<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="It&apos;s a bolg that belongs to a strive programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="Ty_Isaac">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="It&apos;s a bolg that belongs to a strive programmer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ty_Isaac">
<meta name="twitter:description" content="It&apos;s a bolg that belongs to a strive programmer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/23/人工智能专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/23/人工智能专题复习/" itemprop="url">
                  人工智能复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T11:04:37+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/23/人工智能专题复习/" class="leancloud_visitors" data-flag-title="人工智能复习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="人工智能专题复习"><a href="#人工智能专题复习" class="headerlink" title="人工智能专题复习"></a>人工智能专题复习</h1><p>Made by ® Isaac. Ty</p>
<p>hejizh@sdu.edu.cn</p>
<p>主要复习内容:</p>
<ol>
<li><ul>
<li>[ ] 知识的表示方法（*）</li>
</ul>
</li>
<li><ul>
<li>[ ] 搜索技术（*）</li>
</ul>
<p>盲目搜索方法 ；       启发式搜索方法</p>
<p>与/或图搜索方法；   博弈树搜索方法</p>
</li>
<li><ul>
<li>[ ] 经典逻辑理论（*） </li>
</ul>
</li>
<li><ul>
<li>[ ] 产生式系统（*）</li>
</ul>
</li>
<li><ul>
<li>[ ] 不确定性推理模型</li>
</ul>
</li>
<li><p>-[ ] 计算智能（ * ）蚁群算法、粒子群算法、</p>
</li>
<li><p>-[ ] 机器学习（*）归纳学习、决策树学习、ID3、神经网络</p>
</li>
<li><p>-[ ] AI中的其它技术介绍</p>
</li>
</ol>
<h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><ul>
<li>[ ] 逻辑表示</li>
<li>[ ] 产生式规则表示法</li>
<li>[ ] 语义网络表示法</li>
<li>[ ] 框架理论表示法</li>
<li>[ ] 软件技术架构与框架理论关系</li>
<li>[ ] 知识图谱</li>
</ul>
<h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p>直接表示、逻辑表示、产生式规则表示、语义网络表示法、框架表示法、脚本方法、过程表示</p>
<h4 id="逻辑表示法"><a href="#逻辑表示法" class="headerlink" title="逻辑表示法"></a>逻辑表示法</h4><ul>
<li>一阶谓词逻辑式谓词逻辑中最直观的一种逻辑。以谓词形式来表示动作的主体、客体，客体可以有多个。</li>
<li>谓词逻辑规范表达式：$P(x_1,x_2,x_3,…)$，P是谓词，x~i~是主体与客体</li>
<li>存在问题：谓词表示越细，推理越慢、效率越低，但表示清楚</li>
</ul>
<h4 id="产生式规则表示法"><a href="#产生式规则表示法" class="headerlink" title="产生式规则表示法"></a>产生式规则表示法</h4><ul>
<li><p>可以看成断言是一个语言变量的值或是多个语言变量间的关系的陈述句，语言变量的值或语言变量间的关系可以使一个词，不一定是数字</p>
</li>
<li><p>基本特征：</p>
<ul>
<li>数据库：存放构成产生式的基本元素，又是产生式的作用对象</li>
<li>一组规则：产生式本身</li>
<li>一个解释程序：从匹配成功的规则中选出一个加以执行</li>
</ul>
</li>
<li><p>基本结构：</p>
<ul>
<li>工作存储器(数据库)：存放当前已知的数据，包括推理过程中形成的中间结论。</li>
<li>产生式规则：每条产生式分左右两个部分，左部表示激活条件，右部表示产生结果。</li>
<li>规则解释程序：<ul>
<li>匹配器：判断规则条件是否成立</li>
<li>冲突消解器：选择可调用的规则</li>
<li>解释器：执行规则的动作。在满足结束条件时终止产生式系统</li>
</ul>
</li>
</ul>
</li>
<li><p>推理方法</p>
<p>正向、反向、双向、与或树</p>
<ul>
<li>正向：从已知事实出发，逐步推导出最后结论。</li>
</ul>
</li>
</ul>
<ul>
<li>反向：首先提出假设，然后验证这些假设的真假性，找到假设成立的所有证据或事实。</li>
<li><p>双向：既自顶向下、又自底向上作双向推理，直至某个中间界面上两方向结果相符便成功结束。</p>
</li>
<li><p>优点：</p>
<ul>
<li>模块性：规则与规则之间相互独立</li>
<li>灵活性：知识库易于增加、修改、删除</li>
<li>自然性：方便地表示专家的启发性知识与经验</li>
<li>透明性：易于保留动作所产生的变化、轨迹</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>知识库维护难</li>
<li>效率低。为了模块一致性</li>
<li>理解难。由于规则一致性彼此之间不能调用</li>
</ul>
</li>
</ul>
<h4 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h4><ul>
<li>表示形式：每一个要表达的事实用一个“结点”表示，而事实之间用“弧线”表示。即，有向图表示的三元组（结点1，弧，结点2）连接而成。</li>
<li>类属关系：类属关系是指有<strong>共同属性</strong>的不同事物间的分类关系、成员关系或实例关系<ul>
<li>常见属性：<ul>
<li>A-Kind-of  表示一个事物是另一个事物的一种类型</li>
<li>A-member-of  表示一个事物是另一个事物的成员</li>
<li>Is-a   表示一个事物是另一个事物的实例</li>
</ul>
</li>
</ul>
</li>
<li>包含关系：也称聚类关系，是指具有组织或结构特征的“部分与整体”之间的关系。（包含关系一般不具备属性的继承性）<ul>
<li>常见属性：<ul>
<li>Part-of 一个事物是另一个事物的一部分</li>
</ul>
</li>
</ul>
</li>
<li>属性关系：事物和其他属性之间的关系<ul>
<li>常见属性：<ul>
<li>Have   表示一个节点具有另一个节点所描述的属性 </li>
<li>Can  一个节点能做另一个节点的事</li>
</ul>
</li>
</ul>
</li>
<li>位置关系：不同事物在位置方面的关系<ul>
<li>常见位置关系：Located-on/-at/-under/inside/outside</li>
</ul>
</li>
<li>相近关系：不同事物在形状、内容等方面相似和接近<ul>
<li>常用相近关系：Similar-to 相似  Near-to 接近</li>
</ul>
</li>
<li>时间关系：指不同事件在其发生时间方面的先后关系<ul>
<li>常用时间关系：Before 表示一个事件在另一个事件之前发生  After 一个事件在一个事件之后发生</li>
</ul>
</li>
<li>多元逻辑关系：</li>
<li>推理方法<ul>
<li>网络匹配：结构上的匹配，包括结点和弧的匹配</li>
<li>继承推理：利用具有继承性质的语义联系建立一些并不一定显示存在于语义网络知识库中的网络结构。</li>
</ul>
</li>
<li>结论：<ul>
<li>语义网络图的好处是直观、清晰</li>
<li>缺点是表达范围有限。</li>
</ul>
</li>
<li>特点：<ul>
<li>结构性好：语义网络是一种结构化的知识表示方法，能够把事物的属性和事物间的各种语义关系显示地表示出来</li>
<li>联想性：语义网络作为人类联想记忆模型提出来，强调的就是事物之间的语义关系</li>
<li>自然性：语义网络实际上是一个带有标示的有向图，可直观的把事物的属性及事物间的语义联系表示出来，便于理解</li>
</ul>
</li>
</ul>
<h4 id="框架表示"><a href="#框架表示" class="headerlink" title="框架表示"></a>框架表示</h4><ul>
<li>定义：框架是由若干个结点和关系（统称槽）构成的网络。是语义网络更一般化形式的一种结构。同语义网络没有本质区别。</li>
<li>表示形式：框架名、槽名、侧面、值</li>
<li>推理方法：没有固定的推理机理。遵循匹配和继承的原理</li>
<li>软件开发过程中框架理论的使用<ul>
<li>人们将相同类型问题的解决途径进行抽象，抽取成一个应用框架Framework，提供一套明确机制，让开发人员很容易的扩展和控制整个Framework开发上的结构。</li>
<li>为某一特定目的实现一个基本的、可执行的架构。包含了应用程序从启动到运行的主要流程，流程中无法确定的步骤留给用户来实现。程序运行时框架系统自动调用用书实现的功能组件。系统的行为是主动的。</li>
</ul>
</li>
<li>性质：<ul>
<li>对事物进行描述。</li>
<li>通过它对一些从感官中没有直接得到的信息进行预测。</li>
<li>可以利用框架知识进行判断推理</li>
<li>可以通过来认识某一类事物</li>
<li>可以通过实例修正框架对某些事物的不完整描述</li>
</ul>
</li>
</ul>
<h4 id="脚本表示"><a href="#脚本表示" class="headerlink" title="脚本表示"></a>脚本表示</h4><ul>
<li>脚本方式式采用一个专用的框架来表示特定领域的知识</li>
<li>脚本通过元语作为槽名来代表要表示的对象的基本行为</li>
<li>有点像电影剧本</li>
</ul>
<h2 id="产生式系统"><a href="#产生式系统" class="headerlink" title="产生式系统"></a>产生式系统</h2><h3 id="产生式系统的基本组成"><a href="#产生式系统的基本组成" class="headerlink" title="产生式系统的基本组成"></a>产生式系统的基本组成</h3><h4 id="组成三要素"><a href="#组成三要素" class="headerlink" title="组成三要素(*)"></a>组成三要素(*)</h4><ol>
<li>一个综合<strong>数据库</strong>—— 存放信息</li>
<li>一组产生式<strong>规则库</strong>—— 知识</li>
<li>一个控制系统<strong>推理机</strong>—— 规则的解释或执行程序（控制策略、推理策略）</li>
</ol>
<p>产生式系统定义：把一组产生式放在一起，让它们相互配合，协同工作，一个产生式生成的结论可以供另一个产生式作为前提使用，以这种方式求得解决问题的系统叫作产生式系统。</p>
<h4 id="产生式系统的特点"><a href="#产生式系统的特点" class="headerlink" title="产生式系统的特点"></a>产生式系统的特点</h4><ul>
<li>数据驱动：从已知事实出发</li>
<li>模块化：知识的无序性</li>
<li>控制系统与问题无关</li>
<li>类似人类认识的过程：规则似乎式模拟人类如何解决问题的自然方法</li>
</ul>
<h4 id="产生式系统的类型"><a href="#产生式系统的类型" class="headerlink" title="产生式系统的类型(*)"></a>产生式系统的类型(*)</h4><ul>
<li>正向推理：从已知事实出发，通过规则库求得结论，也称自底向上或者数据驱动的方式。F规则</li>
<li>反向推理：从目标出发，反向使用规则，求得已知事实，也称自顶向下推理方式或者目标驱动方式。B规则</li>
<li>双向推理：既自顶向下又自底向上，直至达到某个终结环节两个方向的结果相符边成功结束。</li>
</ul>
<h4 id="产生式系统总结"><a href="#产生式系统总结" class="headerlink" title="产生式系统总结"></a>产生式系统总结</h4><ul>
<li>产生式系统是最简单的知识表示方法，也是应用最广泛的知识表示方法，适于表示各种启发式的经验性关联规则，领域专家无需知识工程工具就能够把自己的知识转化成IF-THEN规则</li>
<li>规则选择效率较低，控制策略不灵活，知识表示形式单一</li>
</ul>
<h3 id="产生式系统的搜索策略"><a href="#产生式系统的搜索策略" class="headerlink" title="产生式系统的搜索策略"></a>产生式系统的搜索策略</h3><h4 id="产生式系统的搜索策略-1"><a href="#产生式系统的搜索策略-1" class="headerlink" title="产生式系统的搜索策略"></a>产生式系统的搜索策略</h4><ol>
<li><strong>盲目搜索</strong>：也称为无信息搜索，即只按预定的控制策略进行搜索，在搜索过程中获得的中间信息不用来改进控制策略。</li>
<li><strong>启发式搜索</strong>：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向进行，加速问题的求解过程并找到最优解。</li>
</ol>
<h4 id="图搜索策略"><a href="#图搜索策略" class="headerlink" title="图搜索策略"></a>图搜索策略</h4><ul>
<li>回溯搜索：只保留从初始状态到当前状态的一条路径</li>
<li>图搜索：保留所有已搜索过的路径</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>节点深度： 根节点深度 = 0  ，其他节点深度 = 父节点深度 + 1</li>
<li>路径： 设一节点序列为$(n_0 ,n_1 ,……,n<em>k)$，对于i = 1,…,k，若节点$n</em>{i-1}$具有一个后继节点$n_i$，则该序列称为从$n_0$到$n_k$的路径</li>
<li>路径的耗散值： 一条路径的耗散值等于连接这条路径各节点间所有耗散值的总和。用$C(n_i,n_j)$表示从n~i~到n~j~的路径的耗散值</li>
<li>扩展一个节点： 生成出该节点所有后继节点，并给出它们之间的耗散值。$Expand(n)$。</li>
<li>辅助存储表：open表：未扩展节点表，closed表：已扩展节点表 </li>
</ul>
<h4 id="无信息图搜索过程"><a href="#无信息图搜索过程" class="headerlink" title="无信息图搜索过程"></a>无信息图搜索过程</h4><ul>
<li>深度优先搜索：<ul>
<li>栈实现</li>
<li>一般不能保证找到最优解。当深度限制不合理时，可能找不到解。可将算法改为可变深度限制。最坏的情况搜索空间等同于穷举</li>
<li>缺点：如果目标节点不在搜索所进入的分支上而该分支又是一个无穷分支，则就得不到解。</li>
<li>优点：如果目标节点恰好在搜索所进入的分支上，则可以较快地得到解</li>
</ul>
</li>
<li>宽度优先搜索：<ul>
<li>队列实现</li>
<li>当问题为单位耗散值时，且问题有解时，一定能找到最优解</li>
<li>方法与问题无关，具有通用性。</li>
<li>效率较低，属于图搜索方法</li>
<li>缺点：当目标节点距离初始节点较远时会产生许多无用的节点，搜索效率低</li>
<li>优点：只要问题有解，则总可以得到解，是完备的，而且是最短路径的解。</li>
</ul>
</li>
<li>回溯与宽度优先方法结合<ul>
<li>目的：解决宽度优先方法的空间问题和回溯方法不能找到最优解的问题</li>
<li>思想：首先个给回溯法一个比较小的深度限制，然后逐渐增加深度限制，直到找到解或遍历所有分支</li>
</ul>
</li>
</ul>
<h4 id="启发式图搜索"><a href="#启发式图搜索" class="headerlink" title="启发式图搜索"></a>启发式图搜索</h4><p>利用知识来引导搜索，达到减小搜索范围，降低问题复杂度的目的。</p>
<ol>
<li><p>启发信息的强度 </p>
<ul>
<li>强：降低搜索工作量，但可能导致找不到最优解。</li>
<li>弱：一般会使工作量降低不如强的多，极限情况下变为盲目搜索，但是可能会找到最优解</li>
</ul>
</li>
<li><p>启发信息</p>
<p>引入启发知识，在保证找到最佳解的情况下，尽可能减少搜索范围，提高搜索效率。</p>
</li>
<li><p>基本思想</p>
<p>定义启发函数$f$ ，对当前搜索状态进行评估，找出一个最有希望的节点来扩展。</p>
</li>
<li><p>A算法与A*算法定义</p>
<p>或图通常采用如下形式的<strong>估计函数</strong>时，称为A算法。</p>
<p>$f(n)=g(n)+h(n)$</p>
<p>$g(n)$表示从<strong>s到n点费用的估计</strong>，因为n为当前节点，搜索已达到n点，所以g$(n)可$</p>
<p>计算出。</p>
<p>$h(n)$表示从<strong>n到目标接近程度的估计</strong>，因为尚未找到解路径，所以$h(n)$仅仅是估计值。</p>
</li>
<li><p><strong>A算法(最好优先搜索)</strong>，适用于<strong>或图</strong>搜索。在所有待扩展结点中优先选择最有希望的结点进行扩展。在搜索过程中如果早期选择了一个错误，最好优先搜索提供了<strong>修改的机会</strong>，这是最好优先搜索算法的关键。 但是<strong>A算法并未显示地给出如何定义<u>启发函数</u>，A*算法就是对A算法的启发函数加上限制后的一种算法</strong>。</p>
</li>
</ol>
<h4 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h4><ul>
<li>$g(n)$ 从S到n的最短路径的<strong>耗散值</strong></li>
<li>$h(n)$ 从n到G的最短路径的<strong>耗散值</strong></li>
<li>$f(n)=g(n)+h(n)$ 从S经过n到G的最短路径<strong>耗散值</strong></li>
<li>$g’(n), h’(n), f’(n)$ 分别式$g(n), h(n), f(n)$的估计值</li>
</ul>
<h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>$f(n)=g(n)+h(n)$ </p>
<ol>
<li>若令$h(n)\equiv0$ ，则A算法相当于宽度优先搜索，因为上一层节点的搜索费用一般比下一层的小</li>
<li>若$g(n)\equiv 0$ ，则相当于最佳优先搜索算法</li>
<li>$g(n)\equiv h(n)\equiv0$ 相当于随机算法</li>
<li><strong>特别是当要求 $h(n) \le h’(n)$，就称为这种A算法为A* 算法</strong></li>
</ol>
<h4 id="A-算法性质"><a href="#A-算法性质" class="headerlink" title="A* 算法性质"></a>A* 算法性质</h4><p>定理1： 对有限图，如果从初始节点s到目标节点t有路径存在，则算法A一定成功</p>
<p>在A算法中，如果满足条件：</p>
<ol>
<li>g(n)是对g*(n)的估计 g(n)&gt;0 </li>
<li>h(n)≤h*(n)</li>
</ol>
<p>则A算法称为A*算法</p>
<h3 id="产生式系统-1"><a href="#产生式系统-1" class="headerlink" title="产生式系统"></a>产生式系统</h3><ul>
<li>[ ] 与或图的搜索及与或图启发式搜索算法AO*</li>
<li>[ ] 与或图搜索中的能解节点和不能解节点</li>
<li>[ ] 博弈树搜索</li>
<li>[ ] α-β剪枝的条件</li>
<li>[ ] 使用α-β剪枝规则完成博弈树搜索的剪枝</li>
</ul>
<h4 id="与或图表示问题"><a href="#与或图表示问题" class="headerlink" title="与或图表示问题"></a>与或图表示问题</h4><ul>
<li>与或图是一个超图，节点间通过连接符连接</li>
<li>K-连接符</li>
<li>$K(n,N) = C_n + k(n_1,N)+…+k(n_i,N)$</li>
<li>其中N为终结节点 ， $C_n$为连接符的耗散值</li>
</ul>
<h5 id="能解节点"><a href="#能解节点" class="headerlink" title="能解节点"></a>能解节点</h5><ul>
<li>终节点是能解节点</li>
<li>若非终节点有“或”子节点时，当前仅当至少有一能解解时，该非终节点能解</li>
<li>若非终节点有“与”子节点时，当且仅当其子节点均能解时，该非终节点才能解。</li>
</ul>
<h5 id="不能解节点"><a href="#不能解节点" class="headerlink" title="不能解节点"></a>不能解节点</h5><ul>
<li>没有后裔的非终节点式不能解节点</li>
<li>若非终节点有“或”子节点，当前仅当所有子节点均不能解，该非终节点不能解</li>
<li>若非终节点有“与”子节点，当至少有一个子节点不能解时，该非终节点才能解</li>
</ul>
<h4 id="与或图启发式搜索算法AO"><a href="#与或图启发式搜索算法AO" class="headerlink" title="与或图启发式搜索算法AO*"></a>与或图启发式搜索算法AO*</h4><ul>
<li><p>AO* 算法两个过程</p>
<ul>
<li><p>图生成过程，即扩展节点（利用起发信息进行）</p>
</li>
<li><p>计算耗散值的过程（根据与或关系）</p>
</li>
</ul>
</li>
<li><p>具有最小耗散值的解图称为最佳解图，其值也用$h^*(n)$表示</p>
</li>
</ul>
<h4 id="博弈树搜索"><a href="#博弈树搜索" class="headerlink" title="博弈树搜索"></a>博弈树搜索</h4><ul>
<li>博弈问题特点：<ul>
<li>双人对弈、轮流走步</li>
<li>信息完备，双方所得到的信息一样</li>
<li>零和，对一方有利的棋，对另一方不利，不存在对双方有利或无利的棋</li>
<li>博弈过程寻找对数必败态的过程</li>
<li>双方无法干预对方选择</li>
<li>可使用图搜索，但是效率很低</li>
</ul>
</li>
<li><p>博弈实例：</p>
<ul>
<li>下棋双方对立</li>
<li>一方为正方，MAX节点</li>
<li>另一方反方，MIN节点</li>
<li>正方反方交替走步，MAX节点MIN节点交替出现</li>
<li>图中所有终结点均表示该选手必输的情况，取胜方的目标式设法使棋局发展为结束在对方走步时的终结点上。</li>
</ul>
</li>
<li><p>博弈策略考虑问题：</p>
<ul>
<li>对MIN走后的每一个MAX结点，必须证明MAX对MIN可能走的每一个棋局对弈后能获胜，即MAX必须考虑应付MIN的所有招法。因此MAX结点可看成<strong>与结点</strong>。</li>
<li>对MAX走后的每一个MIN结点，只需证明MAX有一步能走赢就可以，即MAX只要考虑走出一步棋使MIN无法招架。因此MIN结点可看成<strong>或节点</strong>。</li>
</ul>
</li>
<li><p>极大极小搜索过程—-对各个局面进行评估</p>
<ul>
<li>评估目的：对后面的状态提前考虑，并且以各种状态的评估值为基础做出最好的选择</li>
<li>评估方法：用评价函数对棋局进行评估<ul>
<li>赢的评估值设为+∞，输的评估值设为-∞，平局的评估值设为0</li>
</ul>
</li>
<li>评估的标准：由于下棋的双方是对立的，只能选择其中一方为评估的标准方</li>
<li>由于正方和反方交替走步，因此MAX节点和MIN节点会交替出现。</li>
<li>正方（MAX节点）从所有子节点中，选取具有<strong>最大评估值的节点</strong>。</li>
<li>反方（MIN节点）从所有子节点中选取具有<strong>最小评估值的节点</strong></li>
<li>反复进行选取，可以得到双方各个节点的评估值</li>
</ul>
</li>
</ul>
<h4 id="alpha-beta-搜索过程"><a href="#alpha-beta-搜索过程" class="headerlink" title="$\alpha-\beta$搜索过程"></a>$\alpha-\beta$搜索过程</h4><p>在极小极大搜索过程中，必须求出所有终端节点的评估值，当考虑的棋步比较多时，计算量会大大增加。为提高搜索效率，引入了通过对评估值的上下限进行估计，从而减少需进行评估的节点范围的$\alpha-\beta$剪枝法</p>
<ul>
<li><p>Max节点的评估下限值 $\alpha$</p>
<p>作为正方出现的Max节点，假设它的MIN子节点有N个，那么当它的第一个MIN子节点的评估值为$\alpha$时，对于其他子节点</p>
<ul>
<li>有高过$\alpha$的，就取最高的值作为MAX节点的评估值</li>
<li>没有高估的，则该MAX的节点评估值为$\alpha$</li>
<li>总之Max节点的估计值不会低于$\alpha$，$ \alpha$称为该MAX节点的评估下限值</li>
</ul>
</li>
<li><p>MIN节点的评估上限值$\beta$</p>
<p>作为反方出现的MIN节点，假设它的MAX子节点有N个，那么当它的第一个MAX子节点的评估值为$\beta$时，对于其他子节点</p>
<ul>
<li>有低于$\beta$的，就取那个低于$\beta$的值作为该MIN节点的估计值</li>
<li>没有低于的，则该MIN节点的估计值取$\beta$</li>
<li>总之，该MIN节点的评估值不会高过$\beta$，这个$\beta$就称为该MIN节点的评估上限值</li>
</ul>
</li>
<li><p>$\alpha$剪枝法</p>
<p>设MAX节点的下限为$\alpha$，则其所有MIN子节点中，其评估值的$\beta$上限小于等于$\alpha$的节点，其以下部分的搜索都可以停止了，即对这部分进行$\alpha$剪枝。</p>
</li>
<li><p>$\beta $剪枝法</p>
<p>设MIN节点的上限为$\beta$，则其所有的MAX子节点中，其评估值的$\alpha$下限大于等于 $\beta$的节点，其以下部分的搜索都可以停止了，即对这部分进行$\beta$剪枝。</p>
</li>
<li><p>MAX节点的下界为$\alpha$，MIN节点的上界为$\beta$。则剪枝的条件为：</p>
<ul>
<li>祖先节点的$\alpha$值 $\ge$ 后辈节点的$\beta$值时，$\alpha$剪枝</li>
<li>祖先节点的$\beta$值$ \le $后辈界节点的$\alpha$值时，$\beta$剪枝</li>
</ul>
</li>
</ul>
<h2 id="经典逻辑理论"><a href="#经典逻辑理论" class="headerlink" title="经典逻辑理论"></a>经典逻辑理论</h2><ol>
<li><p>归结原理</p>
<p>一种定理证明方法，从理论上解决了定理证明问题。</p>
<p>在有限步内给予判定。</p>
</li>
<li><p>子句和子句集</p>
<p>子句：</p>
<ul>
<li>无量词约束</li>
<li>元素只是文字的析取</li>
<li>否定符只作用于单个文字</li>
<li>元素间默认为合取</li>
</ul>
<p>子句集：合取范式形式下的子命题（元素）的集合</p>
<p>文字：不含任何连接词的谓词公式</p>
<p>子句：一些文字的析取（谓词的和）</p>
<p>子句集求取： G ——&gt;SKOLEM范式 ——&gt;消去存在变量——&gt;以 ， 取代 </p>
</li>
<li><p>公式G和由公式求取的子句集的关系</p>
</li>
<li><p>归结的一般过程</p>
<ul>
<li>将命题写成合取范式</li>
<li>求出子句集</li>
<li>对子句集使用归结推理规则</li>
<li>归结式作为新子句参加归结</li>
<li>归结式为空，s不可满足的（矛盾），原命题成立</li>
</ul>
</li>
<li><p>置换/合一，最一般合一者</p>
<p>置换：在一个谓词公式中用置换项去置换变量，形如${t_1/x_1,t_2/x_2,…,t_n/x_n}$的有限集合。其中$x_i$是变量，$t$是不同于$x_i$的项；$t_i/x_i$表示用$t_i$置换$x_i$，并且要求$t_i$与$x_i$不相同，而且$x_i$不能循环出现在另一个t中</p>
<p>合一：寻找相对变量的置换，使两个谓词公式一致。设有公式集$F={F_1,F_2,…,F_n}$，若存在一个置换$\theta$，可使$F_1\theta = F_2\theta=…=F_n\theta$，则称$\theta$是F的一个合一。一个公式集的合一不唯一</p>
</li>
<li><p>Skolem标准型（斯克林范式）</p>
<ul>
<li>前束范式：公式A是一个前束范式，如果A中的一切量词都位于该公式的最左边（不含否定词），且这些量词的辖域都延伸到公式末端。</li>
<li>把所有的量词都提到前面去，然后消掉所有量词<ul>
<li>原则：消去存在量词，略去全称量词</li>
<li>左边有全称量词的存在量词，消去时应该改写成为全称量词的函数；如没有则改写成常量。</li>
</ul>
</li>
<li>SKOLEM定理：谓词逻辑的任意公式都可以化为与之等价的前束范式，但是前束范式不唯一</li>
<li>SKOLEM标准形：消去量词后的谓词公式</li>
</ul>
</li>
<li><p>用归结法证明问题(*)</p>
</li>
<li><p>归结过程的控制策略及策略的完备性</p>
<ul>
<li>解决问题：归结方法的知识爆炸</li>
<li>控制策略的目的：归结点尽量少</li>
<li>控制策略的原则：给出控制策略，以使仅对选择合适的子句间方可做归结，避免多余的、不必要的归结式出现。或者说，少做些归结仍能导出空子句。</li>
<li>采用支撑集 </li>
<li>线性归结：线性归结策略首先从子句集中选取一个称作顶子句的子句C0开始作归结。归结过程中所得到的归结式Ci立即同另一子句B_i进行归结得归结式Ci+1</li>
<li>单元归结：单元归结策略要求在归结过程中，每次归结都有一个子句是单元子句（只含一个文字的子句）或单元因子。显而易见，此方法可以简单地削去另一个非单子句中的一个因子，使其长度减少，构成简单化，归结效率较高。</li>
<li>输入归结</li>
</ul>
</li>
</ol>
<h2 id="不确定性推理模型"><a href="#不确定性推理模型" class="headerlink" title="不确定性推理模型"></a>不确定性推理模型</h2><h3 id="Bayes贝叶斯网"><a href="#Bayes贝叶斯网" class="headerlink" title="Bayes贝叶斯网"></a>Bayes贝叶斯网</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>一系列变量的联合概率分布的图形表示；一个表示变量之间的相互依赖关系的数据结构；图论与概率论的完美结合</li>
<li>贝叶斯网就是一个在弧的连接关系上加入连接强度的因果关系网络。是一种变形的语义网络（特殊的有向无环图）DAG+CPT</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>两个部分：DAG+CPT<ul>
<li>贝叶斯网络结构图，这是一个<strong>有向无环图</strong>（DAG:Directed Acyclic Graph），其中图中的每个节点代表相应的变量。当有向弧由节点A指向节点B时，则称：A是B的父节点；B是A的子节点。</li>
<li>节点和节点之间的<strong>条件概率表</strong>（Conditional Probability Table, CPT），也就是一系列的概率值，表示了局部条件概率分布。P(node|parents) 。</li>
</ul>
</li>
<li>目的：由证据得出原因发生的概率。即观察到P(Y)，求P(X|Y)</li>
</ul>
<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><ul>
<li><p>有向非循环图是各个节点变量关系传递的合理表达形式。</p>
</li>
<li><p>条件概率的引入使得计算较之全连接网络有了大大的简化。</p>
</li>
<li><p>CPT表(条件概率表)相对比较容易得到，有时可以用某种概率分布表示，需要做的只是计算表示的参数。</p>
</li>
<li><p>简单联合概率可以直接从网络关系上得到</p>
<ul>
<li><p>$P(X,Y)=P(X)P(Y|X)$</p>
</li>
<li><p>$P(X,Y,Z)=P(X)P(Y)P(Z|X,Y)$</p>
</li>
<li><p>例图中的联合概率密度为：$P(S,C,L,E)=P(E|S,C,L)<em>P(L|S,C)</em>P(C|S)*P(S)$</p>
</li>
<li><p>E与L在S条件下独立，所以$P(E|S,C,L)＝P(E|S,C) $</p>
<p>L与C在S, E条件下独立，所以$P(L|S,C)=P(L|S) $       </p>
<p>C与S在E条件下独立，所以$P(C|S)=P(C)$</p>
</li>
</ul>
</li>
</ul>
<h4 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h4><ul>
<li><p>独立</p>
<ul>
<li><p>$P(X,Y) = P(X)P(Y)$</p>
</li>
<li><p>$P(X|Y)= P(X)$</p>
<p>$P(Y|X)= P(Y)$</p>
</li>
</ul>
</li>
<li><p>对于X,Y,E：X与Y在给定E的条件下独立</p>
<ul>
<li><p>$P(X|Y,E)= P(X|E)$</p>
</li>
<li><p>$  P(Y|X,E)= P(Y|E)   $  </p>
<p>例如$P(E|L,S)=P(E|S),P(L|E,S)=P(L|E)$</p>
</li>
</ul>
</li>
<li><p>多个变量组：d分离(d-separate)</p>
<ul>
<li><p>$P(X_1,X_2,…,X_n|Y_1,Y_2,…,Y_m,E_1,E_2,…,E_p) =P(X_1,X_2,…,X_n|E_1,E_2,…,E_p) $</p>
</li>
<li><p>如果一组节点$X$在给定$E$的条件下，从$X_i$到$Y_j$的每一条通路都被$E_k$  d分离，则称X独立于另一组节点Y</p>
</li>
<li><p>D分离是一种寻找条件独立的有效方法</p>
</li>
<li><p>D分离-串行Linear连接</p>
<p>$X \rightarrow Z\rightarrow Y$ 串行事件中，事件X通过事件Z影响事件Y，反之事件Y也是通过事件Z影响事件X。但是如果原因证据Z是给定的，那么通道就被阻塞，X和Y就是独立的了。 $X,Y$被节点$Z$ D分离</p>
</li>
<li><p>D分离-分叉Diverging连接</p>
<p>如果父节点Z是已知的，没有更多的信息能够通过Z影响到所有子节点。同理父节点Z是已知时，子节点$X,…,N$是相互独立的。称子节点$ X,…,N$是被$Z$节点D分离的</p>
</li>
<li><p>D分离-汇集Converging连接</p>
<p>如果不从父节点得到推断，子节点Z就一无所知，那么，父节点是相互独立的，它们之间没有相互影响。</p>
<p>但是如果某事件影响了Z，那么，各个父节点就不是相互独立的了。该事件可以直接影响Z，也可以通过它的后代节点影响Z。这种现象称作条件依存。总之，如果子节点有了变化，或子节点的后代节点发生变化，信息是可以通过汇集连接传播的。</p>
<p>E能D分离S和C</p>
</li>
</ul>
</li>
</ul>
<h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><ul>
<li>因果推理是从起因到效果。 主要操作：按照给定证据的V和它的所有双亲的联合概率，重新表达给定证据的寻问结点的所求条件概率。</li>
<li>诊断推理是从效果到起因。 主要思想：利用贝叶斯规则将诊断推理转化为因果推理</li>
<li>辩解推理：因果推理与诊断推理结合使用。推理使用嵌入在一个诊断推理中的因果推理。</li>
</ul>
<ul>
<li>计算结果的语义解释（*）</li>
</ul>
<h3 id="主观Bayes贝叶斯网"><a href="#主观Bayes贝叶斯网" class="headerlink" title="主观Bayes贝叶斯网"></a>主观Bayes贝叶斯网</h3><h4 id="主观Bayes："><a href="#主观Bayes：" class="headerlink" title="主观Bayes："></a>主观Bayes：</h4><ul>
<li>贝叶斯规则 $P(B|A)=\frac{P(A|B)P(B)}{P(A)}$</li>
<li>思路：先定好怎么办，再凑公式</li>
<li>LS：充分似然率  $LS = \frac{O(B|A)}{O(B)}=\frac{P(A|B)}{P(A|-B)}$，A为真时对B的影响</li>
<li>LN：必要似然率 $LN = \frac{O(B|-A)}{O(B)}=\frac{P(-A|B)}{P(-A|-B)}$，A为假时对B的影响</li>
</ul>
<h4 id="几率函数O-x-：-O-x-frac-P-x-1-P-x"><a href="#几率函数O-x-：-O-x-frac-P-x-1-P-x" class="headerlink" title="几率函数O(x) ：$O(x)=\frac{P(x)}{1-P(x)}$"></a>几率函数O(x) ：$O(x)=\frac{P(x)}{1-P(x)}$</h4><ul>
<li>P(x)=0，O(x)=0 假；逻辑不发生</li>
<li>P(x)=0.5，O(x)=1 可能发生/不发生</li>
<li>P(x)=1，O(x)=∞ 真；逻辑发生</li>
<li>$O(B|A)=LS*O(B)$</li>
<li>$O(B|-A) =LN*O(B)$</li>
</ul>
<h4 id="取值规则"><a href="#取值规则" class="headerlink" title="取值规则"></a>取值规则</h4><ul>
<li>LS , LN ≥ 0，不独立。都在[0,∞)</li>
<li>LS , LN 不能同时&gt;1 或 &lt;1 。（证明）</li>
<li>LS , LN 可同时 = 1</li>
</ul>
<h4 id="计算A1-A2必然发生时，求结论B1的更新值"><a href="#计算A1-A2必然发生时，求结论B1的更新值" class="headerlink" title="计算A1,A2必然发生时，求结论B1的更新值"></a>计算A1,A2必然发生时，求结论B1的更新值</h4><ul>
<li>A 必然出现时 P(A)=1:<ul>
<li>$O(B)=\frac{P(B)}{1-P(B)}$</li>
<li>$O(B|A) =LS*O(B)$</li>
<li>$O(B|-A) =LN*O(B)$</li>
<li>$P(A)=\frac{O(A)}{1+O(A)}$</li>
</ul>
</li>
</ul>
<h3 id="确定性方法-CF模型"><a href="#确定性方法-CF模型" class="headerlink" title="确定性方法-CF模型"></a>确定性方法-CF模型</h3><h4 id="规则A-—B，可信度表示为CF-B-A-："><a href="#规则A-—B，可信度表示为CF-B-A-：" class="headerlink" title="规则A —B，可信度表示为CF(B,A)："></a>规则A —B，可信度表示为CF(B,A)：</h4><ul>
<li>$CF(B,A)=MB(B,A)-MD(B,A)$</li>
<li>CF是由证据A得到的假设B的确定性因子</li>
<li>MB是证据A得到假设B的<strong>信任增加度量</strong></li>
<li>MD是证据A得到的假设B的<strong>不信任增加度量</strong></li>
<li>确定性因子把信任与不信任组合在了一起</li>
</ul>
<h4 id="MB和MD表达式（-）"><a href="#MB和MD表达式（-）" class="headerlink" title="MB和MD表达式（*）"></a>MB和MD表达式（*）</h4><p>$$ \begin{equation}MB(B,A)=\begin{cases} 1 &amp;\mbox P(B)=1 \ \frac {max{P(B|A),P(B)}-P(B)}{1-P(B)} &amp;\mbox 其它\end{cases}\end{equation}$$</p>
<p>$$\begin{equation}MD(B,A)=\begin{cases}1 &amp;\mbox P(B)=0 \\ \frac{min{P(B|A),P(B)}-P(B)}{-P(B)} &amp;\mbox 其它\end{cases}\end{equation}$$</p>
<h4 id="CF-B-A-表达式-（-）"><a href="#CF-B-A-表达式-（-）" class="headerlink" title="CF(B,A)表达式  （*）"></a>CF(B,A)表达式  （*）</h4><p>$$\begin{equation}CF(B,A)=\begin{cases}\frac{P(B|A)-P(B)}{1-P(B)} &amp;\mbox P(B|A) \ge P(B) \ \frac{P(B|A)-P(B)}{P(B)} &amp;\mbox  P(B|A) &lt; P(B)\end{cases}\end{equation}$$</p>
<h4 id="CF-B-A-表示的意义"><a href="#CF-B-A-表示的意义" class="headerlink" title="CF(B,A)表示的意义"></a>CF(B,A)表示的意义</h4><ul>
<li>证据为真时，相对于P(~B)=1-P(B)来说，A对B为真的支持程度。即A发生更 支持B发生</li>
<li>相对于P(B)来说，A对B为真的不支持程度。即A发生不支持B发生</li>
<li>$-1 \le CF(B,A) \le 1$</li>
</ul>
<h4 id="CF的特殊值"><a href="#CF的特殊值" class="headerlink" title="CF的特殊值"></a>CF的特殊值</h4><ul>
<li>CF(B,A) = 1 前提真，结论必真 P(B|A)=1</li>
<li>CF(B,A) = -1前提真，结论必假 P(B|A)=0</li>
<li>CF(B,A) = 0 前提真假与结论无关  P(B|A) = P(B)</li>
<li>实际中CF(B,A)由专家确定，并非由P(B|A),P(B)计算得到</li>
</ul>
<h4 id="证据A的可信度表示为CF-A"><a href="#证据A的可信度表示为CF-A" class="headerlink" title="证据A的可信度表示为CF(A)"></a>证据A的可信度表示为CF(A)</h4><ul>
<li>特殊值<ul>
<li>CF(A)=1  前提肯定真</li>
<li>CF(A)=-1 前提肯定假</li>
<li>CF(A)=0  对前提一无所知</li>
<li>CF(A)&gt;0 , 表示A以CF(A)程度为真</li>
<li>CF(A)&lt;0 , 表示A以CF(A)程度为假</li>
</ul>
</li>
</ul>
<h4 id="确定性方法-CF模型计算"><a href="#确定性方法-CF模型计算" class="headerlink" title="确定性方法-CF模型计算"></a>确定性方法-CF模型计算</h4><ul>
<li>规则推理计算</li>
<li>规则合成计算</li>
<li>简单的推理计算<ul>
<li>规则推理计算 1，2，（3，4）</li>
<li>是否必然发生，都乘概率，只是必然概率为1</li>
</ul>
</li>
<li>$$</li>
</ul>
<h3 id="证据理论（DS）"><a href="#证据理论（DS）" class="headerlink" title="证据理论（DS）"></a>证据理论（DS）</h3><ul>
<li>基本概率分配函数m(x)：<ul>
<li>$m(x): 2^U \rightarrow [0,1]$，在U的幂集上定义，取值[0,1]</li>
<li>m(A)表示了证据对U的子集A成立的一种信任度</li>
<li>A属于U，且不等于U，表示对A的精确信任度</li>
<li>A等于U，表示这个数不知如何分配</li>
</ul>
</li>
<li>信任函数Bel(A)：集合和他的子集合的信任总和</li>
<li>似然函数</li>
</ul>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="机器学习可以分为几类"><a href="#机器学习可以分为几类" class="headerlink" title="机器学习可以分为几类"></a>机器学习可以分为几类</h3><p>常见的机器学习方法可分为 连接学习、归纳学习、分析学习和遗传算法与强化学习等</p>
<h3 id="机器学习系统"><a href="#机器学习系统" class="headerlink" title="机器学习系统"></a>机器学习系统</h3><p>应有环境、知识库、学习环节和执行环节四个基本部分组成</p>
<h3 id="实例学习及实例学习的两个空间模型"><a href="#实例学习及实例学习的两个空间模型" class="headerlink" title="实例学习及实例学习的两个空间模型"></a>实例学习及实例学习的两个空间模型</h3><ol>
<li>例子空间(实例)—&gt;解释例子(泛化)—&gt;规则空间(概念)—&gt;选择例子(例化)</li>
<li>例子空间的描述语言可以描述所有例子；规则空间的描述语言可以描述所有规则</li>
<li>例子空间<ul>
<li>示教例子的质量: 不能有错，同时提供正例和反例，逐步分批由选择地送入。</li>
<li>选择的条件：最有力地划分规则空间；证实肯定假设规则的集合；否定假设规则的集合。</li>
</ul>
</li>
<li>解释例子(泛化)<ul>
<li>解释例子的目的是从例子中提出用于搜索空间的信息。把示教例子变换成易于进行符号归纳的形式（有时很难）</li>
</ul>
</li>
<li>规则空间(最根本，真正学习的部分)<ul>
<li>定义：一套符号来规定表示规则的算符、术语，所有的描述都在其中。</li>
<li>归纳方法：从一般到特殊</li>
<li>对规则空间的要求：<ul>
<li>规则空间表达能力与规则空间搜索难度</li>
<li>表示和例子的一致</li>
<li>引入新术语（规则空间）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="归纳学习及学习的偏置：变形空间与候选消除学习"><a href="#归纳学习及学习的偏置：变形空间与候选消除学习" class="headerlink" title="归纳学习及学习的偏置：变形空间与候选消除学习"></a>归纳学习及学习的偏置：变形空间与候选消除学习</h3><h4 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h4><ol>
<li>实例学习：从特殊的训练样例中得到的普遍规律</li>
<li>归纳：保证输出的假设能与训练样例相拟合</li>
<li>归纳假设的一个基本假定（偏置）：对于未见实例最好的假设就是与训练数据最佳拟合的假设</li>
<li>归纳学习假设：任一假设如果在足够大的训练样例样例集中很好地逼近目标函数，它也能在未见实例中很好地逼近目标函数</li>
</ol>
<h4 id="假设从一般到特殊的转化"><a href="#假设从一般到特殊的转化" class="headerlink" title="假设从一般到特殊的转化"></a>假设从一般到特殊的转化</h4><p>任何被较特殊的假设划分为正例的实例都会被较一般的实例划分为正例</p>
<h4 id="Find-S算法：寻找极大特殊假设"><a href="#Find-S算法：寻找极大特殊假设" class="headerlink" title="Find-S算法：寻找极大特殊假设"></a>Find-S算法：寻找极大特殊假设</h4><p>使用more_general_than偏序的搜索算法，从H中最特殊假设（最小假设）开始，然后在假设覆盖正例失败时将其一般化</p>
<p>Find-S算法</p>
<ol>
<li>将h初始化H中最特殊假设</li>
<li>对每个正例x<ul>
<li>对h的每个属性约束$a_i$，如果x满足$a_i$，那么不做任何处理</li>
<li>否则将h中$a_i$替换为x满足的另一个更一般约束</li>
</ul>
</li>
<li>输出假设h</li>
</ol>
<p>Find-S算法重要特点：对以属性约束的合取式描述的假设空间H，保证输出为H中与正例一致的最特殊的假设</p>
<h4 id="变形空间和候选消除算法"><a href="#变形空间和候选消除算法" class="headerlink" title="变形空间和候选消除算法"></a>变形空间和候选消除算法</h4><p>候选消除算法输出与训练样例一致的<strong>所有假设的集合</strong>；在描述这一集合时不需要明确列举所有成员；可用于启发式搜索控制规则来表示，容错性能差。</p>
<ol>
<li><p>一致的定义：一个假设h与训练样例集合D一致，当且仅当对D中每一个样例$<x,c(x)>$都有h(x)=c(x)</x,c(x)></p>
</li>
<li><p>先列表后消除法</p>
<p>能表示变型空间的一种方法是列出其所有成员</p>
<ul>
<li>优点：保证得到所有与训练数据一致的假设</li>
<li>缺点：非常繁琐地列出H中的所有假设，大多数实际的假设空间无法做到。</li>
</ul>
</li>
<li><p>变型空间的更简洁表示</p>
<p>变型空间被表示为它的极大一般g和极大特殊s的成员，这些成员形成了一般和特殊边界的集合，这些边界在整个偏序结构中划分出变型空间。</p>
<p>变型空间方法的初始G集是最上面的一个点（最一般的概念），初始S集是最下面的直线上的点（训练正例），初始H集是整个规则空间。</p>
<p>在搜索过程中，G 集逐步下移（进行特例化），S 集逐步上移（进行泛化），H 逐步缩小。最后H收敛为满足要求的概念。</p>
<p>搜索：使用一个可能合理的假设规则的集合H，H是规则空间的子集，是规则空间中间的一段。</p>
<p>H中最一般的元素组成的子集称为G集合，最特殊的元素组成的子集称为S集合。（H是上界G和下界S之间的一段。）</p>
<p>学习基本思想：尽可能合理的进行特殊化和一般化处理，通过搜索减小H，找到一个假设规则。</p>
<p>具体方法：消除候选元素法</p>
</li>
<li><p>形式化定义</p>
<ul>
<li>极大一般：更一般中的极大者(元)-下确界</li>
<li>极大特殊:更特殊中的极小者(元)-上确界</li>
<li>关于假设空间H和训练数据D的一般边界G，是在H中与D相一致的<strong>极大一般</strong>成员的集合</li>
<li>关于假设空间H和训练数据D的特殊边界S，是在H中与D相一致的<strong>极大特殊</strong>成员的集合</li>
</ul>
</li>
<li><p>候选消除算法</p>
<p>将G集合初始化为H中极大一般假设$G0={&lt;\emptyset,\emptyset,\emptyset,\emptyset,\emptyset,\emptyset,\emptyset&gt;}$</p>
<p>将S集合初始化为H中极大特殊假设$S0={&lt;?,?,?,?,?,?,?&gt;}$</p>
<ul>
<li><p>初始化G和S</p>
</li>
<li><p>如果d是一个<strong>正例</strong></p>
<p>从G中移去所有与d不一致的假设</p>
<p>对S中每个与d不一致的假设s，从S中移出s，把s的所有的极小一般（泛化）式h加入到S中，其中h满足h与d一致，而且G的某个成员比h更一般</p>
</li>
<li><p>如果d是一个<strong>反例</strong></p>
<p>从S中移去所有与d不一致的假设</p>
<p>对G中每个与d不一致的假设g，从G中移出g，把g的所有的极小特殊（例化）式h加入到G中，其中h满足h与d一致，而且S的某个成员比h更特殊</p>
</li>
</ul>
<p>正例去掉G中不符合的概念，然后修改S，归纳出最特殊的结果，尽量少改S</p>
<p>反例去掉S中符合的概念，然后修改G，做特殊化得到最一般的结构，尽量少改G</p>
</li>
<li><p>变型空间法的优缺点</p>
<ul>
<li>搜索空间太大，有可能引起计算爆炸问题（规则总地来说是越扩越多）</li>
<li>抗干扰性差，所有数据驱动方法的通病。解决方法：例子一组一组地给。</li>
<li>采用析取规则，即此算法不可能发现“或”的关系。 </li>
</ul>
</li>
<li><p>归纳偏置</p>
<p>归纳学习需要的预先假定，称为归纳偏置</p>
<ul>
<li><p>一个有偏的假设空间</p>
<p>在EnjoySport例子中，假设³空间限制为只包含属性值的合取（肯定有偏）</p>
<p>因为这一限制，导致假设空间不能够表示简单一些的析取形式的目标概念。</p>
</li>
<li><p>无偏的学习器</p>
<p>为了保证目标概念在假设空间中，需要提供一个假设空间，它能表达所有的可教授概念。换言之，它能表达实例集X的所有子集。</p>
</li>
<li><p>EnjoySport的无偏形式</p>
<p>带来的问题：概念学习算法无法从训练样例中泛化。</p>
<p>要想获得单个目标概念，就必须提供X中所有实例作为训练样例</p>
</li>
<li><p>无偏学习的无用性</p>
<p>归纳学习的一个基本属性：学习器如果不对目标概念的形式做预先的假定，它从根本上无法对未见实例进行分类</p>
</li>
</ul>
</li>
</ol>
<h3 id="基于解释的学习"><a href="#基于解释的学习" class="headerlink" title="基于解释的学习(*)"></a>基于解释的学习(*)</h3><p>基于解释的学习，不考虑很多实例，采用演绎推理，少用归纳。可以克服归纳学习的不可靠问题。</p>
<p>基本思想：利用单个问题的求解例子，依据领域知识对实例进行详细分析，构造求解过程的因果关系的解释结构，并获取控制知识，然后对解释进行推广得到一般性描述，以便用于指导以后求解类似问题。</p>
<p>从本质上是属于演绎学习。</p>
<p>解释的过程是为获得相似问题的解决方法（概念）</p>
<h3 id="决策树学习方法，神经网络学习方法-不要求计算"><a href="#决策树学习方法，神经网络学习方法-不要求计算" class="headerlink" title="决策树学习方法，神经网络学习方法(不要求计算)"></a>决策树学习方法，神经网络学习方法(不要求计算)</h3><h4 id="决策树-Decision-Tree"><a href="#决策树-Decision-Tree" class="headerlink" title="决策树(Decision Tree)"></a>决策树(Decision Tree)</h4><p>一种描述<u><strong>概念空间</strong></u>的有效的归纳推理办法。基于决策树的学习方法可以进行不相关的多概念学习，具有简单快捷的优势，已经在各个领域取得广泛应用。</p>
<ol>
<li><p>基本思想</p>
<p>以信息熵为度量标准，构造一棵熵值下降最快的树，到叶子节点处的熵值为零，此时每个叶节点中的示例都属于同一类。</p>
</li>
<li><p>基本概念</p>
<p>决策树学习采用的是自顶向下的递归方法</p>
<p>决策树的每一层节点依照某一属性值向下分为子节点，待分类的实例在每一节点处与该节点相关的属性值进行比较，根据不同的比较结果朝相应的子节点扩展，这一过程在到达决策树的叶节点时结束，此时得到结论。</p>
<p>从根节点到叶节点的每一条路经都对应着一条合理的规则，规则间各个部分（各个层的条件）的关系是合取关系。整个决策树就对应着一组析取的规则。</p>
<p><u><strong>决策树学习算法的最大优点是，它可以自学习。</strong></u>在学习的过程中，不需要使用者了解过多背景知识，只需要对训练例子进行较好的标注，就能够进行学习。如果在应用中发现不符合规则的实例，程序会询问用户该实例的正确分类，从而生成新的分枝和叶子，并添加到树中。</p>
<p>树是由<u><strong>节点</strong></u>和<strong><u>分枝</u></strong>组成的层次数据结构。<strong>节点</strong>用于存贮信息或知识，<strong>分枝</strong>用于连接各个节点。树是图的一个特例，图是更一般的数学结构，如贝叶斯网络。</p>
<p>决策树是<u><strong>描述分类过程的一种数据结构</strong></u>，从上端的根节点开始，各种分类原则被引用进来，并依这些分类原则将根节点的数据集划分为子集，这一划分过程直到某种约束条件满足而结束</p>
</li>
</ol>
<ul>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%86%B3%E7%AD%96%E6%A0%91.png" alt="决策树图"></p>
<p>可以看到，一个决策树的内部结点包含学习的实例，每层分枝代表了实例的一个属性的可能取值，叶节点是最终划分成的类。如果判定是二元的，那么构造的将是一棵二叉树，在树中每回答一个问题就降到树的下一层。</p>
<p>判定结构可以机械的转变成产生式规则。可以通过对结构进行广度优先搜索，并在每个节点生成“IF…THEN”规则来实现。如图的决策树可以转换成下规则：</p>
<pre><code>IF “个子大”THEN

       IF “脖子短”THEN 

                 IF “鼻子长”  THEN可能是大象
</code></pre></li>
</ul>
<ol>
<li><p>构造决策树(四个问题)</p>
<ul>
<li><p><strong>收集待分类的数据</strong>，这些数据的所有属性应该是完全标注的。</p>
</li>
<li><p><strong>设计分类原则</strong>，即数据的哪些属性可以被用来分类，以及如何将该属性量化。</p>
</li>
<li><p><strong>分类原则的选择</strong>，即在众多分类准则中，每一步选择哪一准则使最终的树更令人满意。</p>
</li>
<li><p><strong>设计分类停止条件</strong>，实际应用中数据的属性很多，真正有分类意义的属性往往是有限几个，因此在必要的时候应该停止数据集分裂：例如</p>
<p>该节点包含的数据太少不足以分裂</p>
<p>继续分裂数据集对树生成的目标(例如ID3中的熵下降准则)没有贡献</p>
<p>树的深度过大不宜再分。</p>
</li>
</ul>
</li>
<li><p>决策树性质</p>
<ul>
<li>证据由属性值对表示</li>
<li>目标函数有离散输出值</li>
<li>需要不相关的描述</li>
<li>容忍训练数据的错误</li>
</ul>
</li>
</ol>
<h4 id="人工神经网络-ANNs"><a href="#人工神经网络-ANNs" class="headerlink" title="人工神经网络(ANNs)"></a>人工神经网络(ANNs)</h4><ol>
<li><p>概述</p>
</li>
<li><p>神经网络表示-<strong><u>非图形符号表示</u></strong></p>
<ul>
<li><p>决策树是一种图形符号表示</p>
<p>– 能表示<strong><u>与或规则</u></strong></p>
<p>– 形象直观地<strong><u>图形符号</u></strong></p>
</li>
<li><p>ANNs非图形符号表示法</p>
<p>– 一种<strong><u>函数表示法</u></strong>；</p>
<p>– 从大量的数据中<strong><u>抽取规则函数</u></strong>（或者根本无法表示的识别能力)</p>
</li>
</ul>
</li>
<li><p>ANN表示的信息</p>
<p>所学的概念是一种非精确表示</p>
</li>
<li><p>ANN的学习</p>
<ul>
<li>提供的训练阳历应是数字信息，且有明确的概念</li>
<li>ANN训练完毕后用于区分其他信息</li>
<li>ANN解决问题的步骤：<ol>
<li>选择确定<strong><u>网络结构</u></strong>：输入层、输出层、隐含层的结点数码以及连接权重</li>
<li>选择<strong><u>学习算法</u></strong></li>
<li><strong><u>训练神经网络</u></strong>直至能输出正确的结构</li>
<li><strong><u>使用神经网络</u></strong></li>
</ol>
</li>
</ul>
</li>
<li><p>网络结构</p>
<ul>
<li><p>双层网络/多层网络</p>
</li>
<li><p>全连接/部分连接神经网络</p>
</li>
<li><p>前馈神经网络—— BP算法</p>
<p>计算每个单元的误差，首先计算输出单元的误差；利用<u><strong>输出单元的误差再计算上一层单元的误差</strong></u>，依次向上传播，因此又称<strong><u>反向传播</u></strong>，又称<strong><u>逆推学习算法</u></strong>，简称BP算法。</p>
</li>
<li><p>随机神经网络—— 模拟退火算法</p>
</li>
<li><p>自组织特征映射神经网络</p>
</li>
</ul>
</li>
<li><p>学习速率</p>
<ul>
<li>ƞ称作学习速率，一般设定为小数</li>
<li>学习速率主要用于控制权重的变化</li>
<li>学习速率ƞ的大小对学习算法的影响：<ul>
<li>过大会引起飘移</li>
<li>过小收敛速度太慢，学习效率不高</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="神经网络学习法中学习速率n的概念"><a href="#神经网络学习法中学习速率n的概念" class="headerlink" title="神经网络学习法中学习速率ƞ的概念"></a>神经网络学习法中学习速率ƞ的概念</h4><h4 id="了解ID3学习算法构建决策树的原理和过程"><a href="#了解ID3学习算法构建决策树的原理和过程" class="headerlink" title="了解ID3学习算法构建决策树的原理和过程"></a>了解ID3学习算法构建决策树的原理和过程</h4><p>采用自顶向下的贪婪搜索遍历可能的决策树空间</p>
<ol>
<li>ID3的思想<ul>
<li><strong>自顶向下</strong>构造决策树</li>
<li>从“哪一个属性将在树的根节点被测试”开始</li>
<li>使用统计测试来确定每一个实例属性单独分类训练样例的能力</li>
</ul>
</li>
<li>ID3的过程<ul>
<li>分类能力最好的属性被选作树的根节点(如年龄、长相、文化程度、收入、工作性质、家庭背景，性别，姓氏等等)</li>
<li>根节点的每个可能值产生一个分支</li>
<li>训练样例排列到适当的分支</li>
<li>重复上述过程</li>
</ul>
</li>
<li>ID3算法<ol>
<li>随机选择训练实例的子集构成训练窗口</li>
<li>重复下列步骤：<ol>
<li>对窗口内的实例集构造其决策树</li>
<li>寻找决策树的一个反例</li>
<li>如果反例存在则将其加入到训练窗口中，并转1；否则返回得到决策树</li>
</ol>
</li>
<li>ID3检查所有的候选属性，选择增益最大的属性A作为根节点，形成数。然后对子树C~1~ ,C~2~ ,…,C~m~以同样处理，递归形成决策树。</li>
</ol>
</li>
<li>ID3和候选消除算法的比较<ul>
<li>ID3的搜索范围是一个完整的假设空间，但不彻底地搜索这个空间</li>
<li>候选消除算法的搜索范围是不完整的假设空间，但彻底地搜索这个空间</li>
<li>ID3的归纳偏置完全是搜索车略排序假设的结果，来自搜索策略</li>
<li>候选消除算法完全是假设表示的表达能力的结果，来自对搜索空间的定义。</li>
</ul>
</li>
</ol>
<h2 id="计算智能"><a href="#计算智能" class="headerlink" title="计算智能"></a>计算智能</h2><h3 id="关于A-B-C智能（-）"><a href="#关于A-B-C智能（-）" class="headerlink" title="关于A,B,C智能（*）"></a>关于A,B,C智能（*）</h3><p>贝兹德克（ Bezdek ）于1992年提出了一种A，B，C智能模型，从而表示ABC与神经网络、模式识别和智能之间的关系：</p>
<ul>
<li>Artificial ，人工的、符号的（非生物的）</li>
<li>Biological ，生物的</li>
<li>Computational ，计算的</li>
</ul>
<p>计算智能是一种智力方式的底层认知，它与人工智能的区别是认知层次从中层下降到底层。中层系统含有知识，底层系统没有知识。</p>
<p>当一个系统只涉及数值(低层)数据，含有模式识别部分，不应用于人工智能意义上的知识，而且系统能够呈现出：计算适应性、计算容错性、接近人的计算速度、计算误差率与人接近，则该系统就是<strong>计算智能系统</strong>。</p>
<p>当一个计算智能系统以非数值方式并加上知识，即认为<strong>人工智能系统</strong>。</p>
<h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><h4 id="算法的思想"><a href="#算法的思想" class="headerlink" title="算法的思想"></a>算法的思想</h4><p>在生物系统中，进化被认为是一种成功的自适应方法，具有很好的健壮性。其主要特点：</p>
<ol>
<li>直接对结构对象进行操作，不存在求导和函数连续性的限定。</li>
<li>具有内在的隐含并行性和更好的全局寻优能力；</li>
<li>采用概率化的寻优方法，能自动获取和指导优化的搜索空间。</li>
<li>自适应地调整搜索方向，不需要确定的规则</li>
</ol>
<p>遗传算法将“优胜劣汰，适者生存”的生物进化原理引入优化参数形成的编码串群体中，按所选择的<strong><u>适应度函数</u></strong>并通过遗传中的<u><strong>复制、交叉及变异</strong></u>对个体进行筛选，<strong>适应度高</strong>的个体被保留下来，组成新的群体，新的群体既继承了上一代的信息，又优于上一代</p>
<h4 id="三种基本操作：复制、交叉、变异"><a href="#三种基本操作：复制、交叉、变异" class="headerlink" title="三种基本操作：复制、交叉、变异"></a>三种基本操作：复制、交叉、变异</h4><ol>
<li><p>复制：从一个旧种群中选择生命力强的个体位串产生新种群的过程，具有<strong>高适应度</strong>的位串更有可能在下一代中产生一个或多个子孙。</p>
<p>复制操作可以通过随机方法来实现。首先产生0~1之间均匀分布的随机数，若某串的复制概率为40%，则当产生的随机数在0.40~1.0之间时，该串被复制，否则被淘汰。</p>
</li>
<li><p>交叉：复制操作能从旧种群中选择出优秀者，但不能创造新的染色体。而交叉模拟了生物进化过程中的<strong>繁殖现象</strong>，通过两个染色体的交换组合，来产生新的优良品种。</p>
<p>交叉的过程为：在匹配池中任选两个染色体，随机选择一点或多点交换点位置；交换双亲染色体交换点右边的部分，即可得到两个新的染色体数字串。</p>
</li>
<li><p>变异：用来模拟生物在自然的遗传环境中由于各种偶然因素引起的基因突变，它<strong>以很小的概率随机地改变遗传基因</strong>（表示染色体的符号串的某一位）的值。在染色体以二进制编码的系统中，它随机地将染色体的某一个基因由1变成0，由0变成1.</p>
<p>若只有选择和交叉，而没有变异，则无法在初始基因组合以外的空间进行搜索，使进化过程在早期就陷入局部解而进入终止过程，从而影响解的质量。为了在尽可能大的空间中获得质量较高的优化解，必须采用变异操作。</p>
</li>
</ol>
<h4 id="适应度函数与轮盘赌算法"><a href="#适应度函数与轮盘赌算法" class="headerlink" title="适应度函数与轮盘赌算法"></a>适应度函数与轮盘赌算法</h4><p>在遗传算法中，衡量个体优劣的尺度是<strong><u>适应度</u></strong>，根据适应度的大小决定某些个体是繁殖或是消亡。</p>
<p>通常，适应度是费用、赢利、方差等目标的表达式。</p>
<ol>
<li><p>统一表达式</p>
</li>
<li><p>适应度缩放</p>
</li>
<li><p>复制（轮盘选择）</p>
<ul>
<li>依次累计群体内各个个体的适应度，得相应的累计值$S_i$,最后一个累计值为$S_n$</li>
<li>在$[0,S_n]$区间内产生均匀分布的随机数R</li>
<li>依次用S~i~ 与R相比较，第一个出现S~i~大于或等于R的个体i被选为复制对象</li>
<li>重复(2),(3)直至满足所需要的个体数目。</li>
</ul>
<p>每代群体中，被复制的个体数目由复制概率Pt控制， Pt常取0.1～0.2，也就是说，群体中有90%～80%个体被复制，相应地有10%<br>～20%个体被淘汰，以保持群体大小。</p>
</li>
</ol>
<h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><ol>
<li><p>编码（coding）</p>
<p>遗传算法首先要对实际问题进行编码，用字符串表达问题。这种字符串相当于遗传学中的染色体。每一代所产生的字符串个体总和称为群体。为了实现方便，字符串长度固定，字符选为0或1。</p>
<p>遗传算法的工作对象是字符串，因此对字符串的编码有两点要求：</p>
<ul>
<li>字符串要反映所研究问题的性质</li>
<li>字符串的表达要便于计算处理</li>
</ul>
<p>对于兼有多种性质的问题，可以采用长字符串顺序分别表示。例如，可选25位0/1字符串表示物体的体积、重量及颜色，其中前10位数表示体积量，中间10位数表示重量，后5位数表示颜色。</p>
</li>
</ol>
<h4 id="遗传算法工作步骤（-）"><a href="#遗传算法工作步骤（-）" class="headerlink" title="遗传算法工作步骤（*）"></a>遗传算法工作步骤（*）</h4><p>复制概率$P_t$：用于控制复制与淘汰的个体数目，取值范围0.4~1。</p>
<p>交叉率$P_c$：参加交叉运算的染色体个数占全体染色体总数的比例，取值范围0.4~0.99</p>
<p>变异率$P_m$：发生变异的基因位数所占全体染色体的基因总位数的比例，取值范围0.0001～0.1</p>
<h4 id="与粒子群算法的相同与不同"><a href="#与粒子群算法的相同与不同" class="headerlink" title="与粒子群算法的相同与不同"></a>与粒子群算法的相同与不同</h4><h3 id="群智能（Swarm-Intelligence）"><a href="#群智能（Swarm-Intelligence）" class="headerlink" title="群智能（Swarm Intelligence）"></a>群智能（Swarm Intelligence）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong><u>智能源于社会性的相互作用</u></strong>，群智能发展的基石。</p>
<p>已有的群智能理论和应用研究证明群智能方法是一种能够有效解决<strong><u>大多数优化问题的新方法</u></strong></p>
<h4 id="两大特点"><a href="#两大特点" class="headerlink" title="两大特点"></a>两大特点</h4><p>并行性和分布式</p>
<h4 id="已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法"><a href="#已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法" class="headerlink" title="已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法"></a>已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法</h4><h4 id="群智能典型算法"><a href="#群智能典型算法" class="headerlink" title="群智能典型算法"></a>群智能典型算法</h4><ul>
<li>蚁群算法</li>
<li>粒子群算法</li>
<li>鱼群算法</li>
<li>猴群算法</li>
</ul>
<h4 id="蚁群算法，粒子群算法"><a href="#蚁群算法，粒子群算法" class="headerlink" title="蚁群算法，粒子群算法"></a>蚁群算法，粒子群算法</h4><ol>
<li><p>蚁群算法</p>
<ol>
<li><p>蚁群算法：</p>
<p>蚂蚁觅食的过程，随机移动，遇到食物返回的路上分泌信息素（易挥发的化学性物质），关键路径上的信息素浓度相对高。</p>
</li>
<li><p>蚁群算法原理：</p>
<ul>
<li>基于蚂蚁觅食时最优路径的选择问题，可以构造人工蚁群来解决最优问题</li>
<li>人工蚁群中把具有最简单功能的工作单元看作蚂蚁</li>
<li>人工蚂蚁与自然蚁群相似：优先选择信息素浓度大的路径；区别：人工蚂蚁具有一定的记忆能力，能够记忆已经访问过的节点</li>
<li>人工蚁群在选择吓一跳路径的时候按照一定的算法有意识的寻找最短路径，而不是盲目的。</li>
</ul>
</li>
<li>蚁群算法中的各种行为因子<ul>
<li>范围</li>
<li>环境</li>
<li>觅食规则</li>
<li>移动规则</li>
<li>避障规则</li>
<li>信息素规则</li>
</ul>
</li>
<li>蚁群算法的应用<ul>
<li>聚类问题</li>
<li>路由算法设计</li>
<li>图着色</li>
<li>车辆调度</li>
<li>机器人路径规划</li>
</ul>
</li>
</ol>
</li>
<li><p>粒子群算法</p>
<ol>
<li><p>粒子群优化算法：</p>
<p>模拟鸟群或蜂群的觅食行为。</p>
</li>
<li><p>基本思想：通过群体中个体之间的协作和信息共享来寻找最优解。</p>
</li>
<li><p>粒子群优化算法原理：</p>
<ul>
<li>每个飞行的小鸟抽象为一个无质量、无体积的粒子</li>
<li>每个粒子有一个适应度（评估）函数模拟每只小鸟与食物的<strong>距离</strong></li>
<li>每个粒子有一个<strong>速度</strong>决定它的飞行方向和距离，初始值可以随机确定</li>
<li>每一次单位时间的飞行后，所有粒子分享信息，下一步将飞向<strong>自身最佳位置</strong>（个体极值）和<strong>全局最优位置</strong>（全局极值）的加权中心</li>
</ul>
</li>
<li><p>粒子群优化算法流程</p>
<ol>
<li>初始化一群粒子（群体规模），包括随机的位置和速度</li>
<li>评价每个粒子的适应度</li>
<li>对每个粒子更新个体最优位置P~id~</li>
<li>更新全局最优位置P~gbest~</li>
<li>根据速度和位置方差更行每个粒子的速度和位置（V~id~和P~id~)</li>
<li>如果未满足结束条件（通常为满足足够好的适应值或达到设定的最大迭代次数），返回2 </li>
</ol>
</li>
<li><p>粒子速度和位置的更新公式（*）</p>
<p>第k+1时刻第i个粒子的位置和速度更新为：</p>
<p>$$V^{k+1}<em>{id} = wv^k</em>{id}+c_1rand()(p<em>id+x^k</em>{id})+c<em>2rand()(p</em>{gbest}+x^k_{id})$$</p>
<p>$$x^{k+1}<em>{id}=x^k</em>{id}+v^{k+1}_{id}    i=1,2,…; d=1,2,…,D$$</p>
<p>惯性权重w</p>
<ul>
<li>使粒子保持运动惯性，使其有扩展搜索空间的趋势，有能力探索新的区域。</li>
<li>表示微粒对当前自身运动状态的信任，依据自身的速度进行惯性运动。</li>
<li>较大的w有利于跳出局部极值，而较小的w有利于算法收敛。</li>
</ul>
<p>加速常数$c_1$和$c_2$</p>
<ul>
<li><p>代表将粒子推向$P<em>{best}$和$G</em>{best}$位置的统计加速项的权重。</p>
</li>
<li><p>表示粒子的动作来源于自己经验的部分和其它粒子经验的部分。</p>
</li>
<li><p>较小的值允许粒子在被拉回之前可以在目标区域外徘徊，而较大的值则导致粒子突然冲向或越过目标区域。    </p>
</li>
<li><p>将c1和c2统一为一个控制参数，φ=c1+c2</p>
<p>如果φ很小，粒子群运动轨迹将非常缓慢；</p>
<p>如果φ很大，则粒子的位置变化非常快；</p>
<p>实验表明，当φ=4.1（通常c1=2.0，c2=2.0）时，具有很好的收敛效果。</p>
</li>
</ul>
<p>粒子数</p>
<ul>
<li>一般取20~40，对较难或特定类别的问题可以取100~200</li>
</ul>
<p>最大速度$V_max$</p>
<ul>
<li>决定粒子在一个循环中最大的移动距离，通常设定为粒子的范围宽度。</li>
</ul>
<p>终止条件</p>
<ul>
<li>最大循环数以及最小错误要求</li>
</ul>
</li>
<li><p>与遗传算法的比较</p>
<ol>
<li>共性：<ul>
<li>都属于仿生算法</li>
<li>都属于全局优化方法</li>
<li>都属于随机搜索算法</li>
<li>都隐含并行性</li>
<li>根据个体的适应信息进行搜索，因此不受函数约束条件的限制，如连续性、可导性等；</li>
<li>对高位复杂问题，往往会遇到早熟收敛和收敛性能差的缺点，都无法保证收敛到最优点</li>
</ul>
</li>
<li>差异：<ul>
<li>PSO有记忆，所有粒子都保存较优解的知识，而GA，以前的知识随着种群的改变被改变</li>
<li>PSO中的粒子是一种单向信息共享机制。而GA中的染色体之间相互共享信息，使得整个种群都向最优区域移动</li>
<li>GA需要编码和遗传操作，而PSO没有交叉和变异操作，粒子只是通过内部速度进行更行，因此原理更简单、参数更少、实现更容易。</li>
</ul>
</li>
<li>粒子群优化算法的应用<ul>
<li>巡航导弹的飞行高度进行优化</li>
<li>车辆路径问题的应用</li>
<li>邮政投递</li>
<li>火车及汽车的调度</li>
<li>港口装卸集装箱</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="人工鱼群算法"><a href="#人工鱼群算法" class="headerlink" title="人工鱼群算法"></a>人工鱼群算法</h4><p>模拟鱼群的觅食行为、集群行为、跟随行为、和随机游动行为。大多数时间，鱼会想有更多食物的方向游动，同事，它们会尽量聚集在一起来并保持和鱼群中心位置的鱼游动方向一致</p>
<h4 id="每种算法提出的思想依据与理论基础"><a href="#每种算法提出的思想依据与理论基础" class="headerlink" title="每种算法提出的思想依据与理论基础"></a>每种算法提出的思想依据与理论基础</h4><h4 id="蚁群算法和粒子群算法应用领域"><a href="#蚁群算法和粒子群算法应用领域" class="headerlink" title="蚁群算法和粒子群算法应用领域"></a>蚁群算法和粒子群算法应用领域</h4><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><ol>
<li>NPL的困难<ul>
<li>歧义（Ambiguity）<ul>
<li>注音歧义</li>
<li>分词歧义</li>
<li>无法在句子内部解决的歧义</li>
<li>短语歧义</li>
</ul>
</li>
<li>病构（ill-Formedness）</li>
<li>重述（Paraphrasing）</li>
</ul>
</li>
</ol>
<ol>
<li><p>NPL方法论</p>
<p>语言处理的科学内容</p>
</li>
<li><p>NPL的任务和瓶颈</p>
<ol>
<li><p>NLP的性质</p>
<p>NLP需要的知识非常复杂</p>
<ul>
<li>理解语言的过程是动态的，不是静态的</li>
<li>NLP需要的知识大多是归纳的，不是演绎的</li>
<li>人也不一定能够做出一致的理解结果，存在Upper Bound</li>
<li>NLP是一个非确定性过程</li>
<li>领域词典不充分</li>
</ul>
</li>
</ol>
</li>
<li><p>统计语言模型及解决问题的思想</p>
<p>|    模型    |    算法     |<br>| :——: | :——-: |<br>|  状态机模型   |   动态编程    |<br>| 形式规则系统模型 |   及其学习    |<br>|   统计模型   | 分类/序列模型算法 |<br>|  向量空间模型  |  最大期望算法   |</p>
<p>​</p>
</li>
</ol>
<h3 id="人工智能历史"><a href="#人工智能历史" class="headerlink" title="人工智能历史"></a>人工智能历史</h3><h4 id="人工智能方法与传统程序的不同"><a href="#人工智能方法与传统程序的不同" class="headerlink" title="人工智能方法与传统程序的不同"></a>人工智能方法与传统程序的不同</h4><p>传统方法解决问题。利用已有知识，问题可以结构化-数据结构，数学表达式-数学公式、算法。</p>
<p>利用知识，特别是依赖人类经验的启发知识是人工智能方法与传统数学方法的根本不同之处。基于此，人工智能可以解决众多的难以数学表达的非结构化的实际问题</p>
<p>人工智能首先研究的是以符号表示的知识而不是数值为研究对象。其次采用的是启发式推理的方法而不是常规的算法。控制结构和领域知识是分离的，同时还允许出现相对正确的答案。</p>
<h4 id="人工智能的本质"><a href="#人工智能的本质" class="headerlink" title="人工智能的本质"></a>人工智能的本质</h4><h4 id="研究人工智能的途径"><a href="#研究人工智能的途径" class="headerlink" title="研究人工智能的途径"></a>研究人工智能的途径</h4><h4 id="人工智能的重要影响人物"><a href="#人工智能的重要影响人物" class="headerlink" title="人工智能的重要影响人物"></a>人工智能的重要影响人物</h4><ul>
<li>阿伦-图灵：计算机科学理论创始人</li>
<li>马文-明斯基：人工智能之父，框架理论创立者，首位获得图灵奖的人工智能学者</li>
<li>约翰-麦卡锡：人工智能之父，LISP语言发明人，首次提出AI概念</li>
<li>赫伯特-西蒙：符号主义学派创始人，中国科学院外籍院士</li>
<li>艾伦-纽厄尔：符号主义学派创始人一致，西蒙的学生</li>
</ul>
<h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h3><ol>
<li>归结原理<ul>
<li>P4 49页   求归结步骤和归结树</li>
<li>P4 27页   化为Skolem标准形</li>
</ul>
</li>
<li>主观贝叶斯方法<ul>
<li>P5 100页  根据R1,R2，LS,LN求B的更新值(A1,A2必然发生的情况)</li>
</ul>
</li>
<li>确定性方法<ul>
<li>P5  124页  CF(B1),CF(B2)的计算</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/计算机图形学专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/19/计算机图形学专题复习/" itemprop="url">
                  计算机图形学复习要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T21:10:20+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/19/计算机图形学专题复习/" class="leancloud_visitors" data-flag-title="计算机图形学复习要点">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机图形学复习要点"><a href="#计算机图形学复习要点" class="headerlink" title="计算机图形学复习要点"></a>计算机图形学复习要点</h1><h2 id="第一章-计算机图形学概述"><a href="#第一章-计算机图形学概述" class="headerlink" title="第一章 计算机图形学概述"></a>第一章 计算机图形学概述</h2><h4 id="计算机图形的概念与研究的内容"><a href="#计算机图形的概念与研究的内容" class="headerlink" title="计算机图形的概念与研究的内容"></a>计算机图形的概念与研究的内容</h4><ol>
<li><p>图形的概念</p>
<ul>
<li><p>广义的图形概念 </p>
<p>凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：</p>
<ul>
<li>自然景物</li>
<li>照片和图片</li>
<li>工程图、设计图和方框图</li>
<li>人工美术绘画、雕塑品</li>
<li>用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形</li>
</ul>
</li>
<li><p>计算机图形学中的图形概念</p>
<p>是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色彩等非几何要素构成的，从现实世界中抽象出来的带有灰度、色彩及形状的图或形。</p>
</li>
</ul>
</li>
<li><p>计算机图形学的研究内容</p>
<p>用计算机生成景物的数字模型，并将它显示在计算机屏幕上，或者绘制在纸张或胶片上。它是研究如何在计算机环境下生成、处理和显示图形的一门学科。</p>
<p>主要研究对象：</p>
<ul>
<li>景物的几何建模方法(modeling)对模型的处理方法</li>
<li>几何模型的绘制技术(rendering)</li>
<li>图形输入和控制的人机交互界面(userinterface)。</li>
</ul>
</li>
</ol>
<h4 id="图形学发展史"><a href="#图形学发展史" class="headerlink" title="图形学发展史"></a>图形学发展史</h4><h4 id="计算机图形的应用"><a href="#计算机图形的应用" class="headerlink" title="计算机图形的应用"></a>计算机图形的应用</h4><ol>
<li>计算机辅助设计与制造</li>
<li>地理信息系统</li>
<li>科学计算可视化</li>
<li>计算机动画和艺术</li>
<li>计算机模拟和仿真</li>
<li>虚拟现实</li>
</ol>
<h2 id="第二章-计算机绘图初步认识"><a href="#第二章-计算机绘图初步认识" class="headerlink" title="第二章 计算机绘图初步认识"></a>第二章 计算机绘图初步认识</h2><h4 id="如何在计算机上绘图"><a href="#如何在计算机上绘图" class="headerlink" title="如何在计算机上绘图"></a>如何在计算机上绘图</h4><ol>
<li>计算机绘图的一般方法</li>
</ol>
<ol>
<li>一般图形的显示流程</li>
</ol>
<p>OpenGL图形软件包简介</p>
<h2 id="第三章-计算机图形系统及硬件"><a href="#第三章-计算机图形系统及硬件" class="headerlink" title="第三章 计算机图形系统及硬件"></a>第三章 计算机图形系统及硬件</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>计算机系统中的图形设备</li>
<li>图形的输入输出处理流程</li>
<li>图形工作站与PC机</li>
</ol>
<h4 id="图形显示原理"><a href="#图形显示原理" class="headerlink" title="图形显示原理"></a>图形显示原理</h4><ol>
<li>CRT显示器<ul>
<li>CRT显示原理</li>
<li>彩色CRT的显示原理</li>
<li>光栅扫描式的图形显示器</li>
<li>随机扫描的图形显示器</li>
</ul>
</li>
<li>液晶显示器</li>
<li>等离子显示器</li>
<li>显卡</li>
</ol>
<h2 id="第四章-基本光栅图形算法"><a href="#第四章-基本光栅图形算法" class="headerlink" title="第四章 基本光栅图形算法"></a>第四章 基本光栅图形算法</h2><h4 id="直线生成算法"><a href="#直线生成算法" class="headerlink" title="直线生成算法"></a>直线生成算法</h4><ol>
<li><p>DDA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dda</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> k,i;</div><div class="line">  <span class="comment">//k 即起点和中的横纵坐标距离较大者的距离</span></div><div class="line">  <span class="comment">//即 将距离大者分为k段</span></div><div class="line">  <span class="keyword">float</span> x,y,dx,dy;</div><div class="line">  k=<span class="built_in">abs</span>(x2-x1);</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">abs</span>(y2-y1)&gt;k) k=<span class="built_in">abs</span>(y2-y1);</div><div class="line">  dx=<span class="keyword">float</span>(x2-x1)/k;  <span class="comment">//增量，每次横坐标增量</span></div><div class="line">  dy=<span class="keyword">float</span>(y2-y1)/k;  <span class="comment">//每次纵坐标增量 </span></div><div class="line">  <span class="comment">//有一个的增量&lt;1，另一个增量=1</span></div><div class="line">  x=<span class="keyword">float</span>(x1);</div><div class="line">  y=<span class="keyword">float</span>(y1);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">    gl_Point(<span class="keyword">int</span>(x+<span class="number">0.5</span>),<span class="keyword">int</span>(y+<span class="number">0.5</span>));	<span class="comment">//取整</span></div><div class="line">    x=x+dx;</div><div class="line">    y=y+dy;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该算法计算量大，产生一个象素需要两次加法，两次取整。还需要除法，增加硬件难度。</p>
</li>
<li><p>正负法</p>
</li>
<li><p>Bresenham算法</p>
</li>
</ol>
<h4 id="圆弧生成算法"><a href="#圆弧生成算法" class="headerlink" title="圆弧生成算法"></a>圆弧生成算法</h4><ol>
<li>正负法</li>
<li>Bresenham算法</li>
<li>圆弧的离散生成</li>
</ol>
<h4 id="多边形填充（P51）"><a href="#多边形填充（P51）" class="headerlink" title="多边形填充（P51）"></a>多边形填充（P51）</h4><ol>
<li><p>多边形表示方法</p>
<ul>
<li>顶点表示</li>
<li>点阵表示</li>
</ul>
<p>多边形填充就是把多边形的顶点表示转换为点阵表示。</p>
</li>
<li><p>多边形填充的扫描线算法</p>
<p>扫描线算法是效率较高的多边形填充算法，充分利用了相邻象素之间的连续性，避免反复求交。</p>
<ul>
<li><p>区域的连续性</p>
</li>
<li><p>扫描线的连续性</p>
<p>交点个数是偶数，扫描线上的一些点位于多边形P内，其余区间都在P外。</p>
</li>
<li><p>边的连续性</p>
</li>
<li><p>奇点处理</p>
</li>
<li><p>扫描线算法的数据结构域实现步骤</p>
<ul>
<li><p>边 y. 筒ET</p>
<p>按边下端点的纵坐标$y$对非水平边进行分类的指针数组。下端点的纵坐标$y$等于$i$的边归入第$i$类。同一类中按$x$值进行排序。</p>
<p>生成方式：从低端向上扫描</p>
</li>
<li><p>边的活化链表AEL</p>
<p>由与当前扫描线相交的所有多边形组成，记录多边形边沿扫描线的交点序列</p>
</li>
<li><p>四个域组成</p>
<p>| $y_{max}$ | $x$                          | $\Delta x$ | $next$    |<br>| ——— | —————————- | ———- | ——— |<br>| 边的上端点y坐标  | 边y筒中表示下端点x坐标；AEL中边与扫描线的交点x坐标 | 边斜率的倒数     | 指向下一条边的指针 |</p>
</li>
<li><p>算法步骤</p>
<ul>
<li>（AEL初始化）将边的活化链表AEL置空</li>
<li>（y初始化）取扫描线纵坐标y的初始值为ET中非空元素的最小序号</li>
<li>按从下到上的顺序对纵坐标值为y的扫描线（当前扫描线）执行下列步骤直到边的活化链表为空<ul>
<li>如边ET中的第y类元素非空，则从ET中将第y类的所有边取出，按照x值（x值相等时，按$\Delta x$值）递增方向插入到活化链表AEL中</li>
<li>若AEL非空，将AEL中的边亮亮依次配对，填充所有线段对$（x_1,y）$和$（x_2,y）$，$（x_3,y）$和$（x_4,y）$，……</li>
<li>将AEL中满足y=y_max的边删去</li>
<li>将AEL剩下的每条边的X域累加$\Delta x$ ，即 $x = x + \Delta x$</li>
<li>将当前扫描线的纵坐标值y累加1，即$y=y+1$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>边缘填充算法</p>
<p>多边形填充的扫描线算法中，建立ET筒和AEL活化链表时需要对多边形的边进行排序，该算法采用对图像进行逐位求反的方法可以免去对边排序的工作量。</p>
<ul>
<li>算法实现：对多边形P的每一非水平边$P_iP_i+1$上的各象素做向右求反运算即可。</li>
</ul>
</li>
</ol>
<ul>
<li>优势：数据结构和程序简单，对单值图像比较有用</li>
<li>劣势：需要对帧缓冲器中的大批元素反复赋值，速度不比扫描线快。</li>
</ul>
<ol>
<li><p>边界标志</p>
<p>首先用特殊颜色在帧缓冲器中将多边形边界（水平边的部分边界除外）勾画出来，然后再把位于多边形内的各个象素着色。</p>
<p>避免了对帧缓冲器中的大量元素的多次赋值，但需要逐条扫描线对帧缓冲器中的元素进行搜索和比较。</p>
</li>
</ol>
<h4 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h4><ol>
<li><p>区域概念</p>
<ul>
<li>内点表示</li>
<li>边界表示法</li>
<li>区域的连通性<ul>
<li>四连通区域</li>
<li>八连通区域</li>
</ul>
</li>
</ul>
</li>
<li><p>简单的种子填充算法</p>
<p>给定区域G一种子点（x,y），首先判断该点是否是区域内的一点，是则将该点填充为新的颜色，然后将该点周围的四个点（四连通）或八个点（八连通）作为新的种子点进行相同处理，通过这种扩散完成对整个区域填充。</p>
</li>
<li><p>扫描线种子填充算法</p>
<p>区域填充的递归算法程序简单、表达清楚。但是由于多层递归，需要反复进行费时、费内存的堆栈操作，一般用于细小的区域进行填充。</p>
<p>扫描线种子算法，从给定的种子点开始，填充当前扫描线上种子点所在的区间，然后确定与这一区间相邻的上下两条扫面线上需要填充的区间，从这些区间上各取一个种子点并以此把它们保存起来，作为下次填充的种子点，反复进行直到所保存的各区间都填充完毕</p>
<p>算法步骤：</p>
<ol>
<li>将算法设置的堆栈置为空，将给定种子点（x,y）压入堆栈</li>
<li>如果堆栈为空，算法结束；否则取栈顶元素（x,y）作为种子点</li>
<li>从种子点开始，沿纵坐标为y的当前扫描线向左右两个方向逐个用新的颜色值进行填充，直到边界为止。设区间的横纵坐标分别为$x<em>{left}$和$x</em>{right}$。</li>
<li>在与当前扫描线相邻的上下两条扫描线上，以区间$[x<em>{left},x</em>{right}]$为搜索范围，求出需要填充的各小区间，把各小区间中最右边的点作为种子点压入堆栈，移向2</li>
</ol>
</li>
</ol>
<h2 id="第五章-变换和裁剪"><a href="#第五章-变换和裁剪" class="headerlink" title="第五章 变换和裁剪"></a>第五章 变换和裁剪</h2><h4 id="变换的数学基础"><a href="#变换的数学基础" class="headerlink" title="变换的数学基础"></a>变换的数学基础</h4><h4 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h4><p>每一图形的模型都有自己的坐标系，此坐标系为模型坐标系或局部坐标系。图形场景由多个图形组成，它们被放置在一个统一的坐标系中，称为世界坐标系</p>
<ol>
<li>基本变换<ul>
<li>平移变换</li>
<li>缩放变换<ul>
<li>原点为相似中心</li>
<li>定义其他点为相似中心</li>
<li>为使缩放后的图形仍在原来位置附近，定义相似中心</li>
</ul>
</li>
<li>旋转变换<ul>
<li>x、y、z点左边经旋转后的坐标。（y有差别）</li>
<li>绕过原点的任意轴旋转（不懂）</li>
<li>void glRotate(Type angle, x , y , z) ，以angle为旋转角度，以从原点到指定（x,y,z）向量为旋转中心轴，逆时针旋转。</li>
</ul>
</li>
<li>错切变换</li>
</ul>
</li>
<li>齐次坐标与变换的矩阵表示<ul>
<li>为了将平移变换合并，使用齐次坐标系</li>
<li>用n+1维向量表示n维向量</li>
</ul>
</li>
<li>变换模式<ul>
<li>图形软件包提供两种图形变换模式—— 图形模式和空间模式，从而可以方便地控制变换的次序</li>
<li>图形模式<ul>
<li>每一次变换均可看成相对于原始坐标系中执行的，先调用的变换矩阵放在右边，后调用的矩阵放在左边。 固定坐标系模式</li>
<li>个人理解：都是相对于初始坐标系进行变换</li>
</ul>
</li>
<li>空间模式<ul>
<li>又称活动坐标系模式。连续执行几个变换时，变换矩阵的合并方式和图形模式相反，即后调用的变换矩阵要乘在右边</li>
<li>空间模式的特点是在连续执行几次变换时，每一次变换均可看成是上一次变换所形成的新坐标系中进行的。</li>
<li>对变换后的坐标系进行变换</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ol>
<li>Sutherland-Cohen算法<ul>
<li>判断直线是否完全在窗口内或窗口外</li>
<li>计算出直线段和窗口边界直线的一个交掉，此交点把原线段分成两段，去掉显然在窗口外的一段，对另一段进行重新判断。</li>
<li>用窗口的四条边巴整个平面分成九个区域，对于窗口某一边界外侧的三个区域的四位编码中有一位全是1。</li>
<li>如果两段编码都是0000，则完全在窗口内；如果逻辑与不为0000，即某一位为1，表明两端点位于窗口同一条边界外侧，显然在窗口外·</li>
</ul>
</li>
<li>Cyrus-Beck算法和梁友东-Barsky算法</li>
<li>多边形剪裁</li>
<li>字符剪裁</li>
</ol>
<h4 id="OpenGL中简单变换实例"><a href="#OpenGL中简单变换实例" class="headerlink" title="OpenGL中简单变换实例"></a>OpenGL中简单变换实例</h4><h2 id="第六章-三维空间的观察"><a href="#第六章-三维空间的观察" class="headerlink" title="第六章 三维空间的观察"></a>第六章 三维空间的观察</h2><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>把n维坐标系中的电变换成小于n维坐标系中的点。只讨论三维到二维的投影。</p>
<p>在三维空间中选择一个点作为视点，定义一个不经过视点的平面（投影平面），从视点向投影平面引出任意条射线（投影线）。穿过物体的投影线将与投影平面相交，在投影平面上形成物体的像，此像即为三维物体在二维投影平面上的投影。</p>
<p>投影变换分为透视投影和平行投影，区别是透视投影的投影中心和投影面之间的距离有限，而平行投影的投影中心和投影平面之间的距离是无限的</p>
<ol>
<li>透视投影<ul>
<li>透视投影的计算公式</li>
</ul>
</li>
<li>平行投影<ul>
<li>正投影</li>
<li>斜投影</li>
<li>平行投影的计算公式</li>
</ul>
</li>
<li>任意坐标系到观察坐标系中的变换<ul>
<li>灭点：一组不平行与投影平面的平行线，经过透视投影后相交于一点。灭点可以看作是三维空间的无穷远点在投影平面上的投影点。如果这组平行线平行与坐标轴，这时的灭点称为<strong>主灭点</strong>。</li>
</ul>
</li>
<li>射影变换</li>
</ol>
<h4 id="视见体到规范视见体的变换"><a href="#视见体到规范视见体的变换" class="headerlink" title="视见体到规范视见体的变换"></a>视见体到规范视见体的变换</h4><ol>
<li>平行投影视见体的规范化</li>
<li>透视投影视见体的规范化</li>
</ol>
<h4 id="用三维规范体裁剪"><a href="#用三维规范体裁剪" class="headerlink" title="用三维规范体裁剪"></a>用三维规范体裁剪</h4><h4 id="窗口到视口的变换"><a href="#窗口到视口的变换" class="headerlink" title="窗口到视口的变换"></a>窗口到视口的变换</h4><h2 id="第七章-人机交互绘图技术"><a href="#第七章-人机交互绘图技术" class="headerlink" title="第七章 人机交互绘图技术"></a>第七章 人机交互绘图技术</h2><p>人机交互：用户与计算机系统之间的通信，它是人与计算机之间各种符号和动作的双向信息交换</p>
<h4 id="基本的图形输入设备和基本交互任务"><a href="#基本的图形输入设备和基本交互任务" class="headerlink" title="基本的图形输入设备和基本交互任务"></a>基本的图形输入设备和基本交互任务</h4><ol>
<li>基本的图形输入设备<ul>
<li>定位设备</li>
<li>笔画设备</li>
<li>定值设备</li>
<li>选择设备</li>
<li>拾取设备</li>
<li>字符串设备</li>
</ul>
</li>
<li>基本交互任务<ul>
<li>定位</li>
<li>笔画</li>
<li>定值</li>
<li>选择</li>
<li>拾取</li>
<li>字符串</li>
</ul>
</li>
</ol>
<h4 id="人机交互输入模式"><a href="#人机交互输入模式" class="headerlink" title="人机交互输入模式"></a>人机交互输入模式</h4><ol>
<li>请求模式</li>
<li>样本模式</li>
<li>事件模式</li>
</ol>
<h4 id="常见辅助交互技术"><a href="#常见辅助交互技术" class="headerlink" title="常见辅助交互技术"></a>常见辅助交互技术</h4><ol>
<li>几何约束</li>
<li>拖拽</li>
<li>在三维视图上做三维输入</li>
</ol>
<h2 id="第八章-隐藏先和隐藏面的消除"><a href="#第八章-隐藏先和隐藏面的消除" class="headerlink" title="第八章 隐藏先和隐藏面的消除"></a>第八章 隐藏先和隐藏面的消除</h2><p>计算机生成三维图形，首先确定三维场景中的物体哪些部分是可见的，生成三维图形时只绘制可见的部分。</p>
<p>三维场景中物体的可见性对透视投影是相对于投影中心，平行投影是相对于投影方向。</p>
<p>场景可见部分的判断过程称为可见线判断或可见面判定，也称为隐藏线消除或隐藏面消除。</p>
<p>两种基本算法：</p>
<ol>
<li>以构成图像的每一个象素为处理单元，对场景中所有表面，确定对于观察点是可见的表面，用该表面颜色填充该象素。<strong>多用于面消隐</strong></li>
<li>以三维场景中的物体对象为处理单元，在所有对象之间进行比较，除去完全不可见的物体和物体上不可见的部分。<strong>多用于线消隐，也可用于面消隐</strong></li>
</ol>
<h4 id="可见面判断的有效技术"><a href="#可见面判断的有效技术" class="headerlink" title="可见面判断的有效技术"></a>可见面判断的有效技术</h4><p>可见面或可见线的判定是一个计算量很大的工作，如何减少可见面的判定非常重要。</p>
<ol>
<li><p>边界盒</p>
<p>在裁剪和消隐处理中，采用边界盒可避免不必要的裁剪运算，避免在物体或它们的投影之间进行不必要的计算。所谓物体的边界盒是指一个能够包含该物体的一个几何形状，该形状有较简单的边界</p>
</li>
<li><p>后向面消除</p>
<p>把显然不可见的面去掉，从而减少消隐过程中的直线求交数目</p>
</li>
<li><p>非垂直投影转换成垂直投影</p>
</li>
</ol>
<h4 id="多面体隐藏线消除算法"><a href="#多面体隐藏线消除算法" class="headerlink" title="多面体隐藏线消除算法"></a>多面体隐藏线消除算法</h4><ol>
<li>算法基本思想<ul>
<li>使用后向面消除技术把多面体后向面去掉</li>
<li>使用边界盒技术排除不相交的线段的求交运算</li>
</ul>
</li>
<li>确定边L和多边形E关系的技术</li>
</ol>
<h4 id="基于多边形的子分算法"><a href="#基于多边形的子分算法" class="headerlink" title="基于多边形的子分算法"></a>基于多边形的子分算法</h4><p>用多边形的边界对区域进行划分，目的是尽量减少对区域划分的次数</p>
<h4 id="Z缓冲器算法和扫描线算法"><a href="#Z缓冲器算法和扫描线算法" class="headerlink" title="Z缓冲器算法和扫描线算法"></a>Z缓冲器算法和扫描线算法</h4><ol>
<li><p>Z缓冲器算法</p>
<p>z缓冲器算法是最简单的隐藏面消除算法之一。对屏幕上每一个像素点，找到此像素投影线与所有多边形交点中离观察者最近的点，此点的属性（颜色或灰度）值即为这一屏幕像素点的属性值。</p>
<p>实现此算法需要两个缓冲器数组，即z缓冲器数组和帧缓冲器数组，Zdepth[][]与Frame[][]，算法如下</p>
<ol>
<li>对屏幕上的每个点$(x,y)$，令Zdepth[x][y]为z的极小值，Frame[x][y]为背景颜色</li>
<li>对所有多边形做如下工作：对多边形每一点(x,y)，计算其z值。若z&gt;Zdepth[x][y]，则Zdepth[x][y]=z，并将此属性值赋给Frame[x][y]，否则说明此点离观察者较远，两个数组的值都可以不用改变</li>
</ol>
<p>优点：简单、可靠，不需要对显示物体的面预先进行排序，有利于硬件实现</p>
<p>缺点：需要额外的z缓冲器，将全屏幕的像素保存</p>
</li>
<li><p>扫描线z缓冲器算法</p>
<p>为了克服缺点，将整个屏幕平面划分为若干个区域。如果把整个区域取成屏幕上的一行，就得到了扫面线z缓冲器算法。z缓冲器的单元数和一条扫描线上的像素数目相同。从最上面的扫描线开始，向下对每一条扫面线进行处理。</p>
<p>处理工作</p>
<ol>
<li>把相应的帧缓冲器单元设置成底色，在z缓冲器中存放z的极小值。</li>
<li>对每个多边形检查它在oxy平面上的投影和当前的扫描线是否相交<ul>
<li>若不相交，则不考虑该多边形</li>
<li>若相交，则扫描线和多边形边界的交点是成对出现的。</li>
</ul>
</li>
<li>对每对交点中间的像素计算多边形所在平面对应点的深度（z值），并和z缓冲器中相对应单元存放间的深度值做比较。<ul>
<li>若前者大于后者，则z缓冲器的相应单元内容要被求得的平面深度代替，帧缓冲器相应单元的内容也要换成该平面的属性。</li>
</ul>
</li>
<li>对所有的多边形都做上述处理后，帧缓冲器中这一行的值边反映了消隐后的图形。对帧缓冲器每一行都处理完后，就得到了整个消隐后的图形</li>
</ol>
<p>实现方式</p>
<p>采用数据结构：一个多边形Y筒，一个边Y筒，一个多边形活化表盒一个边活化表。</p>
<ul>
<li>多边形Y筒和边Y筒各是一个记录，记录的个数和扫描线的行数相同。</li>
<li>根据多边形顶点y坐标最大值来决定放入<strong><em>多边形y筒</em></strong>的行数</li>
<li>根据边两端点的较大y坐标值来决定放入<strong>边y筒</strong>的相应行数</li>
<li>多边形Y筒：<ul>
<li>多边形所在平面方程： $ax+by+cz+d=0$的系数     <strong>a,b,c和d</strong></li>
<li>和该多边形在$oxy$平面上的投影相交的扫描线的条数      $\Delta y =8$</li>
<li>多边形的属性   <strong>color</strong></li>
<li>编号 <strong>IP</strong></li>
</ul>
</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%A4%9A%E8%BE%B9%E5%BD%A2y%E7%AD%92.png" alt="多边形Y筒"></li>
<li>边Y筒<ul>
<li>边上端点x坐标的值</li>
<li>在$oxy$平面上的投影和相邻两条扫面线的交点的x坐标的差$\Delta x$</li>
<li>边在oxy平面上的投影所覆盖的扫面线条数 $\Delta y$</li>
<li>边所属多边形的编号  <strong>IP</strong></li>
</ul>
</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E8%BE%B9y%E7%AD%92.png" alt="边y筒"></li>
<li>多边形活化表，记录在$oxy$平面投影和当前考虑的扫描线相交的多边形</li>
<li>边活化表，存放多边形的边和当前扫描线相交的边对。边对保存如下信息：<ul>
<li>$x_l$      左边的x坐标值</li>
<li>$\Delta x_l$   左边和两相邻扫描线交点的x坐标差</li>
<li>$\Delta y_l$   以左边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1</li>
<li>$x_r$      右边交点的x坐标值</li>
<li>$\Delta x_r$  右边和两相邻扫描线交点的x坐标差  </li>
<li>$\Delta y_r$   以右边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1</li>
<li>$z_l $       多边形平面在左交点处的深度值</li>
<li>$\Delta z_x$  沿扫描线向右走过一个像素时，多边形所在平面深度的增量</li>
<li>$ \Delta z_y $  沿y方向向下移过一根扫描线时，多边形所在平面深度的增量</li>
<li>IP      边所在多边形编号</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="优先级排序表算法"><a href="#优先级排序表算法" class="headerlink" title="优先级排序表算法"></a>优先级排序表算法</h4><p>按多边形离观察者的远近来建立一个多边形排序表，距离观察着远的优先级低，近的优先级高。多边形排序表建立后，从优先级低的多边形开始，依次把多边形的颜色填入帧缓冲存储器重，表中距观察者近的元素覆盖帧缓冲存储器中原有内容，当优先级最高的多边形送入缓冲器后，整幅图形就形成了。</p>
<p>算法：</p>
<ol>
<li>根据每个多边形顶点z坐标的极小值 $z_{min}$的大小，按由小到大对它们做初步排序，并把它们组成一个链表</li>
<li>若链表中只有一个多边形，则结束算法，否则取表头多边形为P</li>
<li>设Q为链表中P之外的任一多边形。若对所有Q都有$Qz<em>{min}&gt;Pz</em>{min}$，则P不会遮挡其他多边形，为优先级最低的多边形，去除P，转2；否则，若所有Q都满足下面四项条件中的一项，则在链表中去除P，转2。若不满足此四项条件中任何一个的Q，交换P和Q转3。<ol>
<li>P 和Q在oxy平面上投影的边界盒在x或y方向上不相交</li>
<li>P的各顶点均在Q的远离视点一侧</li>
<li>Q的各顶点均在P的靠近视点一侧</li>
<li>P和Q在oxy平面是的投影不相交</li>
</ol>
</li>
</ol>
<h4 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h4><p>光学投射建立在几何光学的基础上，沿光线的路径追踪可见面，是一种有效的可见性判别技术。</p>
<p>具体做法：由视点出发穿过观察平面上一像素想场景发射一条射线，求出射线与场景中各物体表面的交点，离视点最近的交点的颜色即为像素要填的颜色。光线投射算法对于包含曲面，特别式包含球面的场景有很高的效率。</p>
<h2 id="第九章-简单光照明模型"><a href="#第九章-简单光照明模型" class="headerlink" title="第九章 简单光照明模型"></a>第九章 简单光照明模型</h2><h4 id="简单光照明模型"><a href="#简单光照明模型" class="headerlink" title="简单光照明模型"></a>简单光照明模型</h4><p>光照模型是生成真实感图形的基础。用计算机在图形设备上生成连续色调的真实感图形必须完成四个基本的任务。第一，用数学方法建立所构造三维场景的几何描述，并将其输入计算机。第二，将三维几何转换为二维透视图。通过对场景的透视变换来完成。第三，确定场景中所有可见面。第四，计算场景中可见面的颜色。</p>
<ol>
<li><p>光源</p>
<p>将光源称为发光体，反射表明称为反射光源</p>
<p>光源可分为四类：点光源、线光源、面光源和体光源</p>
</li>
<li><p>材质</p>
<p>材质本身有自己的颜色。材质的颜色是由它所反射的广的波长决定的</p>
</li>
<li><p>简单光照明模型</p>
<p>简单光照明模型只考虑被照明物体的几何形状对反射和透射光的影响，在简单光照模型中，环境假设为由白色照明，且反射光和透射光由用户选定</p>
<ol>
<li><p>环境反射光</p>
<p>环境反射光是由环境光在邻近物体上经过多次反射所产生的。</p>
<p>亮度表示为： $I_a=k<em>aI</em>{pa}$，其中 $I<em>a$是物体的环境反射亮度，$I</em>{pa}$为环境光亮度，$k_a$为物体表面光反射系数</p>
</li>
<li><p>漫反射光</p>
<p>一个比较粗糙的，无光照的物体表面对光的反射表现为漫反射。</p>
<p>郎伯定律指出：对于一个漫反射体，表面的反射光亮度和光源入射角的余弦成正比：$I_d =k<em>dI</em>{pd}\cos i$，其中$I<em>d$为物体表面漫反射光的光亮度，$I</em>{pd}$为光源垂直入射时反射光的光亮度，$i$为光源入射角，$k_d$为漫反射系数</p>
<p>当观察漫反射物体时，人眼接受到光亮度和观察者的位置无关</p>
<p>对漫反射物体，它的表面除受特定光源照射之外，还受到从环境来的反射光的照射</p>
</li>
<li><p>镜面反射光</p>
<p>镜面反射光为朝一定方向的反射光。根据光的反射定律，反射光和入射光对称地分布于表面法向的两侧。</p>
</li>
<li><p>综和</p>
<p>物体表面上任意一点射向视点的光亮度I应该为环境光、漫反射光和镜面反射光的总和。$k_a, k_d , k_s$分别表示环境反射，漫反射和镜面反射分量的比例系数，简单光照明模型为：</p>
<p> $$I=k<em>aI</em>{pa}+k<em>dI</em>{pd}\cos i+k<em>sI</em>{ps}\cos ^n \theta$$</p>
<p>当光源有多个时，则上式可写为$$I=k<em>aI</em>{pa}+\sum( k<em>dI</em>{pd}\cos i+k<em>sI</em>{ps}\cos ^n \theta)  $$</p>
<p>其中$k_d+k_s=1$，该模型也称为Phong模型</p>
</li>
</ol>
</li>
</ol>
<h4 id="光滑明暗处理技术"><a href="#光滑明暗处理技术" class="headerlink" title="光滑明暗处理技术"></a>光滑明暗处理技术</h4><p>通常的多边形扫描线算法来绘制这种近似表示的物体，生成的图形将失去原有曲面的光滑性，呈现多面体形状。由于不同平面片之间不存在不连续的法向量，导致多个平面篇表示的物体表面光亮度呈现不连续跃变。</p>
<ol>
<li><p>Gouraud明暗处理技术</p>
<p>将曲面表面某一点的光亮度做近似表示，近似值为该曲面的各多边形顶点光亮度的双线性插值。</p>
<p>Gouraud明暗处理不能正确地模拟高光，因为采用光亮度插值后将使多边形内的高光丢失</p>
<p>所绘制画面会诱发马赫带效应，光亮度双线性插值保证了由多边形近似表示的曲面上各处光亮度的连续变化，但在相邻多边形的公共边界上光亮度的一阶导数并不连续，由于人眼光学错觉，光亮度变化一阶不连续的边界处会呈现亮带或黑带</p>
</li>
<li><p>Phong明暗处理技术</p>
</li>
</ol>
<h2 id="第十章-Bezier曲线曲面"><a href="#第十章-Bezier曲线曲面" class="headerlink" title="第十章 Bezier曲线曲面"></a>第十章 Bezier曲线曲面</h2><p>在计算机图形学中，常用的曲线曲面的类型有Bezier曲线曲面、B样条曲线曲面、孔斯曲面，这些曲线曲面采用分段和分片参数多项式的形式。曲线曲面的形状不依赖于坐标系的选择，<strong>人机交互直观，易于计算，易于拼接，造型灵活等</strong></p>
<h4 id="曲线曲面的基础知识"><a href="#曲线曲面的基础知识" class="headerlink" title="曲线曲面的基础知识"></a>曲线曲面的基础知识</h4><ol>
<li><p>曲线的表示</p>
<ol>
<li><p>显示表示</p>
<p>对于一条曲线，一个坐标变量显示地表示为另一个变量的函数。在平面曲线的显示表示中，每一个x只对应一个y值，所以显示方程不能表示封闭或多值曲线，例如圆。</p>
</li>
<li><p>隐式表示</p>
<p>平面曲线隐式表示的一半形式为$f(x,y)=0$。</p>
<p>存在问题：1. 与坐标系相关 2.会出现斜率为无穷大的情况 3.非平面曲线难用常系数的非参数化函数表示 4.不利于计算和编程</p>
</li>
<li><p>参数表示</p>
<p>将曲线上各点的坐标显示地表示成参数的函数形式，若去参数为t，曲线的参数表示为</p>
<p>$$P(t) = (x(t),y(t),z(t)) , t \in [0,1]$$</p>
<p>其中，$x(t),y(t)$和$z(t)$分别为t的显示函数，即每一个t对应空间一个点$(x(t),y(t),z(t))$</p>
<p>在曲线曲面的表示上，参数表示比非参数表示具有更大的优越：</p>
<ul>
<li>参数方程形式不依赖于坐标系的选取，具有形状不变性</li>
<li>在参数表示中，变化率以切实量来表示，不会出现无穷大的情况</li>
<li>对参数表示的曲线、曲面进行平移、书房和旋转等几何变换比较容易</li>
<li>用参数表示的曲线曲面的交能力强，参数表示式中系数的几何意义明确，并提高了自由度，以便控制形状</li>
</ul>
</li>
</ol>
</li>
<li><p>参数曲线的切矢量、弧长、法矢量和曲率</p>
<ol>
<li><p>位置矢量</p>
<p>曲线上任一点的位置矢量可表示为  $P(t) = (x(t),y(t),z(t)) , t \in [0,1]$</p>
</li>
<li><p>切矢量</p>
</li>
<li><p>弧长</p>
</li>
<li><p>曲率</p>
</li>
<li><p>主法矢量和副法矢量</p>
</li>
</ol>
</li>
</ol>
<h4 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h4><p>Bezier曲线是一段n次多项式曲线，是构造自由曲线曲面的重要和基本方法之一。它有许多优点，如果保凸性，凸包性，曲线形状不依赖于坐标系选择，人机交互灵活</p>
<ol>
<li><p>曲线的定义</p>
<p>在空间给定n+1个点$P_0,P_1,…,P_n$，称下列参数多项式曲线为n次Bezier曲线</p>
<p>$$P(t)=\sum ^n_{i=0} P<em>iJ</em>{i,n}$$</p>
<p>其中 J_{i,n}是Bernstein基函数</p>
<p>$$J_{i,n}(t)=\frac{n!}{i!(n-1)!}t^i(1-t)^{n-1}$$</p>
<p>折现$P_0,P_1,…,P_n$称为P(t)的控制多边形，$P_0,P_1,…,P_n$个各点成为P(t)的控制顶点。控制多边形是对Bezier曲线P(t)的大致勾画，P(t)是对控制多边形的逼近。</p>
</li>
<li><p>曲线的性质</p>
<ol>
<li>非负性    $ J_{i,n}(t) \ge 0$</li>
<li>权性    $\sum ^n<em>{i=0} J</em>{i,n}(t) \equiv 1$</li>
<li>对称性   $J<em>{i,n}(t) = J</em>{n-i,n}(1-t) ,i=0,1,…,n$</li>
<li>导函数   </li>
<li>最大值</li>
<li>地推公式</li>
<li>升阶</li>
</ol>
<p>例子</p>
</li>
<li><p>Bezier曲线的性质</p>
<ol>
<li><p>端点的位置</p>
<p>Bezier曲线的起点为$P_0$，终点为$P_n$，即 $P(0) = P_0 , P(1)=P_n$</p>
</li>
<li><p>端点的切线</p>
<p>Bezier曲线$P(t)$在起点$P_0$处与边 $\overline {P_0P_1}$相切，在终点P<em>n点处与边$\overline {P</em>{n-1}P_n}$相切，即 $P’(0) = n(P_1-P_0)，P’(1)=n(P<em>n-P</em>{n-1})$</p>
</li>
<li><p>端点的曲率</p>
</li>
<li><p>仿射不变形</p>
</li>
<li><p>凸包性</p>
</li>
<li><p>交互能力</p>
</li>
<li><p>变差缩减性</p>
</li>
<li><p>保凸性</p>
</li>
</ol>
</li>
<li><p>Bezier曲线性质进一步讨论</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/信息检索专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/05/信息检索专题复习/" itemprop="url">
                  信息检索专题复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T19:27:51+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/05/信息检索专题复习/" class="leancloud_visitors" data-flag-title="信息检索专题复习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h1><p>Made by ® Isaac. Ty </p>
<p>信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型</p>
<h4 id="IR新课题"><a href="#IR新课题" class="headerlink" title="IR新课题"></a>IR新课题</h4><ul>
<li>自然语言理解</li>
<li>多媒体检索</li>
<li>垂直检索技术</li>
<li>移动搜索</li>
<li>对社会媒体信息检索</li>
<li>问答</li>
<li>知识发现</li>
<li>行为分析、舆情控制</li>
<li>自动对话</li>
</ul>
<h2 id="2-布尔检索"><a href="#2-布尔检索" class="headerlink" title="2.布尔检索"></a>2.布尔检索</h2><h3 id="信息检索模型概述"><a href="#信息检索模型概述" class="headerlink" title="信息检索模型概述"></a>信息检索模型概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="文档表示"><a href="#文档表示" class="headerlink" title="文档表示"></a>文档表示</h5><p>一个文档被表示为<strong><u>关键词</u></strong>(bag of words)的集合</p>
<h5 id="查询表示"><a href="#查询表示" class="headerlink" title="查询表示"></a>查询表示</h5><p>查询式（Queries）被表示为<strong><u>关键词的布尔组合</u></strong>，用“与、或、非”连接起来（主析取范式）</p>
<h5 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h5><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是二值匹配</li>
</ul>
<h5 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h5><p>没有清晰和明显的语义结构的数据，计算机不易处理这些数据</p>
<h5 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h5><p>最典型的时关系数据库，用来保存公司的产品清单和人事记录</p>
<h5 id="聚类（clustering）"><a href="#聚类（clustering）" class="headerlink" title="聚类（clustering）"></a>聚类（clustering）</h5><p>基于文档内容进行自动聚团的任务。很像在书架上将一系列书按照它们所属的主题重新摆放的过程。</p>
<h5 id="分类（classification）"><a href="#分类（classification）" class="headerlink" title="分类（classification）"></a>分类（classification）</h5><p>根据<strong><u>给定的主题</u></strong>、固定的信息需求或者其他类别体系，将每一个文档分到一个或多个类别的任务。</p>
<h4 id="布尔模型：优缺点"><a href="#布尔模型：优缺点" class="headerlink" title="布尔模型：优缺点"></a>布尔模型：优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>查询<strong>简单</strong>，容易理解</li>
<li>通过使用复杂的布尔表达式，可方便地控制查询结果</li>
<li>相当有效的实现方法</li>
<li>经过某种训练的用户可以容易地写出布尔查询式</li>
<li>布尔模型可以通过扩展来包含排序的功能</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><strong>弱</strong>，不支持部分匹配，完全匹配会导致结果太多或太少</li>
<li>非常<strong>刚性</strong>：“与”意味着全部；“或”意味着任何一个，所有匹配文档都将被返回</li>
<li>不考虑索引词的权重，所有文档都以相同的方式和查询相匹配</li>
<li>很难进行自动的相关反馈</li>
</ul>
<h4 id="信息检索的基本假设"><a href="#信息检索的基本假设" class="headerlink" title="信息检索的基本假设"></a>信息检索的基本假设</h4><ul>
<li>集合：固定数量的文档</li>
<li>目标：找到与用户信息需求相关的含有信息量的文档，帮助用户完成一个任务。</li>
</ul>
<h4 id="典型的搜索模型"><a href="#典型的搜索模型" class="headerlink" title="典型的搜索模型"></a>典型的搜索模型</h4><ul>
<li><strong>构造矩阵→信息需求→文字形式→查询→查询优化→结果</strong></li>
</ul>
<h4 id="返回文档的好坏"><a href="#返回文档的好坏" class="headerlink" title="返回文档的好坏"></a>返回文档的好坏</h4><h5 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h5><p>返回的能满足用户信息需求的文档占<strong>总的返回文档</strong>的百分比</p>
<h5 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h5><p>返回的能满足用户信息需求的文档占<strong>总的能满足用户信息需求的文档</strong>的百分比</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><ul>
<li>对于每一个词项，存储所有包含这个词项的文档的一个<u><strong>列表</strong></u>。一个文档用一个<strong><u>序列号</u></strong>docID来表示</li>
<li>应当使用可变长度的记录表<ul>
<li>在硬盘上，一串连续的记录是正常的，也是最好的</li>
<li>在内存里，可以使用链表，或者可变长度的数组</li>
</ul>
</li>
</ul>
<h4 id="倒排索引建立步骤"><a href="#倒排索引建立步骤" class="headerlink" title="倒排索引建立步骤"></a>倒排索引建立步骤</h4><ol>
<li>收集需要建立索引的文档</li>
<li>将每篇文档转换成一个个词条（token）的列表，此个过程称为词条化（tokenization)</li>
<li>进行语言预处理，产生归一化的词条来作为词项</li>
<li>对所有文档按照其中出现的词项来建立倒排索引，索引中包括一部分词典和一个全体倒排索引表</li>
</ol>
<ul>
<li>词条序列Token Sequence</li>
</ul>
<p>（修改过的词条，文档ID）对序列</p>
<ul>
<li><p>排序</p>
<p>先按照词条排序，再按照docID排序</p>
</li>
<li><p>词典和倒排表</p>
<ul>
<li>同一篇文档中多次出现的词被合并</li>
<li>分割成<strong>词典</strong>和<strong>倒排表</strong></li>
<li>词汇的<strong><u>文档频率</u></strong>也被记录</li>
</ul>
</li>
<li><p>查询的处理:AND</p>
<ul>
<li>考虑这样的查询： Brutus AND Caesar<ul>
<li>在字典中找到Brutus，得到它的倒排记录表</li>
<li>在字典中找到Caesar，得到它的倒排记录表</li>
<li>合并两个倒排列表</li>
<li>同时扫描两个倒排记录表求交集，所需时间和倒排记录的数量呈线性关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="布尔检索模型"><a href="#布尔检索模型" class="headerlink" title="布尔检索模型"></a>布尔检索模型</h3><h4 id="文档表示-1"><a href="#文档表示-1" class="headerlink" title="文档表示"></a>文档表示</h4><p>一个文档被表示为关键词的集合</p>
<h4 id="查询表示-1"><a href="#查询表示-1" class="headerlink" title="查询表示"></a>查询表示</h4><p>查询式(Queries)被表示为<strong>关键词的布尔组合</strong>，用“与、或、非”连接起来(主析取范式DNF)</p>
<h4 id="相关度计算-1"><a href="#相关度计算-1" class="headerlink" title="相关度计算"></a>相关度计算</h4><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是<strong>二值匹配</strong>{0,1}</li>
</ul>
<h4 id="形式化表示"><a href="#形式化表示" class="headerlink" title="形式化表示"></a>形式化表示</h4><ol>
<li>定义：用q~dnf~ 表示查询q的析取范式，q~cc~表示q~dnf~的任意合取分量</li>
<li>文献d~j~与查询q的相似度为</li>
</ol>
<h4 id="布尔检索模型：布尔代数"><a href="#布尔检索模型：布尔代数" class="headerlink" title="布尔检索模型：布尔代数"></a>布尔检索模型：布尔代数</h4><h5 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h5><ul>
<li>只有“真”、“假”取值的变量</li>
</ul>
<h5 id="布尔操作（关系）"><a href="#布尔操作（关系）" class="headerlink" title="布尔操作（关系）"></a>布尔操作（关系）</h5><h5 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h5><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>布尔模型可以用来处理布尔表达式形式的查询</p>
<ul>
<li>布尔查询使用AND,OR和NOT来连接查询词汇<ul>
<li>将文档看作词汇的集合</li>
<li>精确：匹配或不匹配</li>
</ul>
</li>
<li>布尔模型式IR系统中最简单的模型</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul>
<li>按照文档频率的顺序进行处理。先处理文档频率小的，再处理大的。</li>
</ul>
<h2 id="3-词项词典和倒排记录表"><a href="#3-词项词典和倒排记录表" class="headerlink" title="3.词项词典和倒排记录表"></a>3.词项词典和倒排记录表</h2><h3 id="建立词项词典"><a href="#建立词项词典" class="headerlink" title="建立词项词典"></a>建立词项词典</h3><h4 id="文档解析"><a href="#文档解析" class="headerlink" title="文档解析"></a>文档解析</h4><ul>
<li>文档格式</li>
<li>文档中的语言</li>
<li>文档的编码方式</li>
</ul>
<h4 id="词条化"><a href="#词条化" class="headerlink" title="词条化"></a>词条化</h4><ul>
<li><p>将给定的字符序列拆分成一系列子序列的过程，其中每一个子序列称之为一个“词</p>
<p>条”Token。</p>
</li>
<li><p>词条(Tokens)、词项(Terms)</p>
</li>
<li><p>针对不同的语言，采用不同策略的词条化方法</p>
</li>
<li><p>分词的基本方法：</p>
<ul>
<li>基于词典的最大匹配法</li>
<li>机器学习方法</li>
</ul>
</li>
</ul>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><ul>
<li>停用词表：将词项按照<strong>文档集频率</strong>，从高到低排列。选取与文档意义不大，<strong>高频</strong>出现的词，例如a ,an , the , and, ….</li>
<li>优点：停用词消除可以减少term的个数</li>
<li>缺点：有时消除的停用词对检索有意义的 。 的士 ， to be or not to be</li>
<li>消除方法：查表法，基于文档频率</li>
</ul>
<h4 id="词项归一化"><a href="#词项归一化" class="headerlink" title="词项归一化"></a>词项归一化</h4><ul>
<li>将不完全一致的多个词条归纳成一个等价类，以便在它们之间进行匹配。</li>
<li>归一化结果：在IR系统的词项词典中，形成多个<strong>近似词项的一个等价类</strong></li>
<li>归一化策略：建立同义词扩展表</li>
</ul>
<h4 id="词干还原"><a href="#词干还原" class="headerlink" title="词干还原"></a>词干还原</h4><ul>
<li><strong>很粗略的去除单词两端的词缀的启发式过程</strong></li>
<li>能提高召回率，但是会降低准确率</li>
<li>porter算法</li>
</ul>
<h4 id="词形归并"><a href="#词形归并" class="headerlink" title="词形归并"></a>词形归并</h4><ul>
<li>利用词汇表和词形分析来减少曲折变化的形式，将其转变为基本形式 </li>
<li>词形归并可以减少词项词典中的词项数量</li>
</ul>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>词干还原在一般情况下会将多个派生相关词合并在一起</li>
<li>词形归并通常只将同一词元的不同曲折形式进行合并</li>
</ul>
<h3 id="实现倒排记录表"><a href="#实现倒排记录表" class="headerlink" title="实现倒排记录表"></a>实现倒排记录表</h3><h4 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h4><ul>
<li>通过在两个倒排表之间同时移动指针来实现合并，此时的操作与线性表的总数成线性关系。</li>
</ul>
<h4 id="基于调表的倒排记录表快速合并算法"><a href="#基于调表的倒排记录表快速合并算法" class="headerlink" title="基于调表的倒排记录表快速合并算法"></a>基于调表的倒排记录表快速合并算法</h4><ul>
<li>跳表指针能够跳过那些不可能出现在检索结果中的记录项</li>
<li>如果倒排表的长度是L，那么在每个$\sqrt L$处均放置跳表指针</li>
<li>跳表指针只对AND类型查询有用，对OR类型查询不起作用</li>
</ul>
<h4 id="短语查询"><a href="#短语查询" class="headerlink" title="短语查询"></a>短语查询</h4><h5 id="二元词索引"><a href="#二元词索引" class="headerlink" title="二元词索引"></a>二元词索引</h5><ul>
<li>将文档中每个连续词对看成一个短语，其中的每个二元词对豆浆作为词典中的词项。</li>
</ul>
<h5 id="扩展的二元词索引"><a href="#扩展的二元词索引" class="headerlink" title="扩展的二元词索引"></a>扩展的二元词索引</h5><h5 id="位置信息索引"><a href="#位置信息索引" class="headerlink" title="位置信息索引"></a>位置信息索引</h5><ul>
<li><p>在此索引中，对每个词项，都采取以下方式存储倒排表记录：</p>
<p> &lt;词项，词项频率;</p>
<p>   文档1：位置1，位置2，……</p>
<p>   文档2：位置1，位置2，……</p>
</li>
</ul>
<h2 id="4-索引构建"><a href="#4-索引构建" class="headerlink" title="4.索引构建"></a>4.索引构建</h2><h3 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h3><h3 id="语资料库"><a href="#语资料库" class="headerlink" title="语资料库"></a>语资料库</h3><h3 id="索引构建算法"><a href="#索引构建算法" class="headerlink" title="索引构建算法"></a>索引构建算法</h3><h4 id="基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）"><a href="#基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）" class="headerlink" title="基于块的排序索引算法（BSBI：Blocked sort-based Indexing）"></a>基于块的排序索引算法（BSBI：Blocked sort-based Indexing）</h4><ul>
<li>在索引构建过程中需要依次分析所有的文档，不能很容易利用压缩技巧。只有分析完所有文档，最终的倒排记录表才会完整。</li>
</ul>
<ul>
<li>基本思想：对每一个<strong>块</strong>都生成倒排记录，并排序，写入硬盘。然后将这些块<strong>合并</strong>成一个长的排好序的倒排记录。</li>
<li>每条数据占用12字节（4+4+4）（词项，文档，频数）</li>
<li>在内存中处理，累积放满固定的块，排序后写入硬盘f~i~ ，合并所有索引文件成一个</li>
</ul>
<h5 id="基于BSBI排序算法存在的问题"><a href="#基于BSBI排序算法存在的问题" class="headerlink" title="基于BSBI排序算法存在的问题"></a>基于BSBI排序算法存在的问题</h5><ul>
<li>假设能够将<strong><u>词典存入内存</u></strong>中</li>
<li>需要该词典动态增长去查找任一词项和词项ID之间的对应关系。</li>
<li>（一个可扩展的，但效率非常低的构建索引算法）</li>
</ul>
<h4 id="内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing"><a href="#内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing" class="headerlink" title="内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)"></a>内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)</h4><ul>
<li><p>核心思想：为每个块<strong>单独</strong>生成一个词典—— （不需要维护全局的&lt;词项,词项ID&gt;映射表）</p>
</li>
<li><p><strong>不进行排序</strong>。有新的&lt;词项,文档ID&gt;对时直接在倒排记录表中增加一项。</p>
<ul>
<li>可以为每个块生成一个完整的倒排索引，然后将这些单独的索引合并为一个大的索引</li>
</ul>
</li>
<li>压缩技术将会使SPIMI算法更加高效<ul>
<li>压缩词项</li>
<li>压缩倒排记录表</li>
</ul>
</li>
</ul>
<h4 id="分布式索引构建（Distributed-indexing）"><a href="#分布式索引构建（Distributed-indexing）" class="headerlink" title="分布式索引构建（Distributed indexing）"></a>分布式索引构建（Distributed indexing）</h4><ul>
<li><p>Web规模的索引构建</p>
<p>必须使用一个分布式的计算机集群</p>
</li>
<li><p>计算机都是故障频发的</p>
<ul>
<li>可能会在任意时刻失效</li>
</ul>
</li>
<li><p>利用集群中的主控节点来指挥索引构建工作</p>
<ul>
<li>认为主控节点是“安全的”</li>
</ul>
</li>
<li><p>将索引构建过程<strong>分解</strong>成一组并行的任务</p>
</li>
<li><p>主控计算机从集群中选取一台空闲的机器并将<strong>任务分配</strong>给它</p>
</li>
<li><p>采用两组不同的并行任务</p>
<ul>
<li><p>Parsers分析器</p>
<ol>
<li><p>主节点将一个数据片分配给一台空闲的分析服务器</p>
</li>
<li><p>分析器依次读取文档并生成&lt;词项,文档&gt;对。</p>
</li>
<li><p>分析器将这些&lt;词项,文档&gt;按照<em><strong>词项对</strong></em>分成$j$个段</p>
</li>
<li><p>每一段是按照词项首字母划分的一个区间。</p>
<p>例如：a-f,g-p,q-z 这里j=3</p>
</li>
<li><p>然后进行索引的倒排</p>
</li>
</ol>
</li>
<li>Inverters倒排器<ol>
<li><strong><em>对于一个词项分区</em></strong>，倒排器收集所有的&lt;词项,文档&gt;对（倒排记录）。</li>
<li>排序，并写入最终的倒排记录表。</li>
</ol>
</li>
</ul>
</li>
<li><p>首先，将输入文档集分割成n个数据片</p>
<ul>
<li>每个数据片就是一个文档子集（与BSBI/SPIMI算法中的数据块相对应）</li>
<li>两种分割方法<ul>
<li>基于词项的分割</li>
<li>基于文档的分割</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="数据流图"></p>
</li>
</ul>
<h3 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h3><h4 id="动态索引构建方法"><a href="#动态索引构建方法" class="headerlink" title="动态索引构建方法"></a>动态索引构建方法</h4><p>文档集通常不是静态的</p>
<ul>
<li>文档会不断的加入进来</li>
<li>文档也会被删除或者被修改</li>
</ul>
<p>词典和倒排记录表需要修改</p>
<ul>
<li>对于已在词典中的词项更新倒排记录</li>
<li>新的词项加入到词典中</li>
</ul>
<ol>
<li>周期性索引重构</li>
</ol>
<ul>
<li>建立索引的同时，旧索引继续工作</li>
<li>条件<ul>
<li>更新次数不是很多</li>
<li>能够接受对新文档检索的一定延迟（重构之前新文档检索不到）</li>
<li>有足够的资源进行重构</li>
</ul>
</li>
</ul>
<ol>
<li>维护一个大的主索引<ul>
<li>新文档信息存储在一个小的<strong>辅助索引</strong>中（位于内存）</li>
<li>检索可以同时遍历两个索引并将结果<strong>合并</strong></li>
<li>删除<ul>
<li>文档的删除记录在一个<strong>无效位向量</strong>中</li>
<li>在返回结果前利用它过滤掉已删除文档</li>
</ul>
</li>
<li>定期地将辅助索引合并到主索引中</li>
<li>文档更新通过先删除后插入的方式实现</li>
</ul>
</li>
</ol>
<h4 id="主索引与辅助索引存在的问题"><a href="#主索引与辅助索引存在的问题" class="headerlink" title="主索引与辅助索引存在的问题"></a>主索引与辅助索引存在的问题</h4><ul>
<li>频繁的合并带来很大开销</li>
<li>合并过程效率低<ul>
<li>如果每个词项的倒排记录表都单独成一个文件，那么合并主索引和辅助索引将会很高效。</li>
<li>合并是一个简单的添加操作</li>
<li>需要使用很多倒排文件—— 对文件系统来说是低效的</li>
</ul>
</li>
</ul>
<h4 id="对数合并"><a href="#对数合并" class="headerlink" title="对数合并"></a>对数合并</h4><ul>
<li>维护一系列索引$I_0, I_1 , I_2, … ,$每个都是前一个的两倍大小</li>
<li>辅助索引$Z_0$存储在内存中，而较大的（$I_0, I_1 , I_2, … ,$）存储在磁盘中</li>
<li>当$Z_0$达到上限时，将它写入磁盘$I_0$中，当下一次达到上限时，它会和$I_0$合并，生成$Z_1$<ul>
<li>此时，如果$I1$不存在，存储到$I1$中</li>
<li>如果$I1$已存在，则$Z1$与$I1$合并成$Z2 $(大小$2^{2*n}$)</li>
<li>此时，如果$I2$不存在，存储到$I2$中</li>
<li>如果$I2$已存在，则$Z2$与$I2$合并成Z3 (大小$2^{2*n}$)</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="4-索引压缩"><a href="#4-索引压缩" class="headerlink" title="4.索引压缩"></a>4.索引压缩</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>节省磁盘空间</li>
<li>提高内存的利用率（加快速度）</li>
<li>加快数据从磁盘到内存的传输速度<ul>
<li>[读取压缩数据][解压缩] 比直接 [读取未压缩的数据]快</li>
<li>前提：解压缩算法要很快</li>
</ul>
</li>
</ul>
<h4 id="压缩倒排索引的原因"><a href="#压缩倒排索引的原因" class="headerlink" title="压缩倒排索引的原因"></a>压缩倒排索引的原因</h4><ul>
<li>词典<ul>
<li>压缩的足够小以便放入内存中</li>
<li>当词典足够小时，也可以在内存中存储一部分倒排索引记录表</li>
</ul>
</li>
<li>倒排记录文件<ul>
<li>减少所需要的磁盘空间</li>
<li>减少从磁盘读取倒排记录文件所需的时间</li>
<li>大的搜索引擎在内存中存储了很大一部分倒排记录表<ul>
<li>压缩可以在内存中存储的更多</li>
</ul>
</li>
</ul>
</li>
<li>将涉及各种基于IR系统的压缩架构</li>
</ul>
<h3 id="词项统计量"><a href="#词项统计量" class="headerlink" title="词项统计量"></a>词项统计量</h3><h3 id="词典压缩"><a href="#词典压缩" class="headerlink" title="词典压缩"></a>词典压缩</h3><h4 id="有损压缩和无损压缩"><a href="#有损压缩和无损压缩" class="headerlink" title="有损压缩和无损压缩"></a>有损压缩和无损压缩</h4><ul>
<li>无损压缩：压缩之后所有原始信息都被保留<ul>
<li>在IR系统中常采用无损压缩</li>
</ul>
</li>
<li>有损压缩：丢掉一些信息</li>
<li>一些<strong>预处理步骤可以看成是有损压缩</strong>：大小写转化，停用词剔除，词干还原，数字去除等</li>
<li>有损还是无损与需求相关</li>
</ul>
<h4 id="Heaps定律：M-kT-b"><a href="#Heaps定律：M-kT-b" class="headerlink" title="Heaps定律：M=kT^b^"></a>Heaps定律：M=kT^b^</h4><ul>
<li>M是<strong>词项</strong>的数目，T是文档集中<strong>词条</strong>的个数</li>
<li>词汇量大小M和文档集大小T在对数空间存在斜率为1/2的线性关系。</li>
<li><strong>不同单词的数目与文本篇幅之间存在幂函数的关系</strong>，其幂指数小于1</li>
<li><strong>提供了对文档集中词汇量的估计</strong></li>
</ul>
<h4 id="Zipf定律"><a href="#Zipf定律" class="headerlink" title="Zipf定律"></a>Zipf定律</h4><ul>
<li><strong>词项在文档中的分布情况</strong></li>
</ul>
<ul>
<li>排名<strong>第i多</strong>的词项的文档集频率与1/i成正比</li>
<li>词项t~i~在文档集中出现的次数</li>
<li><strong>高频词项很少，低频罕见词项很多</strong></li>
</ul>
<h4 id="为什么要压缩词典"><a href="#为什么要压缩词典" class="headerlink" title="为什么要压缩词典"></a>为什么要压缩词典</h4><ul>
<li>搜索从词典开始</li>
<li>想将词典放入内存中和其他应用程序共享内存资源</li>
<li>手机或者嵌入式设备通常只有很小的内存</li>
<li>即使不在内存中，也希望足够小以便搜索能够快速启动</li>
</ul>
<h4 id="压缩词项列表：将词典看成单一字符串"><a href="#压缩词项列表：将词典看成单一字符串" class="headerlink" title="压缩词项列表：将词典看成单一字符串"></a>压缩词项列表：将词典看成单一字符串</h4><ul>
<li>将所有词项存储为一个长字符串<ul>
<li>指向下一词项的指针同时也标识着当前词项的结束</li>
<li>期望节省60%词典空间</li>
</ul>
</li>
</ul>
<h4 id="按块存储（Blocking）"><a href="#按块存储（Blocking）" class="headerlink" title="按块存储（Blocking）"></a>按块存储（Blocking）</h4><ul>
<li>每k个词项分词一块，只保留第一个指针</li>
<li>需要存储词项长度（额外一字节）</li>
</ul>
<h4 id="前端编码"><a href="#前端编码" class="headerlink" title="前端编码"></a>前端编码</h4><ul>
<li>按照词典顺序排列的连续词项之间往往具有<strong>公共前缀</strong></li>
<li>（块内k个词项的最后k-1个）</li>
</ul>
<h3 id="倒排记录表压缩"><a href="#倒排记录表压缩" class="headerlink" title="倒排记录表压缩"></a>倒排记录表压缩</h3><ul>
<li>倒排记录表远大于词典，至少10倍</li>
<li>紧密地存储每一个倒排记录表</li>
<li>每个倒排记录用<strong>文档ID</strong>来定义</li>
</ul>
<h4 id="倒排记录表：相反的两点"><a href="#倒排记录表：相反的两点" class="headerlink" title="倒排记录表：相反的两点"></a>倒排记录表：相反的两点</h4><ul>
<li>像“arachnocentric”这样的词项可能在一百万 个文档中才会出现一次 可以用log21M ≈ 20 bits来存储这一倒排记录。</li>
<li>像“the”这样的词项在每个文档中都会出现， 所以对它采用20bit/倒排记录太浪费了。<ul>
<li>这种情况更希望是0/1的bit向量<h4 id="倒排记录表项中文档ID的间距（GAP）"><a href="#倒排记录表项中文档ID的间距（GAP）" class="headerlink" title="倒排记录表项中文档ID的间距（GAP）"></a>倒排记录表项中文档ID的间距（GAP）</h4></li>
</ul>
</li>
<li>按照文档ID的递增顺序来存储一个词项的倒排列表<ul>
<li>Computer： 33，47，154，159，202，…</li>
</ul>
</li>
<li>可以存储间距<ul>
<li>33，14，107，5，43，…</li>
</ul>
</li>
<li>期望：绝大多数间距存储空间都远小于20bit</li>
</ul>
<h4 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h4><ul>
<li>目标：<ul>
<li>对于arachnocentric，使用20bit/间距项</li>
<li>对于the，使用1 bit/间距项</li>
</ul>
</li>
<li>如果词项的评价间距为G，我们想使用log2Gbit/间距项</li>
<li>关键问题：需要利用整个字节对每个间距编码<ul>
<li>可变长度编码：对一些小数字用短码来实现</li>
</ul>
</li>
<li>可变字节码：<ul>
<li>用一个字节来存储G，并分配1bit作为延续位</li>
<li>G$\le$127 对7位有效码采用二进制编码并设置延续位c=1（结束)</li>
<li>G$&gt;$127 则先对G低阶的7位编码，然后采用相同的算法用额外字节对高阶bit位进行编码</li>
<li>设置最后一个字节的延续位为1（c=1)，其他字节的c=0（未结束）</li>
</ul>
</li>
</ul>
<h2 id="5-Web搜索"><a href="#5-Web搜索" class="headerlink" title="5.Web搜索"></a>5.Web搜索</h2><h3 id="Web搜索基础"><a href="#Web搜索基础" class="headerlink" title="Web搜索基础"></a>Web搜索基础</h3><h4 id="重复文档"><a href="#重复文档" class="headerlink" title="重复文档"></a>重复文档</h4><ul>
<li>完全复制Duplication ： 可以通过指纹（fingerprints）来检测精确匹配</li>
<li>近似重复Near-Duplication：通过编辑距离计算语法上的相似性</li>
</ul>
<h4 id="相似性计算"><a href="#相似性计算" class="headerlink" title="相似性计算"></a>相似性计算</h4><ul>
<li>搭叠Shingles（N元词N-Grams）<ul>
<li>给定正整数K及文档d的一个词项序列可以定义文档d的k-shingle为d中所有k个连续词项构成的序列</li>
</ul>
</li>
<li>Jaccard系数：衡量重复度<ul>
<li>表示公式： 交集 / 并集</li>
<li>计算所有文档对之间搭叠的<strong>精确交集</strong>非常费时而且难以处理</li>
<li>使用冲Shingles中选出一个<strong>子集</strong>（素描sketch）来近似计算（抽样Sample）</li>
</ul>
</li>
</ul>
<h4 id="小结：近似重复检测"><a href="#小结：近似重复检测" class="headerlink" title="小结：近似重复检测"></a>小结：近似重复检测</h4><ul>
<li>Shingle算法的核心思想是将<strong>文件相似性</strong>问题转换为<strong>集合的相似</strong>性问题</li>
<li>数量较大时，对Shingle集合进行<strong>抽样</strong>，以降低空间和时间计算复杂性</li>
<li>shingle取样三种方法：Min-Wise,Modm,Mins</li>
</ul>
<h3 id="Web采集"><a href="#Web采集" class="headerlink" title="Web采集"></a>Web采集</h3><h4 id="采集器"><a href="#采集器" class="headerlink" title="采集器"></a>采集器</h4><ol>
<li>从已知种子URL开始</li>
<li>获取页面并解析<ol>
<li>提取页面中包含的链接</li>
<li>将链接放入URL队列</li>
</ol>
</li>
<li>对队列中的URL转2</li>
</ol>
<h5 id="采集器必须具有的功能"><a href="#采集器必须具有的功能" class="headerlink" title="采集器必须具有的功能"></a>采集器必须具有的功能</h5><ul>
<li>礼貌性：Web服务器有显示或隐式的策略控制采集器的访问</li>
<li>鲁棒性：能从采集器陷阱中跳出，能处理Web服务器的其他恶意行为</li>
<li>分布式：可以在多台机器上分布运行</li>
<li>可扩展性：添加更多机器后采集效率应该提高</li>
<li>性能和效率：充分利用不同的系统资源，包括处理器、存储器和网络带宽</li>
<li>新鲜度：对原来爬取的网页进行更新</li>
<li>功能可扩展性：支持多方面的功能扩展，例如处理新的数据格式、抓取新的协议。</li>
</ul>
<h4 id="采集器基本架构"><a href="#采集器基本架构" class="headerlink" title="采集器基本架构"></a>采集器基本架构</h4><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E9%87%87%E9%9B%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="采集器"></p>
<h4 id="Web-图"><a href="#Web-图" class="headerlink" title="Web 图"></a>Web 图</h4><h5 id="Web-→Web图"><a href="#Web-→Web图" class="headerlink" title="Web →Web图"></a>Web →Web图</h5><ul>
<li>将静态Web看成静态HTML网页通过超链接互相连接而成的有向图，其中每个<strong>网页</strong>是<strong>图的顶点</strong>，而每个超链接式图的<strong>有向边</strong>。</li>
<li>该有向图可能不是一个强连通图，即从一个网页出发，沿着超链接前进，有可能永远不会到达另外某个网页</li>
<li><strong>指向</strong>某个网页的链接称为 <strong><u>入链接</u></strong>（in-link)，而从某个网页指出去的链接称为<strong><u>出链接</u></strong>（out-link）。</li>
<li>入度：网页的入链数目。  出度：网页的出链数目</li>
</ul>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><ul>
<li>每个网页都用唯一的整数来表示</li>
<li>建立一个<strong>类似于倒排索引</strong>的邻接表，每行对应一个网页，按照其对应的整数大小排序。</li>
<li>任一网页P对应的行中包含的也是一系列整数的排序结构，每个整数对应<strong><u>链向P</u></strong>的网页编号。（那些网页指向P）</li>
</ul>
<h4 id="链接分析"><a href="#链接分析" class="headerlink" title="链接分析"></a>链接分析</h4><h5 id="Web是有向图"><a href="#Web是有向图" class="headerlink" title="Web是有向图"></a>Web是有向图</h5><ul>
<li>假设1：A到B的超链接表示A的作者对B的认可</li>
<li>假设2：指向页面B的锚文本式对B一个很好的描述</li>
</ul>
<h5 id="索引锚文本"><a href="#索引锚文本" class="headerlink" title="索引锚文本"></a>索引锚文本</h5><ul>
<li>索引文档D的时候，也索引指向文档D的锚文本</li>
<li>可以根据锚文本<strong><u>所在页面的权威性</u></strong>来确定锚文本的权重</li>
</ul>
<h5 id="小结：锚文本"><a href="#小结：锚文本" class="headerlink" title="小结：锚文本"></a>小结：锚文本</h5><ul>
<li>Web上很多网页的内容并不包含对自身的精确描述</li>
<li>Web搜索者不一定要使用网页中的词项来对网页进行查询，而使用锚文本。</li>
<li>锚文本周围窗口中的文本也可以当成锚文本一样来使用。</li>
</ul>
<h4 id="链接分析：PageRank"><a href="#链接分析：PageRank" class="headerlink" title="链接分析：PageRank"></a>链接分析：PageRank</h4><h5 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h5><ul>
<li>对Web图中的每个节点赋一个0~1间的分值，这个分值为PageRank</li>
<li><strong>查询词无关</strong>的排序</li>
<li>第一代版本：使用<strong>链接的数目</strong>作为流行程度的最简单度量</li>
<li>两个改进：<ul>
<li>无向流行度：赋予每个页面一个分：出链数+入链数</li>
<li>有向流行度：页面分数 = <strong>入链数</strong></li>
</ul>
</li>
</ul>
<h5 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h5><ul>
<li>检索出所有满足文本查询词的页面，然后把这些页面按照链接的流行的排序。</li>
<li>更复杂：把链接按流行度当作静态得分，结合文本匹配的分数进行综合排序</li>
</ul>
<h5 id="PageRank打分"><a href="#PageRank打分" class="headerlink" title="PageRank打分"></a>PageRank打分</h5><ul>
<li>假设一个浏览者在网络上随机行走<ul>
<li>从一个随机页面开始，每一步从当前页等概率地选择一个链接，进入链接所在页面</li>
</ul>
</li>
<li>在稳定状态下，每个页面都有一个访问概率——用这个概率作为页面的分数</li>
<li>当浏览者在Web上进行节点间的随机游走时，某些节点的访问次数会比其他的节点更多</li>
<li>访问频繁的节点具有很多从其它频繁访问节点中指向的入链接</li>
<li>PageRank思路：<strong>在随机游走过程中越频繁访问的网页越重要</strong></li>
</ul>
<h5 id="随机跳转（Teleporting）"><a href="#随机跳转（Teleporting）" class="headerlink" title="随机跳转（Teleporting）"></a>随机跳转（Teleporting）</h5><ul>
<li>遇到dead end时，随机跳转到一个页面，如果页面总数总是N，那么随机跳转的概率式1/N</li>
<li>非dead end， 以$a$(值较小)的概率跳转到一个随机页面；以剩余1-a的概率从页面的出链中选择一个</li>
<li>随机跳转结果：不会再困在一个地，将会有比率表示所有网页长期被访问的概率</li>
</ul>
<h5 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h5><ul>
<li>一个Markov链有<strong>N个状态</strong>，以及一个NxN的<strong>转移概率矩阵P</strong>。每一步只能处在一个状态</li>
<li>$1 \le i,j\le N$，转移概率矩阵P~ij~给出了从状态i到下一个状态j的条件转移概率</li>
<li>P中每一行的元素之和为1，从该页面跳转道其所有出链的概率之和为1</li>
<li>满足上述性质的非负矩阵被成为随机矩阵。最大特征值是1，与该特征值对应的有一个<strong>左特征向量</strong></li>
<li>马尔科夫链中下一个状态的分布仅仅依赖于当前的状态，与如何到达当前状态无关。</li>
<li>马尔科夫链的状态概率分布可以看成一个概率向量，每个元素都在[0,1]，且所有元素的和为1（行）</li>
</ul>
<h5 id="邻接矩阵A→概率转移矩阵P"><a href="#邻接矩阵A→概率转移矩阵P" class="headerlink" title="邻接矩阵A→概率转移矩阵P"></a>邻接矩阵A→概率转移矩阵P</h5><ul>
<li>如果一行没有1（没有出链），用1/N代替每个元素</li>
<li>否则<ul>
<li>每行中用1的个数除每个1。（归一化） 若某行3个1，每个1用1/3表示</li>
<li>上面处理的结果矩阵乘以1-a</li>
<li>上面结果矩阵元素加上  a/N </li>
</ul>
</li>
</ul>
<h5 id="概率向量的变化"><a href="#概率向量的变化" class="headerlink" title="概率向量的变化"></a>概率向量的变化</h5><ul>
<li>最终访问频率收敛与固定的、稳态概率π</li>
<li>算法： 给 <strong><em>X</em></strong> 乘上P的k次方，k不断增加，直到乘积稳定</li>
<li><strong><em>π</em></strong>P = <strong><em>π</em></strong>  <ul>
<li>解矩阵等式得到<strong><em>π</em></strong></li>
<li><strong><em>π</em></strong>是P的主左特征向量，<strong><em>π~i~</em></strong>是页面i的PageRank</li>
</ul>
</li>
</ul>
<h3 id="链接分析：HITS"><a href="#链接分析：HITS" class="headerlink" title="链接分析：HITS"></a>链接分析：HITS</h3><ul>
<li>对每个网页给出两个得分 hub值（导航） ，authority值（权威）</li>
<li>确定基本集</li>
<li>精选出Hub页和Authority页</li>
<li>迭代跟新h(x),a(x)<ul>
<li>输出h(x)最高作为Top Hub页，a(x)最高作为Top Authority页</li>
</ul>
</li>
<li>大概5次迭代就会稳定</li>
<li>h是$AA^t$的特征向量，a是$A^tA$的特征向量</li>
</ul>
<h2 id="6-向量模型"><a href="#6-向量模型" class="headerlink" title="6.向量模型"></a>6.向量模型</h2><h3 id="排序式检索"><a href="#排序式检索" class="headerlink" title="排序式检索"></a>排序式检索</h3><p>布尔检索：文档要么匹配要么不匹配。对自身需求和文档集性质非常了解的专家而言，布尔查询式不错的选择。然而对大多数用户来说不方便</p>
<ul>
<li>布尔查询的结果不是太多就是太少</li>
<li>需要花费很多精力去<strong>构造一个合适的query</strong>才可以获得一个在数量上可以接受的查询结果。</li>
</ul>
<h4 id="排序检索模型"><a href="#排序检索模型" class="headerlink" title="排序检索模型"></a>排序检索模型</h4><ul>
<li>在排序检索模型中，系统根据<strong>文档与query的相关性排序</strong>返回文档集合中的文档，而不是简单地返回所有满足query描述的文档集合。</li>
<li>自由文本查询：用户query是自然语言的一个或多个词语而不是由查询语言构造的表达式。</li>
<li>总体上，排序检索模型中有布尔查询和自由文本查询两种方式，但是实际中排序检索模型总是与自由文本查询联系在一起，反之亦然。</li>
</ul>
<h4 id="过多、过少不再是问题"><a href="#过多、过少不再是问题" class="headerlink" title="过多、过少不再是问题"></a>过多、过少不再是问题</h4><ul>
<li>当系统给出的式有序的查询结果，查询结果数目多不再是问题。只需要给出<strong>top K</strong>（10个左右）个结果，为用户减轻负担。</li>
<li>前提是有<strong>合适的排序算法</strong></li>
</ul>
<h4 id="排序检索的基本—-评分"><a href="#排序检索的基本—-评分" class="headerlink" title="排序检索的基本—-评分"></a>排序检索的基本—-评分</h4><p>希望根据文档对查询者的有用性大小顺序将文档返回给查询者</p>
<ul>
<li>给每个“查询—文档”对进行评分，在[0,1]之间</li>
<li><strong><em><em>这个评分值衡量文档与query的匹配程度</em></em></strong></li>
<li>以单个单词组成的query为例<ul>
<li>如果单词不出现在文档中，该文档得分为0</li>
<li>该词项在文档中出现的频率越高，则评分越高</li>
</ul>
</li>
</ul>
<h5 id="评分方案一—-Jaccard系数"><a href="#评分方案一—-Jaccard系数" class="headerlink" title="评分方案一—-Jaccard系数"></a>评分方案一—-Jaccard系数</h5><p>一种常用的衡量<strong>两个集合A,B重叠度</strong>的方法</p>
<ul>
<li>$Jaccard(A,B) = |A \cap B| / |A \cup B|$</li>
<li>$Jaccard(A,A) = 1$</li>
<li>$Jaccard(A,B) = 0 \ if\  A \cap B=0$</li>
<li>集合A和B不需要具有同样的规模</li>
<li>Jaccard(A,B)的取值在[0,1]</li>
</ul>
<p>用Jaccard系数评分的问题</p>
<ul>
<li>没有考虑<strong><em>词项频率</em></strong>（词项在文档中出现的次数）</li>
<li>没有考虑<strong><em>罕见词比高频词的信息量更大，更具区分度</em></strong></li>
</ul>
<h3 id="词项频率"><a href="#词项频率" class="headerlink" title="词项频率"></a>词项频率</h3><h4 id="词项–文档二值关联矩阵"><a href="#词项–文档二值关联矩阵" class="headerlink" title="词项–文档二值关联矩阵"></a>词项–文档二值关联矩阵</h4><ul>
<li>每个文档用一个二值向量表示 $\in {0,1}^{|v|}$  。每个词项是否属于某个文档</li>
</ul>
<h4 id="词项—文档词频关联矩阵"><a href="#词项—文档词频关联矩阵" class="headerlink" title="词项—文档词频关联矩阵"></a>词项—文档词频关联矩阵</h4><ul>
<li>考虑词项在文档中出现的频率，将每个文档看成是一个<strong><em>词频向量</em></strong>：矩阵中的一列</li>
</ul>
<h4 id="词袋模型（Bag-of-words）"><a href="#词袋模型（Bag-of-words）" class="headerlink" title="词袋模型（Bag of words）"></a>词袋模型（Bag of words）</h4><ul>
<li><p><strong>不考虑词在文档中出现的顺序</strong></p>
<p>“John is quicker than Mary” 和 “Mary is quicker than John” 的表示结果一样</p>
</li>
</ul>
<h5 id="词项频率tf（Term-frequency）"><a href="#词项频率tf（Term-frequency）" class="headerlink" title="词项频率tf（Term frequency）"></a>词项频率tf（Term frequency）</h5><p>词项频率：词项t在文档d中出现的次数，记为$tf_{t,d}$</p>
<ol>
<li>采用原始tf值（raw tf）<ul>
<li>某个词项在A文档中出现10次，即tf=10，在B文档中tf=1，那么A比B更相关，但是相关度不会相差10倍</li>
<li><strong><em>相关性不会正比于词项频率</em></strong></li>
</ul>
</li>
<li>对数词频<ul>
<li>词项t在文档d中的对数频率权重</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%AF%B9%E6%95%B0%E9%A2%91%E7%8E%87.png" alt="对数词频"><ul>
<li>文档——词项的<strong><em>匹配得分</em></strong>是所有<strong>同时出现</strong>在<u>query</u>和<u>文档d</u>中的词项的词频的对数之和</li>
<li>$Score(q,d) = \sum<em>{t\in q\cap d} (1+log^{tf</em>{t,d}})$</li>
<li>评分为0，表示文档和query没有<strong><em>公共词项</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="tf-idf权重计算"><a href="#tf-idf权重计算" class="headerlink" title="tf-idf权重计算"></a>tf-idf权重计算</h3><p>除词项频率tf之外，利用<strong>词项在整个文档集中</strong>的频率进行权重和评分计算</p>
<h4 id="罕见词所期望的权重"><a href="#罕见词所期望的权重" class="headerlink" title="罕见词所期望的权重"></a>罕见词所期望的权重</h4><ul>
<li><strong>罕见词比常见词所蕴含的信息更多</strong></li>
<li>考虑查询中某个词项，它会在整个文档集中非常罕见</li>
<li><strong>某篇包含该词项的文档很可能相关</strong>，故罕见词项将有较高权重</li>
</ul>
<h4 id="常见词项所期望的权重"><a href="#常见词项所期望的权重" class="headerlink" title="常见词项所期望的权重"></a>常见词项所期望的权重</h4><ul>
<li>常见词项的<strong>信息量</strong>不如罕见词</li>
<li>考虑一个查询此项，它频繁出现在文档集中</li>
<li>一篇包含该词项的文档当然比不包含该词项的文档的相关度要高</li>
<li>但是，这些词对于相关度而言并<strong><em><em>不是非常强的指示词</em></em></strong>，故<strong><em><em>给一个正的权重，但是整个权重小于罕见词权重</em></em></strong></li>
</ul>
<h4 id="文档频率（Document-frequency，df）"><a href="#文档频率（Document-frequency，df）" class="headerlink" title="文档频率（Document frequency，df）"></a>文档频率（Document frequency，df）</h4><ul>
<li>罕见词项赋予高权重</li>
<li>常见词项赋予正的低权重</li>
<li>文档频率$df$因子来计算 查询–文档的匹配得分</li>
<li><strong><em>文档频率</em></strong>：出现词项的文档数目</li>
</ul>
<h4 id="idf（inverse-document-frequency）逆文档频率"><a href="#idf（inverse-document-frequency）逆文档频率" class="headerlink" title="idf（inverse document frequency）逆文档频率"></a>idf（inverse document frequency）逆文档频率</h4><ul>
<li>$df_t$是词项t的<strong>文档频率</strong>：<strong>文档集合中包含t的文档数目</strong><ul>
<li>$df_t$与词项t包含的<strong>信息量</strong>成<strong>反比</strong>（出现文档数目越多，该词项的信息量相对较小）</li>
<li>$df_t \le N$ (N是文档的总数)</li>
</ul>
</li>
<li><p>定义t的<strong>逆文档频率</strong>为$idf$</p>
<p>  $idf<em>t = log</em>{10}(N/df_t)$</p>
</li>
<li>$idf_t$是反应<strong>词项t的信息量</strong>的一个指标</li>
<li>用$log_{10}(N/df_t)$来代替$\frac{N}{df_t}$来抑制idf的作用</li>
</ul>
<h4 id="idf对排序的影响"><a href="#idf对排序的影响" class="headerlink" title="idf对排序的影响"></a>idf对排序的影响</h4><ul>
<li>对于含有<strong>两个以上查询词的query</strong>，$idf$才会影响排序结果；只有一个查询词的query，idf对排序结果没有影响</li>
<li>例如 Query: arachnocentric line ， idf会提高 arachnocentric的相对权重，同时减低line的相对权重</li>
</ul>
<h4 id="文档集频率和文档频率"><a href="#文档集频率和文档频率" class="headerlink" title="文档集频率和文档频率"></a>文档集频率和文档频率</h4><ul>
<li>文档集频率（collection frequency,cf）是<u>指t在整个文档集合中出现的<strong><em><em>词的次数</em></em></strong></u>。</li>
<li>文档频率（document frequency，df）<u>包含该词项的<strong><em><em>文档数目</em></em></strong></u></li>
<li>df比cf更适合权重计算</li>
</ul>
<h4 id="tf–idf文档-逆文档频率（单个词）"><a href="#tf–idf文档-逆文档频率（单个词）" class="headerlink" title="tf–idf文档-逆文档频率（单个词）"></a>tf–idf文档-逆文档频率（单个词）</h4><ul>
<li>tf-idf是信息检索中最著名的权重计算方法</li>
<li>词项t的tf-idf式由它的tf和idf组合而成</li>
<li>$w<em>{t,d} = (1+logtf</em>{t,d})\times\log_{10}(N/df_t)$</li>
<li>tf-idf值随着<strong><em>词项在单个文档中出现次数(tf)增加而增加</em></strong>，随着<strong><em>词项在文档集中数目(df)增加而减小</em></strong></li>
</ul>
<h4 id="Query-最终文档排序"><a href="#Query-最终文档排序" class="headerlink" title="Query 最终文档排序"></a>Query 最终文档排序</h4><p>$Score(q,d) = \sum<em>{t\in q \cap d}tf*idf</em>{t,d}$</p>
<h3 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h3><ul>
<li>二值关联矩阵：每个文档用一个二值向量表示 $\in {0,1}^{|v|}$</li>
<li>词频矩阵：每篇文档表示成一个词频向量 $\in N^{|v|}$</li>
<li>tf-idf矩阵：每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$</li>
</ul>
<h4 id="文档表示成向量"><a href="#文档表示成向量" class="headerlink" title="文档表示成向量"></a>文档表示成向量</h4><ul>
<li>每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$(V式词项集合，|v|表示词项个数)</li>
<li>|v|维实向量空间<ul>
<li>空间每一维都对应<strong>词项</strong></li>
<li><strong>文档</strong>是空间的点或者向量</li>
<li>维度非常高：特别是互联网搜索引擎，空间可达千万维或更高</li>
<li>向量空间非常<strong>稀疏</strong>：对每个向量来说大部分都是0</li>
</ul>
</li>
</ul>
<h4 id="Queries表示成向量"><a href="#Queries表示成向量" class="headerlink" title="Queries表示成向量"></a>Queries表示成向量</h4><ol>
<li>对于查询做同样的处理，即将查询表示成统一高维空间的向量</li>
<li>在向量空间内根据query与<strong>文档相量间的距离</strong>来排序</li>
</ol>
<h4 id="利用夹角代替距离"><a href="#利用夹角代替距离" class="headerlink" title="利用夹角代替距离"></a>利用夹角代替距离</h4><ul>
<li>按query与文档夹角递减给文档排序，按余弦递增给文档排序 是的等价的。</li>
<li>按余弦cosine(query,document)递减给文档排序，只考虑相对顺序</li>
</ul>
<h4 id="文档长度归一化"><a href="#文档长度归一化" class="headerlink" title="文档长度归一化"></a>文档长度归一化</h4><ul>
<li>利用二范数对文档长度进行归一化，一个文档向量除以它的L~2~范数就是给这个文档进行长度归一化</li>
</ul>
<h2 id="6-检索系统"><a href="#6-检索系统" class="headerlink" title="6.检索系统"></a>6.检索系统</h2><h3 id="排序的重要性"><a href="#排序的重要性" class="headerlink" title="排序的重要性"></a>排序的重要性</h3><ul>
<li>用户只希望看到一些而不是成千上万的结果</li>
<li>很难构造只产生一些结果的查询，即使是专家也很难</li>
<li>→排序能够将成千上万条结果缩减至几条结果，因此非常重要</li>
<li>实际上大部分用户只看到1-3条结果</li>
</ul>
<h4 id="摘要阅读"><a href="#摘要阅读" class="headerlink" title="摘要阅读"></a>摘要阅读</h4><p>用户更可能阅读前几页(1, 2, 3, 4)的结果的摘要</p>
<h4 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h4><p>点击的分布甚至更有偏向性</p>
<ul>
<li>一半情况下，用户点击排名最高的页面<ul>
<li>即使排名最高的页面不相关，仍然有30%的用户会点击它            </li>
</ul>
</li>
<li>正确排序相当重要，把相关的页面放在首页非常重要</li>
</ul>
<h3 id="结果排序的实现"><a href="#结果排序的实现" class="headerlink" title="结果排序的实现"></a>结果排序的实现</h3><h4 id="tf和idf的存储"><a href="#tf和idf的存储" class="headerlink" title="tf和idf的存储"></a>tf和idf的存储</h4><ul>
<li><p>词典中保存每个词的idf</p>
</li>
<li><p>词项频率tf存入倒排索引</p>
<p>term|idf    →  d1,tf , \<p1,p2,…> d5, tf, \<p1,p2,…></p1,p2,…></p1,p2,…></p>
</li>
</ul>
<h4 id="精确top-K检索机器加速办法"><a href="#精确top-K检索机器加速办法" class="headerlink" title="精确top K检索机器加速办法"></a>精确top K检索机器加速办法</h4><ul>
<li>从文档集所有文档中找出K个离查询最近的文档</li>
<li>步骤：对每个文档频繁（余弦相似度），按评分高低排序，选出前K个结果</li>
<li>如何加速：<ul>
<li>加快每个余弦相似度的计算</li>
<li>不对所有文档的评分结果排序而直接选出top K篇</li>
<li>能否不需要计算所有N篇文档的得分</li>
</ul>
</li>
</ul>
<h4 id="快速计算余弦相似度"><a href="#快速计算余弦相似度" class="headerlink" title="快速计算余弦相似度"></a>快速计算余弦相似度</h4><ul>
<li>检索排序就是找查询的k临近</li>
<li>如果查询很短，可以加速<ul>
<li>查询的多个词项无权重</li>
<li>排序只需要相对得分</li>
</ul>
</li>
</ul>
<h4 id="堆排序法N中选K"><a href="#堆排序法N中选K" class="headerlink" title="堆排序法N中选K"></a>堆排序法N中选K</h4><ul>
<li>检索时，通常只需要返回前K条结果</li>
<li>令J=具有非零余弦相似度值的文档数目，利用对结构从J中选K个最大的</li>
</ul>
<h4 id="提前终止计算"><a href="#提前终止计算" class="headerlink" title="提前终止计算"></a>提前终止计算</h4><h4 id="非精确top-K检索的可行性"><a href="#非精确top-K检索的可行性" class="headerlink" title="非精确top K检索的可行性"></a>非精确top K检索的可行性</h4><ul>
<li>索引去除：<ul>
<li>对于一个包含多个词项的查询来说，可以只考虑<strong>至少包含一个查询词项的文档</strong></li>
<li>只考虑那些词项的<strong>idf值</strong>超过一定阈值的文档</li>
<li>只考虑包含<strong>多个查询词项</strong></li>
</ul>
</li>
<li>胜者表<ul>
<li>对于词典中的每个词项t，预先计算出r个最高权重的文档<ul>
<li>词项t所对应的tf值最高的r篇文档构成t的胜者表，r值<strong>在索引建立时给定</strong>可能r&lt;k</li>
</ul>
</li>
<li>根据给定查询q，对查询q中所有词项的胜者表求并集生成集合A。根据余弦相似度大小从A中选取前top K个文档</li>
</ul>
</li>
<li>静态得分<ul>
<li>希望排序考前的文档既相关又是权威的<ul>
<li>相关性通过余弦相似度得分来判断</li>
<li>权威性由文档本身的属性决定</li>
</ul>
</li>
<li>​</li>
</ul>
</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>信息检索的目标式<strong><em><em>较少消耗情况下尽快、全面返回准确的结果。</em></em></strong></p>
<h3 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h3><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><ul>
<li>时间开销</li>
<li>空间开销</li>
<li>响应速度<h4 id="效果（Effectiveness）"><a href="#效果（Effectiveness）" class="headerlink" title="效果（Effectiveness）"></a>效果（Effectiveness）</h4></li>
<li>返回的文档中有多少相关文档</li>
<li>所有相关文档中反回了多少</li>
<li>返回得靠不靠前<h4 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h4></li>
<li>覆盖率（Coverage）</li>
<li>访问量</li>
<li>数据更新速度</li>
</ul>
<h4 id="评价效果"><a href="#评价效果" class="headerlink" title="评价效果"></a>评价效果</h4><ul>
<li><strong>相同的文档</strong>集合，<strong>相同的查询</strong>主题集合，<strong>相同的评价指标</strong>，<strong>不同</strong>的检索系统进行比较。</li>
</ul>
<h3 id="无序检索结果的评价"><a href="#无序检索结果的评价" class="headerlink" title="无序检索结果的评价"></a>无序检索结果的评价</h3><h4 id="对单个查询进行评估的指标"><a href="#对单个查询进行评估的指标" class="headerlink" title="对单个查询进行评估的指标"></a>对单个查询进行评估的指标</h4><h5 id="对整个文档集合的划分"><a href="#对整个文档集合的划分" class="headerlink" title="对整个文档集合的划分"></a>对整个文档集合的划分</h5><ul>
<li>未检索出（Not Retrieved）<ul>
<li>未检索出的相关文档(NR)</li>
<li>未检索出的不相关文档 (NN)</li>
</ul>
</li>
<li>检索出（Retrieved）<ul>
<li>检索出的相关文档(RR)</li>
<li>检索出的不相关文档(RN)<h5 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h5></li>
</ul>
</li>
<li>召回率(Recall):RR/(RR+NR),返回的相关结果数占实际相关结果总数的比率，也称为查全率，$R\in[0,1]$</li>
<li>正确率(Precision):RR/(RR+RN),返回的结果中真正相关的比率，也称查准率，$P\in[0,1]$</li>
<li>两个指标分别度量检索效果的某个方面，忽略任何一个方面都有偏失。</li>
<li>两个极端情况<ol>
<li>返回有把握的1篇，P=100%，但R极低</li>
<li>全部文档都返回，R=1，但P极低</li>
</ol>
</li>
<li>虽然Precision和Recall都很重要，但是不同的应用、不同的用户对两者的要求不一样。</li>
</ul>
<h4 id="正确率和召回率的问题"><a href="#正确率和召回率的问题" class="headerlink" title="正确率和召回率的问题"></a>正确率和召回率的问题</h4><ul>
<li>应用领域<ul>
<li>拼写校对、中文分词、文本分类、人脸识别、…… </li>
</ul>
</li>
</ul>
<ul>
<li>召回率难以计算<ul>
<li>Pooling方法，或则不考虑召回率</li>
</ul>
</li>
<li>两个指标分别衡量了系统的某个方面，但是如何评价哪个系统好<ul>
<li>将两个指标融成一个指标</li>
</ul>
</li>
<li>两个指标都是基于<strong><em>集合（无序）进行</em></strong>计算，并没有考虑序的作用<ul>
<li>引入序的作用</li>
</ul>
</li>
</ul>
<h5 id="召回率的计算"><a href="#召回率的计算" class="headerlink" title="召回率的计算"></a>召回率的计算</h5><p>对于大规模语料集合，列举每个查询的所有相关文档不可能，因此不可能准确地计算召回率</p>
<ul>
<li>缓冲池（Pooling）方法：对多个检索系统的TopN个结果组成的集合进行人工标注，标注相关文档集合作为整个相关文档集合</li>
</ul>
<h5 id="使用查准率-查全率的问题"><a href="#使用查准率-查全率的问题" class="headerlink" title="使用查准率/查全率的问题"></a>使用查准率/查全率的问题</h5><ul>
<li>需要在<strong>大规模</strong>的文档集合和查询集合上进行计算</li>
<li><p>需要<strong>人工</strong>对返回的文档进行评价</p>
<ul>
<li>由于人的主观因素，人工评价往往不可靠</li>
</ul>
</li>
<li><p>评价是二值的</p>
<ul>
<li>无法体现细微的差别</li>
</ul>
</li>
<li>文档结合和数据来源不同，结果也不同，有严重的偏差<ul>
<li>评价结果只适用于某个范围，很难引申到其他范围</li>
</ul>
</li>
</ul>
<h4 id="综合评价准则-F-P和R融合"><a href="#综合评价准则-F-P和R融合" class="headerlink" title="综合评价准则 F=P和R融合"></a>综合评价准则 F=P和R融合</h4><ul>
<li>F值（F-measure):召回率R和查准率的加权调和平均值</li>
<li>$F = \frac{1}{\alpha^\frac{1}{p}+(1-\alpha)^\frac{1}{R}}=\frac{(\beta^2+1)PR}{\beta^2P+R}$</li>
<li>$F_\beta$ ：表示召回率的重要程度是查准率的$\beta(&gt;=0)$倍<ul>
<li>$\beta&gt;1$ 更重视召回率，$\beta&lt;1$更重视查准率</li>
<li>取等权重</li>
<li>$F_{\beta=1} = \frac{2PR}{P+R}$</li>
</ul>
</li>
<li>调和平均比较保守</li>
</ul>
<h4 id="精确率不适合IR的原因"><a href="#精确率不适合IR的原因" class="headerlink" title="精确率不适合IR的原因"></a>精确率不适合IR的原因</h4><ul>
<li>和查询相关的文档占文档集的极少数，即使什么都不返回也会得到很高的精确率</li>
<li>用户希望找到某些文档并且能够容忍结果中有一定的不相关性</li>
<li>返回一些即使不好的文档也比不反回任何文档好</li>
</ul>
<h3 id="有序检索结果的评价"><a href="#有序检索结果的评价" class="headerlink" title="有序检索结果的评价"></a>有序检索结果的评价</h3><h4 id="评价排序后的结果"><a href="#评价排序后的结果" class="headerlink" title="评价排序后的结果"></a>评价排序后的结果</h4><ul>
<li>P、R、F值都是基于集合的评价方法，它们都是利用无序的文档集合进行计算。如果搜索引擎输出为有序的检索结果时，需要扩展</li>
<li>对于特定检索词的有序检测结果<ul>
<li>系统可能返回任意数量的结果（=N）</li>
<li>考虑Top k返回的情形</li>
<li>则每个k的取值对应一个R和P</li>
</ul>
</li>
<li>计算得到查准率-查全率曲线</li>
</ul>
<h4 id="P-R的优缺点"><a href="#P-R的优缺点" class="headerlink" title="P-R的优缺点"></a>P-R的优缺点</h4><ul>
<li>优点：<ul>
<li>简单直观</li>
<li>既考虑了检索结果的覆盖度，又考虑了检索结果的排序情况</li>
</ul>
</li>
<li>缺点:<ul>
<li>单个查询的P-R曲线虽然直观，但是难以明确表示两个查询的检索结果的优劣</li>
</ul>
</li>
</ul>
<h4 id="基于P-R曲线的单一指标"><a href="#基于P-R曲线的单一指标" class="headerlink" title="基于P-R曲线的单一指标"></a>基于P-R曲线的单一指标</h4><ul>
<li>固定检索等级的查准率<ul>
<li>Precision@k：前k个结果的查准率</li>
<li>对大多数的web搜索适合，因为用户看重在前几页中有多少好结果</li>
<li>平均的方式不好，通常所用指标中最不稳定的</li>
</ul>
</li>
<li>11点平均正确率<ul>
<li>对每个信息需求，插值的<strong>正确率</strong>定义在0,0.1,0.2,…,0.9,1共11个召回率水平上</li>
<li>对每个召回率水平，对测试集中<strong>多个查询</strong>在该点的插值正确率<strong>求算术平均</strong></li>
</ul>
</li>
</ul>
<h4 id="更多的评价准则：AP"><a href="#更多的评价准则：AP" class="headerlink" title="更多的评价准则：AP"></a>更多的评价准则：AP</h4><ul>
<li><p>平均查准率(Average Precision,AP)：对不同召回率点上的正确率进行平均</p>
<ul>
<li><p><strong>未插值AP</strong>：某个查询Q共有6个相关结果，某系统排序反回了5篇相关文档，其位置分别为 第1，第2，第5，第10，第20位。</p>
<ul>
<li>$AP = (\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20}+0)/6$，等价于6点平均</li>
</ul>
</li>
<li><p><strong>插值的AP</strong>：在召回率分别为0, 0.1, 0.2, … ,1.0的十一个点上的正确率求平均，等价于11点平均</p>
<ul>
<li><p><strong>只对返回的相关文档</strong>进行计算的AP</p>
<p>$AP =(\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20})/5$，倾向返回那些快速返回结果的系统，<strong>没有考虑召回率</strong>，等价于5点平均</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="不考虑召回率"><a href="#不考虑召回率" class="headerlink" title="不考虑召回率"></a>不考虑召回率</h4><ul>
<li>Precision@N：在第N个位置上的正确率<ul>
<li>对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页结果。因此P@10、P@20对大规模搜索引擎来说是很好的指标</li>
</ul>
</li>
</ul>
<h4 id="宏平均vs微平均"><a href="#宏平均vs微平均" class="headerlink" title="宏平均vs微平均"></a>宏平均vs微平均</h4><ul>
<li>平均的求法：<ul>
<li>宏平均（Macro Average）：对<strong>每个查询</strong>求出某个指标，然后对这些指标进行算术平均</li>
<li>微平均（Micro Average）：将所有查询视为<strong>一个查询</strong>，将各种情况的文档总数求和，然后进行指标运算。（一个系统的所有查询）<ul>
<li>Eg： $ Micro Precision = \frac{对所有检验出的相关文档总数} {对所有查询检出的文档总数}$</li>
<li>宏平均对所有<strong>查询一视同仁</strong>，微平均受返回相关文档数目比较大的查询影响（宏平均保护弱者）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="平均查准率均值-Mean-Average-Precision-MAP"><a href="#平均查准率均值-Mean-Average-Precision-MAP" class="headerlink" title="平均查准率均值 Mean Average Precision(MAP)"></a>平均查准率均值 Mean Average Precision(MAP)</h4><ul>
<li>每个<strong><u><em>相关文档位置上</em></u></strong>查准率的平均值，被称为<strong>平均查准率</strong>（AP）</li>
<li>对所有查询求宏平均，就得到平均查准率均值（MAP）</li>
<li>$Map(Q)= \frac{1}{|Q|}\sum_{j=1}^{|Q|}\frac{1}{m<em>j}\sum</em>{k=1}^{m<em>j}Precision(R</em>{jk})$</li>
<li>Q为信息需求，$q_j \in Q$所对应的所有相关文档集合为${d_1,d<em>2,…,d</em>{mj}}$ ，$R_{ij}$是查询$q<em>j$的返回结果，该结果中包含而不含有$d</em>{k+1}$及以后的相关文档</li>
</ul>
<h4 id="面向用户的评价指标"><a href="#面向用户的评价指标" class="headerlink" title="面向用户的评价指标"></a>面向用户的评价指标</h4><ul>
<li>假定用户<strong>已知的相关文档集合为U</strong>，检索结果和U的交集为$R_u$，则<strong>覆盖率</strong><ul>
<li>$C=\frac{R_u}{U}$，<strong>检索系统找到的用户已知的相关文档比例</strong></li>
</ul>
</li>
<li>假定检索结果中返回一些用户<strong>以前未知的相关文档$R_k$</strong>，则可以定义<strong>新颖率</strong><ul>
<li>$N=\frac{|R_k|}{|R_u|+|R_k|}$，表示系统返回的新相关文档的比例</li>
</ul>
</li>
</ul>
<h4 id="GMAP"><a href="#GMAP" class="headerlink" title="GMAP"></a>GMAP</h4><ul>
<li>AP的集合平均值（更能体现细微差别）</li>
</ul>
<h4 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h4><ul>
<li>每个文段不仅仅只有相关和不相关，而是有相关级别<ul>
<li>相关度级别越高的结果越多越好</li>
<li>相关度级别越高的结果越靠前越好</li>
</ul>
</li>
</ul>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><ul>
<li>标题通常是从文档的元数据中自动抽取出来的<ul>
<li>用户根据描述信息来判断这个文档是否相关</li>
</ul>
</li>
<li>两种基本类型<ul>
<li>静态：不论输入什么查询，文档的静态摘要都是不变的</li>
<li>动态：动态摘要<strong>依赖于查询</strong>，试图解释当前文档返回的原因</li>
</ul>
</li>
</ul>
<h4 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>信息检索的评价方法<ul>
<li>不考虑序的检索评价指标：P、R、F</li>
<li>考虑序的评价指标：P/R曲线、MAP、NDCG</li>
</ul>
</li>
<li>检索结果的摘要</li>
</ul>
<h2 id="相关反馈及查询扩展"><a href="#相关反馈及查询扩展" class="headerlink" title="相关反馈及查询扩展"></a>相关反馈及查询扩展</h2><ul>
<li>交互式相关反馈：在初始检索结果基础上，通过用户指定哪些文档相关或不相关，然后改进检索的结果。Rocchio相关反馈</li>
<li>查询扩展（Query expansion）：通过在查询中加入同义或者相关的词项来提供检索结果。人工编辑的同义词辞典、自动构造的同义词词典、查询日志</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h4 id="搜索中提高召回率的方法"><a href="#搜索中提高召回率的方法" class="headerlink" title="搜索中提高召回率的方法"></a>搜索中提高召回率的方法</h4><ul>
<li>提高召回率的方法—— 相关反馈及查询扩展</li>
<li>返回不包含查询词项的相关文档</li>
</ul>
<h4 id="关于召回率Recall"><a href="#关于召回率Recall" class="headerlink" title="关于召回率Recall"></a>关于召回率Recall</h4><ul>
<li>放松召回率的定义，给用户返回更多的相关文档</li>
</ul>
<h4 id="提高召回率的方法"><a href="#提高召回率的方法" class="headerlink" title="提高召回率的方法"></a>提高召回率的方法</h4><ul>
<li>局部（local）方法：对用户查询进行局部的实时分析<ul>
<li>主要局部方法：<strong>相关反馈</strong>（relevance feedback）</li>
</ul>
</li>
<li>全局（global）方法：进行一次性的全局分析产生同/近义词词典(thesaurus)<ul>
<li>利用该词典进行查询扩展</li>
</ul>
</li>
</ul>
<h3 id="相关反馈基础"><a href="#相关反馈基础" class="headerlink" title="相关反馈基础"></a>相关反馈基础</h3><h4 id="相关反馈的基本思想"><a href="#相关反馈的基本思想" class="headerlink" title="相关反馈的基本思想"></a>相关反馈的基本思想</h4><ul>
<li>用户提交一个（简短的）查询</li>
<li>搜索引擎返回一系列文档</li>
<li>用户将部分返回文档标记为<strong>相关</strong>的，将部分文档标记为<strong>不相关</strong>的</li>
<li>搜索引擎根据标记结果计算得到信息需求的一个<strong>新查询表示</strong>。（希望好于初始查询）</li>
<li>对新查询进行处理，返回新结果。</li>
<li>新结果渴望有更高的<strong>召回率</strong></li>
</ul>
<h4 id="相关反馈分类"><a href="#相关反馈分类" class="headerlink" title="相关反馈分类"></a>相关反馈分类</h4><ul>
<li>用户相关反馈或显示相关反馈（User Feedback or Explicit Feedback）：用户显示参加交互过程</li>
<li>隐式相关反馈（Implicit Feedback）：系统跟踪用户的行为来推测返回文档的相关性，从而进行反馈</li>
<li>伪相关反馈或盲目相关反馈：（Pseduo Feedback or Blind Feedback）：没有用户参与，系统直接假设返回文档的前K篇相关的，然后进行反馈。</li>
</ul>
<h3 id="相关反馈详细介绍"><a href="#相关反馈详细介绍" class="headerlink" title="相关反馈详细介绍"></a>相关反馈详细介绍</h3><h4 id="相关反馈中的核心概念：质心"><a href="#相关反馈中的核心概念：质心" class="headerlink" title="相关反馈中的核心概念：质心"></a>相关反馈中的核心概念：质心</h4><ul>
<li>质心是一系列点的中心</li>
<li>前面将文档表示成高维空间中的点</li>
<li>计算文档质心的公式：</li>
</ul>
<h4 id="相关反馈基本理论"><a href="#相关反馈基本理论" class="headerlink" title="相关反馈基本理论"></a>相关反馈基本理论</h4><ul>
<li>基本理论：假定要找一个最有查询向量q，它与相关文档之间的相似度最大且同时又和不相关文档之间的相似度最小。</li>
<li><strong><em>q~opt~</em></strong>是将相关文档与不相关文档区分开的向量</li>
<li>当sim()函数采用余弦相似度计算时，能够将相关文档与不相关文档区分开的最有查询向量为：</li>
<li>最优查询向量等于<strong>相关文档的质心向量和不相关文档的质心向量的差</strong></li>
</ul>
<h4 id="Rocchio算法"><a href="#Rocchio算法" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>假定有一个用户查询，并知道部分相关文档和不相关文档的信息，最优查询向量为</li>
<li>q-</li>
<li>修改后的新查询从q~0~开始，向相关文档质心靠近，同时与不相关文档质心远离。</li>
<li>将<strong>相关文档</strong>的质心移动一个量，该量为相关文档质心和不相关文档质心的差异量</li>
<li>修改后的新查询，向着相关文档的质心向量靠近了一段距离，与不相关文档的质心向量远离了一段距离。</li>
</ul>
<h4 id="相关反馈策略的评价"><a href="#相关反馈策略的评价" class="headerlink" title="相关反馈策略的评价"></a>相关反馈策略的评价</h4><ul>
<li>使用初始查询q~0~ ，计算”查准率-查全率“曲线</li>
<li>使用相关反馈后修改查询q~m~，然后计算”查准率-查全率“曲线<ul>
<li>方案1：在<strong>整个文档集合</strong>上评价<ul>
<li>有显著的改善，但是有作弊嫌疑部分原因是会把已知的相关文档排在很前</li>
<li>需要用用户没有看到的文档集合来评价</li>
</ul>
</li>
<li>方案2：使用<strong>剩余的文档</strong>集合来评价（总的文档集合减去评价过的相关性文档）<ul>
<li>评价结果往往<strong>比初始查询的结果差</strong>，但是这种方法更现实</li>
<li>可以用来有效比较不同相关反馈方法之间的相对效果</li>
</ul>
</li>
<li>方案3：使用<strong>两个文档</strong>集合<ul>
<li>在第一个文档集合上使用初始查询q~0~，并进行相关反馈</li>
<li>在第二个文档集合上使用初始查询q~0~和修改过的查询q~m~进行评价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="评价的误区"><a href="#评价的误区" class="headerlink" title="评价的误区"></a>评价的误区</h4><ul>
<li>评价不同相关反馈的效用的时候，必须考虑消耗时间的要素。</li>
<li>代替相关反馈的方法：用户修改并重新提交查询</li>
<li>相对于判断文档的相关性，用户可能更愿意修改并重新提交查询</li>
<li>没有证据能表明相关反馈占用了用户的时间就能给用户带来最大的效用。</li>
</ul>
<h4 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h4><ul>
<li>提高召回率</li>
<li>查询重构的全局方法。在全局查询扩展中，查询基于一些<strong>全局的资源</strong>进行修改。</li>
<li>主要使用 同义词或近义词词典（人工构建和自动构建）</li>
</ul>
<h2 id="概率检索模型"><a href="#概率检索模型" class="headerlink" title="概率检索模型"></a>概率检索模型</h2><h3 id="向量空间模型回顾"><a href="#向量空间模型回顾" class="headerlink" title="向量空间模型回顾"></a>向量空间模型回顾</h3><h4 id="向量空间模型-1"><a href="#向量空间模型-1" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>文档表示成向量</li>
<li>查询也表示成向量</li>
<li>计算两个向量之间的相似度：余弦相似度、内积相似度</li>
<li>向量表示中的词项权重计算方法主要是tf-idf公式，实际考虑<strong>tf、idf及文档长度</strong>3个因素</li>
</ul>
<h4 id="向量空间模型优缺点"><a href="#向量空间模型优缺点" class="headerlink" title="向量空间模型优缺点"></a>向量空间模型优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>简洁直观，可以应用到很多其他领域(文本分类、生物信息学)</li>
<li>支持部分匹配和近似匹配，结果可以排序</li>
<li>检索效果不错</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>理论上不够：基于直觉的经验性公式</li>
<li>索引项之间的独立性假设与实际不符：实际上，term的出现之间是有关系的，不是完全独立。</li>
</ul>
<h3 id="基本概率统计知识"><a href="#基本概率统计知识" class="headerlink" title="基本概率统计知识"></a>基本概率统计知识</h3><h4 id="随机试验和随机事件"><a href="#随机试验和随机事件" class="headerlink" title="随机试验和随机事件"></a>随机试验和随机事件</h4><h4 id="概率和条件概率"><a href="#概率和条件概率" class="headerlink" title="概率和条件概率"></a>概率和条件概率</h4><h4 id="乘法公式、全概率公式和贝叶斯公式"><a href="#乘法公式、全概率公式和贝叶斯公式" class="headerlink" title="乘法公式、全概率公式和贝叶斯公式"></a>乘法公式、全概率公式和贝叶斯公式</h4><h4 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h4><h4 id="概率检索模型-1"><a href="#概率检索模型-1" class="headerlink" title="概率检索模型"></a>概率检索模型</h4><ul>
<li>概率检索模型：通过<strong>概率的方法</strong>将查询和文档联系起来<ul>
<li>定义3个随机变量R、Q、D：<strong>相关度R</strong>={0，1}，<strong>查询Q</strong>={q1,q2,…}，<strong>文档D</strong>={d1,d2,…}</li>
<li>通过计算<strong>条件概率$P(R=1|Q=q,D=d)$</strong>来度量文档和查询的相关度</li>
</ul>
</li>
</ul>
<h4 id="概率排序原理PRP"><a href="#概率排序原理PRP" class="headerlink" title="概率排序原理PRP"></a>概率排序原理PRP</h4><ul>
<li>利用概率模型来估计每篇文档和需求的<strong><em>相关概率P(R=1|d,q)</em></strong>，然后对结果进行排序</li>
<li>最简单的PRP情况<ul>
<li>检索没有任何迭代因子，或者说不会对不同行为或错误采用不同的权重因子。</li>
<li>在返回一篇不想管文档或者返回一篇相关文档不成功的情况下，将失去1分</li>
<li>而检索的目标是对于用户给定的k值，返回可能性最高的文档前k篇作为结果输出。即RPR希望可以按照$P(R=1|d,q)$值的<strong>降序</strong>来排列所有文档</li>
</ul>
</li>
<li>公式的理解</li>
</ul>
<h4 id="基于检索代价的概率排序原理"><a href="#基于检索代价的概率排序原理" class="headerlink" title="基于检索代价的概率排序原理"></a>基于检索代价的概率排序原理</h4><ul>
<li>C~1~表示一篇<strong>相关文档未返回</strong>所发生的代价</li>
<li>C~0~表示<strong>返回一篇不相关文档</strong>所发生的代价</li>
<li>PRP认为，如果对于一篇特定的文档d及其所有其他未返回的文档d’都满足：</li>
<li>$C_0\cdot P(R=1|d)-C_1\cdot P(R=0|d) \le C_0\cdot P(R=1|d’)-C_1\cdot P(R=0|d’)$<ul>
<li>$C_0\cdot P(R=1|d)$：当d不相关时却返回的代价（判为相关）</li>
<li>$C_1\cdot P(R=0|d)$：当d相关却没有返回的代价</li>
<li>两者相减表示返回文档d的<strong>代价函数</strong>，即此时前者越低越好，后者越高越好</li>
</ul>
</li>
<li>那么d就应该是下一篇被返回的文档</li>
</ul>
<h4 id="二值独立概率模型BIM"><a href="#二值独立概率模型BIM" class="headerlink" title="二值独立概率模型BIM"></a>二值独立概率模型BIM</h4><ul>
<li>为了对概率函数P(R|q,d)进行估计，引入了一些简单假设。<ul>
<li>”二值“等价于布尔值：文档和查询都表示为<strong><u>词项出现与否的布尔向量</u></strong></li>
<li>类似，查询q表示成词项出现向量q</li>
<li>”独立性“指的式词项在文档中的出现是相互独立的，BIM不识别词项之间的关联。</li>
</ul>
</li>
</ul>
<h4 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h4><ul>
<li>在减少出现事件的概率估计值的同时提高未出现事件的概率估计值的方法</li>
</ul>
<h4 id="BIM模型的优缺点"><a href="#BIM模型的优缺点" class="headerlink" title="BIM模型的优缺点"></a>BIM模型的优缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>BIM模型建立在数学基础上，理论性较强</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>需要估计参数</li>
<li>原始BIM没有考虑TF、文档长度因素</li>
<li>BIM中同样存在词项独立性假设</li>
</ul>
<h4 id="理论上的概率估计方法"><a href="#理论上的概率估计方法" class="headerlink" title="理论上的概率估计方法"></a>理论上的概率估计方法</h4><ul>
<li>P~t~词项出现在一篇相关文档中的概率</li>
<li>$p_t = P(x_t=1|R=1,q) = s/S$</li>
<li>u~t~词项出现在一片不相关文档中的概率</li>
<li>$u_t=P(x_t=1|R=0, q)= (df_t-s)/(N-S)$</li>
</ul>
<h2 id="基于语言建模的检索模型"><a href="#基于语言建模的检索模型" class="headerlink" title="基于语言建模的检索模型"></a>基于语言建模的检索模型</h2><ul>
<li>传统概率模型<ul>
<li>需要对文档d与查询q的相关概率$P(R=1|q,d)$进行显示建模</li>
</ul>
</li>
<li>概率语言模型<ul>
<li>首先对每篇文档d建模得到文档的<strong>概率语言模型 $M_d$</strong></li>
<li>然后按照<strong>模型生成查询q</strong>的概率$P(q|M_d)$的高低来对文档进行排序</li>
</ul>
</li>
</ul>
<h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><h4 id="最简单的语言生成器模型"><a href="#最简单的语言生成器模型" class="headerlink" title="最简单的语言生成器模型"></a>最简单的语言生成器模型</h4><ul>
<li>一个简单的又穷自动机及其生成语言中的一些字符串<ul>
<li>$\rightarrow$指向的是自动机的初始状态</li>
<li>双圈节点对应的是终止状态</li>
</ul>
</li>
<li>如果每一个节点都有一个生成不同词项的概率分布，便得到一个语言模型，或概率语言模型，或统计语言模型<ul>
<li>语言模型的概念本质上是基于概率的</li>
</ul>
</li>
</ul>
<h4 id="有穷自动机-rightarrow-语言模型"><a href="#有穷自动机-rightarrow-语言模型" class="headerlink" title="有穷自动机$\rightarrow$语言模型"></a>有穷自动机$\rightarrow$语言模型</h4><ul>
<li>一个语言模型（LM）是从某词汇表上抽取的<strong>字符串概率的一个映射函数</strong>。对字母表$\sum$上的语言模型M有：$\sum_{s\in \sum^*}P(s)=1$</li>
<li>最简单的语言模型等价于一个仅仅包含一个节点的概率有穷自动机，只有一个生成不同词项的概率分布，因此有$\sum_{t\in V}P(t)=1$</li>
<li>假定停止概率是固定的，因此不会影响文档的排序。因此可以不考虑停止概率，但形式上得到的结果将不再是概率，而只是概率的部分项</li>
</ul>
<h4 id="语言模型的比较"><a href="#语言模型的比较" class="headerlink" title="语言模型的比较"></a>语言模型的比较</h4><ul>
<li>比较两个模型，可计算似然比，即将其中一个模型的数据生成概率除以另外一个模型数据的生成概率。</li>
</ul>
<h3 id="语言模型的种类"><a href="#语言模型的种类" class="headerlink" title="语言模型的种类"></a>语言模型的种类</h3><h4 id="对于词项序列如何求解其生成的概率值"><a href="#对于词项序列如何求解其生成的概率值" class="headerlink" title="对于词项序列如何求解其生成的概率值"></a>对于词项序列如何求解其生成的概率值</h4><ul>
<li>根据链式规则将一系列事件的概率分解成多个连续事件概率之积，每个概率是每个事件基于其历史事件的条件概率。</li>
<li>$P(t_1t_2t_3t_4)=P(t_1)P(t_2|t_1)P(t3|t_1t_2)P(t_4|t_1t_2t_3)$</li>
</ul>
<h4 id="语言模型的种类n-gram"><a href="#语言模型的种类n-gram" class="headerlink" title="语言模型的种类n-gram"></a>语言模型的种类n-gram</h4><ul>
<li><p>一元语言模型（Unigram LM）：上下文语言无关模型，是最简单的语言模型，去掉所有条件概率中的条件来独立地估计每个词项的概率</p>
<ul>
<li>$P_{uni}(t_1t_2t_3t_4) = P(t_1)P(t_2)P(t_3)P(t_4)$</li>
<li>词袋模型Bag of words</li>
</ul>
</li>
<li><p>二元语言模型（Bigram LM）：即计算条件概率时只考虑前一个词项的出现情况</p>
<ul>
<li>$P_{bi}(t_1t_2t_3t_4) = P(t_1)P(t_2|t_1)P(t_3|t_2)P(t_4|t_3)$</li>
</ul>
</li>
<li><p>三元语言模型（Trigram LM）</p>
</li>
</ul>
<h4 id="词的多项式分布"><a href="#词的多项式分布" class="headerlink" title="词的多项式分布"></a>词的多项式分布</h4><ul>
<li>词的多项式分布</li>
</ul>
<h3 id="语言模型应用到IR"><a href="#语言模型应用到IR" class="headerlink" title="语言模型应用到IR"></a>语言模型应用到IR</h3><h4 id="总体分布-amp-抽样"><a href="#总体分布-amp-抽样" class="headerlink" title="总体分布&amp;抽样"></a>总体分布&amp;抽样</h4><ul>
<li>文档模型实际是某种<strong>总体分布</strong></li>
<li>文档和查询都是该总体分布下的一个<strong>抽样样本示例</strong></li>
<li>根据文档，估计文档的模型，即求出该总体分布，然后计算该总体分布下抽样出查询的概率</li>
<li>文档 $\rightarrow$ 总体分布 $\rightarrow$ 查询</li>
</ul>
<h4 id="查询似然模型"><a href="#查询似然模型" class="headerlink" title="查询似然模型"></a>查询似然模型</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>将文档按照其余查询相关的似然$P(d|q)$排序<ul>
<li>$P(d|q)=P(d|q)\frac{P(d)}{P(q)}$</li>
</ul>
</li>
<li><p>最后会按照$P(d|q)$进行排序，它是在<strong>文档d对应的语言模型$M_d$下生成q的概率</strong></p>
</li>
<li><p>IR中的语言建模方法实际上是在<strong>对查询的过程</strong>进行建模</p>
<ul>
<li>首先每篇文档d对应一个文档模型$M_d$</li>
<li>然后计算查询被视为每个文档模型的随机抽样样本的概率</li>
<li>最后根据这些概率对文档排序<ul>
<li>$P(q|M_d) = K<em>q \prod</em>{t\in V}P(t|M<em>d)^{tf</em>{t,d}}$</li>
<li>$K_q$是查询q的多项式系数，对于某个特定查询，是一个常数可以忽略。</li>
</ul>
</li>
</ul>
</li>
<li>模型的直观意义是，用户脑子里有一篇原型文档，然后按照该文档中的词语用法来生成查询。</li>
</ul>
<h4 id="查询生成的概率估计"><a href="#查询生成的概率估计" class="headerlink" title="查询生成的概率估计"></a>查询生成的概率估计</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>采用最大似然估计：使得观察样本出现概率最大的估计<ul>
<li>$P(q|M<em>d)=\prod</em>{t\in q}P_{mle}(t|M<em>d)=\frac{tf</em>{t,d}}{L_d}$</li>
<li>$L_d$是d中的词条数目</li>
</ul>
</li>
</ul>
<h4 id="线性插值LM示例"><a href="#线性插值LM示例" class="headerlink" title="线性插值LM示例"></a>线性插值LM示例</h4><h4 id="平滑的方法：线性插值LM"><a href="#平滑的方法：线性插值LM" class="headerlink" title="平滑的方法：线性插值LM"></a>平滑的方法：线性插值LM</h4><ul>
<li><p>需要对文档LM的概率进行平滑（Smoothing），即对出现事件的概率结果进行折扣，并对未出现的词的概率赋予一定的值。</p>
</li>
<li><p>将基于<strong>文档的多项式</strong>分布和基于全部<strong>文档集</strong>估计出的多项式分布相混合</p>
</li>
<li>$P(t|d)= \lambda P_{mle}(t|M<em>d)+(1-\lambda)P</em>{mle}(t|M_c)$<ul>
<li>$\lambda \in (0,1)$ , $M_c$是基于全部文档集构造的LM</li>
</ul>
</li>
</ul>
<h4 id="扩展的LM方法"><a href="#扩展的LM方法" class="headerlink" title="扩展的LM方法"></a>扩展的LM方法</h4><ul>
<li>a查询似然类：文档建模，计算查询的似然<ul>
<li>基本QLM模型、翻译模型</li>
</ul>
</li>
<li>b文档似然类：查询建模，计算文档的似然<ul>
<li>BIM模型、相关性模型</li>
</ul>
</li>
<li>c模型比较类：文档建模，查询建模，kl距离模型</li>
</ul>
<h2 id="文本分类及朴素贝叶斯分类器"><a href="#文本分类及朴素贝叶斯分类器" class="headerlink" title="文本分类及朴素贝叶斯分类器"></a>文本分类及朴素贝叶斯分类器</h2><h3 id="本讲要点"><a href="#本讲要点" class="headerlink" title="本讲要点"></a>本讲要点</h3><ul>
<li>什么是文本分类</li>
<li>什么是朴素贝叶斯分类器</li>
<li>朴素贝叶斯分类器的生成模型</li>
<li>朴素贝叶斯分类器的性质<ul>
<li>条件独立假设&amp;位置独立性假设</li>
</ul>
</li>
<li>特征选择：互信息、x2统计量、词项频率</li>
<li>文本分类评价：宏平均和微平均</li>
</ul>
<h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><ul>
<li>给定分类体系，将一篇文本分到其中一个或者多个类别中的过程。</li>
</ul>
<ul>
<li>文本分类中，给定文档$d \in X$ 和一个固定的类别集合 $C={C_1,C_2,…,C_j}$ , 其中X表式文档空间，类别也通常称为类或类标签<ul>
<li>按类别书目：binary vs multi-class</li>
<li>按每篇文档赋予的标签书目： sing label vs multi label</li>
</ul>
</li>
</ul>
<h4 id="分类方法1：-手工方法"><a href="#分类方法1：-手工方法" class="headerlink" title="分类方法1： 手工方法"></a>分类方法1： 手工方法</h4><ul>
<li>使用人工分类方法来分类，如果专家来分类精度会非常高</li>
<li>如果问题规模和分类团队都很小时，能否保持分类结果的一致性</li>
</ul>
<h4 id="分类方法2：规则方法"><a href="#分类方法2：规则方法" class="headerlink" title="分类方法2：规则方法"></a>分类方法2：规则方法</h4><ul>
<li>繁琐，开销大</li>
</ul>
<h4 id="分类方法3：机器学习方法"><a href="#分类方法3：机器学习方法" class="headerlink" title="分类方法3：机器学习方法"></a>分类方法3：机器学习方法</h4><ul>
<li>文本分类被定义为一个学习问题，包括：<ul>
<li>通过有监督的学习，得到分类函数$\gamma$，然后将其应用于对新文档的分类</li>
</ul>
</li>
<li>一系列的分类方法：朴素贝叶斯、Rocchio、KNN、SVM</li>
<li>当学习方法基于统计时，此方法也称为统计文本分类：<ul>
<li>在统计文本分类中，对每个类别需要一些好的文档样例（训练文档）</li>
<li>需要人来标注训练文档，所以对人工分类的需求依然存在</li>
<li>标注（labeling）指对每篇文档赋予类别标签的过程</li>
</ul>
</li>
</ul>
<h4 id="基于学习的文本分类"><a href="#基于学习的文本分类" class="headerlink" title="基于学习的文本分类"></a>基于学习的文本分类</h4><ul>
<li>文档空间X<ul>
<li>文档都在该空间下表示—— 通常都是某种高维空间</li>
</ul>
</li>
<li>固定的类别集合$C={C_1,C_2,…,C_j}$<ul>
<li>类别往往根据应用的需求来人为定义</li>
</ul>
</li>
<li>训练集D，文档d用c来标记，$<d,c> \in X \times C$<ul>
<li>利用学习算法，可以学习一个分类器$\gamma$，它可以将文档映射成类别： $\gamma：X\rightarrow C$</li>
</ul>
</d,c></li>
<li>文档分类的实现<ul>
<li>对于文档空间中文档，$d \in X $,可确定$γ(d) \in C $即确定d最可能属于的类别$c_i = γ(d),c \in C$</li>
</ul>
</li>
</ul>
<h4 id="无监督-有监督的学习"><a href="#无监督-有监督的学习" class="headerlink" title="无监督/有监督的学习"></a>无监督/有监督的学习</h4><ul>
<li>supervised learning 监督学习<ul>
<li>利用一组<strong><u>已知类别的样本</u></strong>调整分类器的参数，使其达到所求性能的过程，也称为监督训练或有教师学习</li>
</ul>
</li>
<li>无监督学习<ul>
<li>若所给的学习样本<strong><em>不带有类别信息</em></strong>，就是无监督学习</li>
</ul>
</li>
</ul>
<h4 id="搜索引擎中的文本分类应用"><a href="#搜索引擎中的文本分类应用" class="headerlink" title="搜索引擎中的文本分类应用"></a>搜索引擎中的文本分类应用</h4><ul>
<li>语言识别</li>
<li>垃圾网页识别</li>
<li>是否包含淫秽内容</li>
<li>领域搜索或垂直搜索—— 搜索对象限制在某个垂直领域</li>
<li>静态查询</li>
<li>情感识别</li>
</ul>
<h4 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h4><ul>
<li>是一个概率分类器</li>
<li>文档d属于类别c的概率计算</li>
<li>$P(c|d)=\frac{P(c)P(d|c)}{P(d)} ∞ P(c)P(d|c)∞P(c)\prod_{1\le K \le n_d}{P(t_k|c)}$</li>
<li>t~k~是d中的词条，n~d~是文档的长度（词条个数）</li>
<li>P(t~k~|c)是此项t~k~出现在类别c中文档的概率，或类别c生成词项t~k~的概率，或是度量的是当c是正确类别时t~k~的贡献</li>
<li>P(c)是类别c的先验概率</li>
<li>如果文档的词项无法提供属于哪个类别的信息，那么直接选择P(c)最高的那个类别</li>
</ul>
<h3 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h3><h4 id="两种模型文本生成过程"><a href="#两种模型文本生成过程" class="headerlink" title="两种模型文本生成过程"></a>两种模型文本生成过程</h4><ul>
<li>给定类别时文档生成的条件概率计算有所不同<ul>
<li>多项式模型$P(d|c)=P(<t_1, …="" ,="" t_k,="" …,="" t_{nd}="">|c)$</t_1,></li>
<li>贝努利模型$P(d|c)=P(<e_1, …="" ,="" e_k,="" …,="" e_m="">|c)$</e_1,></li>
<li>其中 多项式模型是d中出现的词项序列（去掉词）</li>
<li>贝努利模型是一个M维的布尔向量，表示每个词项在文档d中存在与否。</li>
</ul>
</li>
<li>两种不同的文档表示方法<ul>
<li>多项式模型是文档空间X是所有词项序列的集合</li>
<li>贝努利模型是文档空间X是${0,1}^M$</li>
</ul>
</li>
</ul>
<h4 id="具有最大后验概率的类别"><a href="#具有最大后验概率的类别" class="headerlink" title="具有最大后验概率的类别"></a>具有最大后验概率的类别</h4><ul>
<li>朴素贝叶斯分类的目标是寻找“最佳”类别</li>
</ul>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ul>
<li>文本分类中，通常要将文本表示在一个<strong>高维空间</strong>下，<strong>每一维对应一个词项</strong>。特征选择是从训练集合出现的词项中选出一部分子集的过程。在文本分类过程也仅仅使用这个子集作为特征</li>
<li>特征选择有两个主要目的：<ol>
<li>通过减少有效的词汇空间来提高分类器训练和应用的效率。这对除NB之外的其他训练开销较大的分类器来说尤为重要。</li>
<li>特征选择能够去除噪音特征，从而提高分类的精度。</li>
</ol>
</li>
<li><strong>噪音特征</strong>：加入文本表示之后反而会增加新数据上的分类错误率的特征</li>
<li>由于训练集的偶然性导出的不正确的泛化结果称为<strong>过学习</strong></li>
</ul>
<h4 id="特征选择算法"><a href="#特征选择算法" class="headerlink" title="特征选择算法"></a>特征选择算法</h4><ul>
<li>给定类别c，对词汇表中的每个词项t，计算<strong>效用指标A(t,c)</strong>，然后从中选择k个具有最高值的词项作为最后的特征。</li>
</ul>
<h4 id="不同的特征选择方法"><a href="#不同的特征选择方法" class="headerlink" title="不同的特征选择方法"></a>不同的特征选择方法</h4><ul>
<li>特征选择方法主要基于其所使用特征效用指标来定义</li>
<li>特征效用指标<ul>
<li>频率法—— 选择高频词项</li>
<li>互信息—— 选择具有最高互信息的那些词项</li>
<li>卡方x^2^ </li>
</ul>
</li>
</ul>
<h3 id="分类评价"><a href="#分类评价" class="headerlink" title="分类评价"></a>分类评价</h3><ul>
<li>评价必须基于测试数据进行，而且该测试数据与训练数据完全独立。</li>
<li>很容易通过训练可以子训练集上达到很高的性能</li>
<li>常用指标：正确率、召回率、F~1~值、分类精确率等等</li>
<li>宏平均：在类别之间求平均值  微平均：将每篇文档在每个类别上的判定放入一个缓冲池，然后基于这个缓冲池计算效果指标。</li>
</ul>
<h4 id="宏平均"><a href="#宏平均" class="headerlink" title="宏平均"></a>宏平均</h4><ul>
<li>对类别集合C中的每个类都计算一个F~1~值</li>
<li>对C个结果求平均</li>
</ul>
<h4 id="微平均"><a href="#微平均" class="headerlink" title="微平均"></a>微平均</h4><ul>
<li>对类别集合C中的每个类都计算TP、FP和FN</li>
<li>将C中的这些数字累加</li>
<li>基于累加的TP、FP、FN计算P、R和F~1~</li>
</ul>
<h4 id="宏平均和微平均的适用范围"><a href="#宏平均和微平均的适用范围" class="headerlink" title="宏平均和微平均的适用范围"></a>宏平均和微平均的适用范围</h4><ul>
<li>宏平均和微平均的计算结果可能会相差很大。宏平均对每个类等同对待，而微平均则对每篇文档的判定结果等同对待</li>
<li>由于F1值忽略判断正确的负例，所以它的大小主要由判断正确的正例数目所决定，所以在微平均计算中大类起支配作用。</li>
</ul>
<h2 id="基于向量空间模型的文本分类"><a href="#基于向量空间模型的文本分类" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><ul>
<li>Rocchio方法<ul>
<li>基于质心或原型将整个向量空间划分成多个区域</li>
</ul>
</li>
<li>kNN方法<ul>
<li>将K个最邻近文档所属的主类别赋给测试文档</li>
</ul>
</li>
<li>线性分类器<ul>
<li>指基于特征的简单<strong>线性组合</strong>就可以对文档进行分类的分类器</li>
</ul>
</li>
</ul>
<h3 id="基于向量空间的分类方法"><a href="#基于向量空间的分类方法" class="headerlink" title="基于向量空间的分类方法"></a>基于向量空间的分类方法</h3><h4 id="向量空间表示"><a href="#向量空间表示" class="headerlink" title="向量空间表示"></a>向量空间表示</h4><ul>
<li>每个文档表示成一个<strong>向量</strong>，向量的每一维表示一个<strong>term</strong></li>
<li>向量可以归一化成单位长度</li>
<li>高维向量空间<ul>
<li>维度非常高</li>
<li>每个term就是一个坐标轴</li>
<li>文档表示为空间的向量</li>
</ul>
</li>
</ul>
<h4 id="向量空间模型-2"><a href="#向量空间模型-2" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>词项——文档矩阵：二值—&gt; 计数 —&gt; 权重矩阵（tf-idf）</li>
<li><p>相关性 = 向量距离 ： 欧式距离—&gt; 夹角 —&gt; 余弦相似度</p>
</li>
<li><p>利用向量空间模型进行文本分类的思路主要基于<strong>邻近假设</strong>：</p>
<ol>
<li>同一类的文档会构成一个邻近区域</li>
<li>不同类的邻近区域之间互不重叠</li>
</ol>
</li>
<li>如何找到<strong>分类面决策边界</strong>（decision boundary）</li>
</ul>
<h3 id="Rocchio方法"><a href="#Rocchio方法" class="headerlink" title="Rocchio方法"></a>Rocchio方法</h3><h4 id="Rocchio方法进行向量空间分类的思路"><a href="#Rocchio方法进行向量空间分类的思路" class="headerlink" title="Rocchio方法进行向量空间分类的思路"></a>Rocchio方法进行向量空间分类的思路</h4><ul>
<li>利用<strong>质心</strong>来定义分类边界</li>
<li>一个<strong>类别c的质心</strong>可以通过类中文档向量的平均向量或者质心想来来计算</li>
<li>计算公式：</li>
</ul>
<h4 id="Rocchio算法-1"><a href="#Rocchio算法-1" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>计算每个类的中心向量（所有文档向量的算术平均）</li>
<li>将每篇测试文档分到离它最近的那个中心向量</li>
</ul>
<h4 id="Rocchio算法中的决策边界"><a href="#Rocchio算法中的决策边界" class="headerlink" title="Rocchio算法中的决策边界"></a>Rocchio算法中的决策边界</h4><ul>
<li>利用质心来定义分类边界</li>
<li>两类的边界由那些<strong>到两个类质心等距的点集组成</strong>（超平面）</li>
</ul>
<h4 id="Rocchio分类方法的缺陷"><a href="#Rocchio分类方法的缺陷" class="headerlink" title="Rocchio分类方法的缺陷"></a>Rocchio分类方法的缺陷</h4><ul>
<li>为了遵循邻近性的要求，Rocchio 分类中的每个类别一定要近似球形，并且它们之间具有相似球半径。</li>
</ul>
<h3 id="KNN邻近方法"><a href="#KNN邻近方法" class="headerlink" title="KNN邻近方法"></a>KNN邻近方法</h3><h4 id="kNN（k邻近）方法"><a href="#kNN（k邻近）方法" class="headerlink" title="kNN（k邻近）方法"></a>kNN（k邻近）方法</h4><ul>
<li>kNN = k nearnest neighbors， k邻接</li>
<li>k = 1情况下的kNN：将每篇测试文档分给训练集中离它最近的那篇文档所属的类别。</li>
<li>1NN不很鲁棒 —— 一篇文档可能会分错类或者这篇文档本身就返常</li>
<li>k&gt;1情况下的kNN：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>kNN的基本依据<ul>
<li>根据邻近假设，一篇测试文档d将和其邻域中的训练文档应该具有相同的类别。</li>
</ul>
</li>
</ul>
<h4 id="1NN分类器"><a href="#1NN分类器" class="headerlink" title="1NN分类器"></a>1NN分类器</h4><ul>
<li>1NN分类器的判别边界是<strong>Voronoi剖分</strong>形成的多个线段的连接。Voronoi剖分会将整个平面分成|D|个凸多边形，每个多边形仅包含其对应的文档，而每个凸多边形是在二维空间种通过直线围成的凸区域。</li>
</ul>
<h4 id="小结：KNN方法"><a href="#小结：KNN方法" class="headerlink" title="小结：KNN方法"></a>小结：KNN方法</h4><ul>
<li>思路：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>KNN的基本依据：根据邻近假设，一篇测试文档d将和其领域中的训练文档应该具有相同的类别<ul>
<li>当训练集非常大的时候，KNN分类精度很高</li>
<li>当训练集非常小的时候，KNN效果很差</li>
</ul>
</li>
</ul>
<h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><ul>
<li>定义</li>
</ul>
<h2 id="基于向量空间模型的文本分类-1"><a href="#基于向量空间模型的文本分类-1" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><h3 id="二元线性SVM"><a href="#二元线性SVM" class="headerlink" title="二元线性SVM"></a>二元线性SVM</h3><ul>
<li>SVM是最大间隔分类器的一种，它是局域向量空间的机器学习方法，其目标是找到两个类别之间的一个决策边界，使之尽量远离训练集上的任意一点。</li>
<li>SVM定义的准则是<strong><u>寻找一个离数据点最远的决策面</u></strong>。从决策面到最近数据点的距离决定了<strong>分类器的间隔</strong></li>
</ul>
<h4 id="小结：SVM要点"><a href="#小结：SVM要点" class="headerlink" title="小结：SVM要点"></a>小结：SVM要点</h4><ul>
<li>线性SVM的结果分类器为：</li>
<li>SVM基本过程：<ul>
<li>基于给定训练数据集，通过二次优化过程寻找最佳的分类超平面</li>
<li>对于待分类的新数据点，利用分类函数计算该点到超平面的距离</li>
<li>距离的正负（分类函数的符号）决定了该数据点类别的归属</li>
<li>如果该点在分类器的间隔之内，分了器可以在原来的两个类之外，返回“类别未知”</li>
</ul>
</li>
<li>​</li>
</ul>
<h2 id="文本聚类"><a href="#文本聚类" class="headerlink" title="文本聚类"></a>文本聚类</h2><h3 id="聚类介绍"><a href="#聚类介绍" class="headerlink" title="聚类介绍"></a>聚类介绍</h3><h4 id="聚类的定义"><a href="#聚类的定义" class="headerlink" title="聚类的定义"></a>聚类的定义</h4><ul>
<li>文档聚类是将一系列文档按照相似性聚团成子集或者簇的过程</li>
<li>簇内文档之间应该彼此相似，相似度不大</li>
<li>聚类是一种最常见的无监督学习方法<ul>
<li>无监督学习意味着没有已标注好的数据集</li>
</ul>
</li>
</ul>
<h4 id="分类VS聚类"><a href="#分类VS聚类" class="headerlink" title="分类VS聚类"></a>分类VS聚类</h4><ul>
<li>分类：有监督的学习</li>
<li>聚类：无监督的学习</li>
<li>分类：类别事先人工定义好，并且是学习算法的输入的一部分</li>
<li>聚类：簇在没有人工输入的情况下从数据中推理而得<ul>
<li>但是很多因素会影响聚类的输出结果：簇的个数、相似度计算方法、文档的表示方式等。</li>
</ul>
</li>
</ul>
<h3 id="聚类在IR中的应用"><a href="#聚类在IR中的应用" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h3><h4 id="聚类假设"><a href="#聚类假设" class="headerlink" title="聚类假设"></a>聚类假设</h4><ul>
<li>在考虑文档和信息需求之间的相关性式，同一簇中的文档表现互相类似。</li>
<li>聚类在IR中的应用所有应用都直接或间接基于上述聚类假设</li>
</ul>
<h4 id="聚类在IR中的应用-1"><a href="#聚类在IR中的应用-1" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h4><table>
<thead>
<tr>
<th>应用</th>
<th>聚类对象</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>搜索结果聚类</td>
<td>搜索结果</td>
<td>提供面向用户的更有效的展示</td>
</tr>
<tr>
<td>“分散-集中”界面</td>
<td>文档集和文档子集</td>
<td>提供了另一种用户界面，即不需要人工输入关键词的搜索界面</td>
</tr>
<tr>
<td>文档聚类</td>
<td>文档集</td>
<td>提供了一种面向探索式浏览的有效性的信息展示法</td>
</tr>
<tr>
<td>基于语言建模的IR文档集</td>
<td>文档集</td>
<td>提高了正确率和/或召回率</td>
</tr>
<tr>
<td>基于聚类的检索</td>
<td>文档集</td>
<td>加快了搜索的速度</td>
</tr>
</tbody>
</table>
<h4 id="文档聚类用于提高召回率"><a href="#文档聚类用于提高召回率" class="headerlink" title="文档聚类用于提高召回率"></a>文档聚类用于提高召回率</h4><ul>
<li>实现将文档集中的文档进行聚类</li>
<li>当文档和查询匹配时，也返回包含d的簇所包含的其它文档</li>
<li>我们希望通过上述做法，在输入查询“car”时，也能包含“automobile”的文档</li>
<li>由于聚类算法会把包含“car”的文档和包含“automobile”的文档聚在一起</li>
</ul>
<h4 id="聚类的要求"><a href="#聚类的要求" class="headerlink" title="聚类的要求"></a>聚类的要求</h4><ul>
<li>一般目标： 将相关文档放到一个簇中，将不相关文档放到不同的簇中</li>
<li>簇的数目应该合适，以便于聚类的数据集吻合<ul>
<li>一开始，假设给定簇的数目为K</li>
<li>后面介绍K的半自动的方法</li>
</ul>
</li>
<li>其它目标：<ul>
<li>避免非常小和非常大的簇</li>
<li>定义的簇对用户来说很容易理解</li>
<li>其它……</li>
</ul>
</li>
</ul>
<h4 id="扁平聚类vs层次聚类"><a href="#扁平聚类vs层次聚类" class="headerlink" title="扁平聚类vs层次聚类"></a>扁平聚类vs层次聚类</h4><ul>
<li><p>扁平算法：</p>
<ul>
<li>通过一开始将全部或部分文档随机划分为不同的组</li>
<li>通过迭代不断修正</li>
<li>代表算法： K-均值聚类算法</li>
</ul>
</li>
<li><p>层次算法：</p>
<ul>
<li>构建具有层次结果的簇</li>
<li>自底向上（Bottom-up）的算法称为凝聚式算法</li>
<li>自顶向下的（Top-down）算法称为分裂式算法</li>
</ul>
</li>
</ul>
<h4 id="硬聚类vs软聚类"><a href="#硬聚类vs软聚类" class="headerlink" title="硬聚类vs软聚类"></a>硬聚类vs软聚类</h4><ul>
<li>硬聚类：每篇文档仅仅属于一个簇<ul>
<li>很普遍并且相对容易实现</li>
</ul>
</li>
<li>软聚类：一篇文档可以属于多个簇</li>
</ul>
<h4 id="扁平算法"><a href="#扁平算法" class="headerlink" title="扁平算法"></a>扁平算法</h4><ul>
<li>扁平算法将N篇文档划分成K个簇</li>
<li>给定一个文档集合及聚类结果簇的个数K</li>
<li><strong>寻找一个划分将这个文档集合分成K个簇，该结果满足最优划分规则</strong></li>
<li>全局优化：穷举所有的结果划分，从中选择最优的那个划分结果(无法处理)</li>
<li>高效的启发式方法：k-均值聚类算法</li>
</ul>
<h3 id="K-均值聚类算法"><a href="#K-均值聚类算法" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h3><p>最著名的聚类算法，算法十分简单，但是在很多情况下效果不错</p>
<h4 id="聚类中的文档表示"><a href="#聚类中的文档表示" class="headerlink" title="聚类中的文档表示"></a>聚类中的文档表示</h4><ul>
<li>向量空间模型</li>
<li>欧式距离计算向量之间的相关性</li>
</ul>
<h4 id="K-均值聚类算法-1"><a href="#K-均值聚类算法-1" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h4><ul>
<li>K-均值聚类算法中的每个簇都定义为其质心向量</li>
<li>划分准则：<strong>使得所有文档到其所在簇的质心向量的平方和最小</strong></li>
<li>质心向量的定义：</li>
<li>通过下列两部来实现目标优化：<ol>
<li>重分配：将每篇文档分配给离它最近的簇</li>
<li>重计算：重新计算每个簇的质心向量</li>
</ol>
</li>
</ul>
<h4 id="K-均值聚类算法一定会收敛"><a href="#K-均值聚类算法一定会收敛" class="headerlink" title="K-均值聚类算法一定会收敛"></a>K-均值聚类算法一定会收敛</h4><ul>
<li>RSS（Residual Sum of Squares）残差平方和 = 所有簇上的文档向量到质心向量的距离的平方和的总和</li>
<li>每次重新分配之后RSS会下降<ul>
<li>因为每个向量都被移到离它最近的质心向量所代表的簇中</li>
</ul>
</li>
<li>每次重新计算之后RSS也会下降</li>
<li>可能的聚类结果是有穷的，因此一定会收敛到一个固定点</li>
<li>如果出现了等值的情况，算法都采用前后一致的方法来处理</li>
<li>如果不关心少许文档在不同簇之间来回交叉的话，收敛速度通常会很快。但是完全收敛需要很庞大的迭代过程</li>
</ul>
<h4 id="K-均值聚类算法的最优性"><a href="#K-均值聚类算法的最优性" class="headerlink" title="K-均值聚类算法的最优性"></a>K-均值聚类算法的最优性</h4><ul>
<li>收敛并不意味着会达到<strong>全局最优</strong>的聚类结果，这是K-均值聚类算法最大缺点之一。如果开始的种子选择不好，最终的聚类结果可能会非常糟糕。</li>
</ul>
<h4 id="K-均值聚类算法的初始化"><a href="#K-均值聚类算法的初始化" class="headerlink" title="K-均值聚类算法的初始化"></a>K-均值聚类算法的初始化</h4><ul>
<li>种子的随机选择只是K-均值聚类算法的中初始化方法之一</li>
<li>随机选择不太鲁棒：可能会获得一个次优的聚类结果</li>
<li>更好的办法：<ul>
<li>非随机地采用某些启发式方法来选择种子（比如，过滤掉一些离群点，或则寻找具有较好文档空间覆盖度的种子集合）</li>
<li>采用层级聚类算法寻找好的种子</li>
<li>选择$i$次不同的随机种子集合，对每次产生的随机种子集合运行<strong><em>K</em></strong>-均值聚类算法，最后选择具有最小RSS的聚类结果。</li>
</ul>
</li>
</ul>
<h4 id="K-均值聚类算法的时间复杂度"><a href="#K-均值聚类算法的时间复杂度" class="headerlink" title="K-均值聚类算法的时间复杂度"></a>K-均值聚类算法的时间复杂度</h4><p>O(<em>IKNM</em>)-线性</p>
<h3 id="聚类评价"><a href="#聚类评价" class="headerlink" title="聚类评价"></a>聚类评价</h3><h4 id="内部准则"><a href="#内部准则" class="headerlink" title="内部准则"></a>内部准则</h4><p>一个内部准则的例子：K-均值聚类算法的$RSS$值。</p>
<p>但是内部准则往往不能评价聚类在应用中的实际效用</p>
<h4 id="外部准则"><a href="#外部准则" class="headerlink" title="外部准则"></a>外部准则</h4><ul>
<li>按照用户定义的<strong>分类</strong>结果来评价，即对一个分好类的数据集进行聚类，将聚类结果和事先的类别情况进行比照，得到最后的评价结果。</li>
<li>目标：<strong>聚类结果和给定分类结果一致</strong></li>
</ul>
<h4 id="纯度"><a href="#纯度" class="headerlink" title="纯度"></a>纯度</h4><ul>
<li>对每个簇，找到类别$c_j$，该类别包含$w<em>k$中的元素最多，为$n</em>{kj}$个，也就是说$w_k$的元素最多分布在$c_j$中</li>
<li>将所有n_{kj}求和，然后除以所有的文档数目N</li>
</ul>
<h3 id="簇个数确定"><a href="#簇个数确定" class="headerlink" title="簇个数确定"></a>簇个数确定</h3><ul>
<li>基本思路：<ul>
<li>从一个簇开始（K=1）</li>
<li>不断增加簇</li>
<li>对每个新的簇增加一个惩罚项</li>
</ul>
</li>
<li>在惩罚项和RSS之间折中，选择满足最佳折中条件的K</li>
<li>给定聚类结果，定义文档的代价为其到质心向量的距离(失真率)</li>
<li>定义全部失真率RSS(K)为所有文档代价和</li>
<li>对每个簇一个惩罚项$\lambda$ ，对于具有K个簇的聚类结果，总的聚类惩罚项为K$\lambda$。</li>
<li>定义聚类结果的所有开销为失真率和总聚类惩罚项的和：RSS(K)+K$\lambda$</li>
<li>选择使得(RSS(k)+Kℷ)最小的K值</li>
</ul>
<h4 id="本讲小结-1"><a href="#本讲小结-1" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>聚类的概念</li>
<li>聚类在IR中的应用</li>
<li>K-均值聚类算法</li>
<li>聚类评价</li>
<li>簇个数确定</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/Create-reverse-table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/01/Create-reverse-table/" itemprop="url">
                  Create reverse table
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T15:44:06+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/01/Create-reverse-table/" class="leancloud_visitors" data-flag-title="Create reverse table">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="http://a280606790.iteye.com/blog/799347" target="_blank" rel="external">http://a280606790.iteye.com/blog/799347</a></p>
<p><a href="http://www.cnblogs.com/sephy/p/3303711.html" target="_blank" rel="external">http://www.cnblogs.com/sephy/p/3303711.html</a></p>
</blockquote>
<h2 id="Lucene包结构功能表"><a href="#Lucene包结构功能表" class="headerlink" title="Lucene包结构功能表"></a>Lucene包结构功能表</h2><table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.apache.lucene.analysis</td>
<td>语言分析器，主要用于的切词，支持中文主要是扩展此类</td>
</tr>
<tr>
<td>org.apache.lucene.document</td>
<td>索引存储时的文档结构管理，类似于关系型数据库的表结构</td>
</tr>
<tr>
<td>org.apache.lucene.index</td>
<td>索引管理，建立、删除等</td>
</tr>
<tr>
<td>org.apache.lucene.queryParser</td>
<td>查询分析器，查询关键词间的运算，与、或、非等</td>
</tr>
<tr>
<td>org.apache.lucene.search</td>
<td>检索管理，根据查询条件，检索得到结果</td>
</tr>
<tr>
<td>org.apache.lucene.util</td>
<td>公用类</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Analyzer是分析器，将字符串划分成一个个词语，去除其中的无效词语。英文的of,the，中文’的’，’地’等。</p>
</li>
<li><p>document用户提供的源，可以是文本文件、字符串或者数据库表的一条记录。一条记录经过索引后，就是以一个Document形式存储在索引文件中。用户进行搜索以Document列表形式返回</p>
</li>
<li><p>Field: 一个document可以包含多个信息域，标题、正文、最后修改时间，这些信息域通过Field在Document中存储。Field有两个属性可选：存储和索引。通过存储属性可以控制是否对该Field进行存储。</p>
</li>
<li><p>Term:搜索的最小单位，表示文档的一个词语。term由词语和这个词语出现的Field组成。</p>
</li>
<li><p>Tocken: term中的一次出现，包含term文本和相应的起止偏移，以及一个类型字符串。一句话可以出现多次相同的词语，它们用同一个term表示，但是用不同的tocken，每个tocken标记该词语出现的地方。</p>
</li>
<li><p>Segment: 添加索引时并不是每个document都马上添加到同一个索引文件，首先被写入不同的小文件，然后再合并成一个大索引文件，每一个小文件都是一个segment。</p>
<p>​</p>
</li>
</ul>
<h2 id="Lucene查询逻辑"><a href="#Lucene查询逻辑" class="headerlink" title="Lucene查询逻辑"></a>Lucene查询逻辑</h2><h3 id="影响Lucene对文档评分权重的方式"><a href="#影响Lucene对文档评分权重的方式" class="headerlink" title="影响Lucene对文档评分权重的方式"></a>影响Lucene对文档评分权重的方式</h3><p>如果希望某些文档和某些域比其他的域更重要，如果此文档和此域包含所要查询的词则应该得分较高，则可以在索引阶段设定文档的boost和域的boost值。默认值1.0，增加权重需要比1大才可以</p>
<p>Lucene文档的打分公式：<br>$$<br>score(q,d)=coord(q,d) \cdot queryNorm(q)\cdot \sum (tf(t\in d))\cdot idf(t)^3 \cdot t.getBoost()\cdot norm(t,d))<br>$$<br>通过修改对应域的boost的值来修改对应域的权重。</p>
<p>lucene的搜索相当强大，提供了很多辅助查询类，每个类都继承自Query类，各自完成特定的一种查询，可以组合使用完成特定的复杂操作；Lucene还提供Sort类对结果进行排序，还有Filter类对查询条件进行限制。各种查询方式可以在官网API中查看。</p>
<p>对于分词器，按照句子语义切分成一个个词语。对英文进行切词已经有完善的分词器StandardAnalyzer，很多情况下都可以使用。但是对中文分词并不友好，它会将中文词语单切，对每一个字符都分词。例如搜索”如果”，也会将”牛奶不如果汁好喝”搜索出来，并且因为对每一个字都分词，会造成词项很多，文件很大。所以选择使用Paoding分词，按词典词义进行分词。</p>
<p>执行查询的逻辑为：在已创建的索引目录中，创建一个搜索器。使用分词器对查询语句分词，设置搜索的域，利用生成的query去搜素，以Hits的形式返回。</p>
<p>查询例示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">searchIndex</span><span class="params">(String text)</span></span>&#123;</div><div class="line">     TokenStream stream = analyzer.tokenStream(<span class="string">"content"</span>,<span class="keyword">new</span> StringReader(text));</div><div class="line">     Date date1=<span class="keyword">new</span> Date();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">if</span>(showParticiple)</div><div class="line">             printTokens(<span class="string">" "</span>,stream);</div><div class="line">         System.out.println(<span class="string">"搜索 '"</span>+text+<span class="string">"' 结果如下"</span>);</div><div class="line">         <span class="comment">//1.打开存储位置</span></div><div class="line">             <span class="comment">//庖丁分词</span></div><div class="line">         analyzer = <span class="keyword">new</span> PaodingAnalyzer();</div><div class="line">         IndexReader ireader = IndexReader.open(INDEX_DIR);</div><div class="line">         <span class="comment">//2.创建搜索器</span></div><div class="line">         IndexSearcher isearcher = <span class="keyword">new</span> IndexSearcher(ireader);</div><div class="line">         <span class="comment">//3.进行关键词查询</span></div><div class="line">         QueryParser parser = <span class="keyword">new</span> QueryParser(<span class="string">"content"</span>,analyzer);</div><div class="line">       	<span class="comment">//进行多域查询，支持查询内容，时间，日期</span></div><div class="line">         String fields[] = &#123;<span class="string">"content"</span>,<span class="string">"filename"</span>,<span class="string">"editor"</span>,<span class="string">"date"</span>&#125;;</div><div class="line">         String texts[] =&#123;text,text,text,text&#125;;</div><div class="line">         Query query = MultiFieldQueryParser.parse(texts,fields,analyzer);</div><div class="line">         ScoreDoc[] hits=isearcher.search(query,<span class="keyword">null</span>,<span class="number">300</span>).scoreDocs;</div><div class="line">         <span class="keyword">if</span>(hits.length==<span class="number">0</span>)</div><div class="line">             System.out.println(<span class="string">"没有相似文件"</span>);</div><div class="line">         <span class="keyword">else</span> &#123;</div><div class="line">             System.out.println(<span class="string">"找到"</span>+hits.length+<span class="string">"个文件"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hits.length;i++)&#123;</div><div class="line">             Document hitDoc = isearcher.doc(hits[i].doc);</div><div class="line">             System.out.println(<span class="string">"_______________________"</span>);</div><div class="line">             System.out.println(hitDoc.get(<span class="string">"filename"</span>));</div><div class="line">             System.out.println(<span class="string">"时间: "</span>+hitDoc.get(<span class="string">"date"</span>));</div><div class="line">             System.out.println(<span class="string">"URL: "</span>+hitDoc.get(<span class="string">"url"</span>));</div><div class="line">             System.out.println(<span class="string">"Content:"</span>+hitDoc.get(<span class="string">"content"</span>));</div><div class="line">             System.out.println(<span class="string">"编辑: "</span>+hitDoc.get(<span class="string">"editor"</span>));</div><div class="line">             System.out.println(<span class="string">"Path:"</span>+hitDoc.get(<span class="string">"path"</span>));</div><div class="line">             System.out.println(<span class="string">"_______________________"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//4.关闭查询器等</span></div><div class="line">         ireader.close();</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">     &#125;</div><div class="line">     Date date2 = <span class="keyword">new</span> Date();</div><div class="line">     System.out.println(<span class="string">"查看索引-----耗时："</span>+(date2.getTime()-date1.getTime()+<span class="string">"ms\n"</span>));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="Lucene入库逻辑"><a href="#Lucene入库逻辑" class="headerlink" title="Lucene入库逻辑"></a>Lucene入库逻辑</h2><ol>
<li><p>入库这定义到库中文档的结构，如需要把网站内容加载到全文检索库，让用户通过“站内检索“搜索到相关的网页的内容。入库文档结构和关系型数据库中的表结构类似，每个入库的文档由多个字段构成（文章标题、作者、发布时间、原文链接、正文内容）。</p>
</li>
<li><p>包含N个字段的文档（Dcument）在入库前需要经过切词索引，切词规则由语言分析器（analyzer）完成。</p>
</li>
<li><p>切分后的”单词“被注册到索引树上，供查询使用。另需要将其他不需要索引的内容入库，所有这些文件操作由storage完成。</p>
</li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">createIndex</span><span class="params">(String path)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">boolean</span> first=<span class="keyword">true</span>;</div><div class="line">        <span class="comment">//记录开始创建索引的时间</span></div><div class="line">        Date date1=<span class="keyword">new</span> Date();</div><div class="line">        <span class="comment">//获取路径下的所有文件集合</span></div><div class="line">        List&lt;File&gt; fileList=getFileList(path);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span>(File f:fileList)&#123;</div><div class="line">                <span class="comment">//从"."开始取子字符串 取文件后缀</span></div><div class="line">                String type =f.getName().substring(f.getName().lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>);</div><div class="line">                <span class="comment">//1.读取txt文件的内容</span></div><div class="line">                <span class="keyword">if</span>(<span class="string">"txt"</span>.equalsIgnoreCase(type)) &#123;</div><div class="line">                    <span class="comment">//取得文件所有内容</span></div><div class="line">                    con = txt2String(f);</div><div class="line">                &#125;</div><div class="line">     </div><div class="line">                <span class="comment">//2.向本地文件存储索引</span></div><div class="line">                File indexFile = <span class="keyword">new</span> File(INDEX_DIR);</div><div class="line">              	<span class="comment">//如果索引不存在则创建</span></div><div class="line">                <span class="keyword">if</span>(!indexFile.exists())&#123;</div><div class="line">                    indexFile.mkdirs();</div><div class="line">                &#125;</div><div class="line">                indexWriter = <span class="keyword">new</span> IndexWriter(INDEX_DIR,analyzer,first);</div><div class="line">                first=<span class="keyword">false</span>;</div><div class="line">        </div><div class="line">                <span class="comment">//3.提取内容，进行索引的存储</span></div><div class="line">                Document document=<span class="keyword">new</span> Document();</div><div class="line">                Field filename = <span class="keyword">new</span> Field(<span class="string">"filename"</span>,con.get(<span class="number">0</span>), Field.Store.YES,Field.Index.TOKENIZED);</div><div class="line">                filename.setBoost(<span class="number">100</span>);</div><div class="line">                Field editor = <span class="keyword">new</span> Field(<span class="string">"editor"</span>,con.get(<span class="number">2</span>), Field.Store.YES,Field.Index.TOKENIZED);</div><div class="line">              	<span class="comment">//设置内容权重</span></div><div class="line">                editor.setBoost(<span class="number">80</span>);</div><div class="line">                document.add(filename);</div><div class="line">                Field content = <span class="keyword">new</span> Field(<span class="string">"content"</span>,con.get(con.size()-<span class="number">1</span>), Field.Store.YES,Field.Index.TOKENIZED);</div><div class="line">                content.setBoost(<span class="number">50</span>);</div><div class="line">                document.add(<span class="keyword">new</span> Field(<span class="string">"date"</span>,con.get(<span class="number">3</span>), Field.Store.YES,Field.Index.UN_TOKENIZED));</div><div class="line">                document.add(editor);</div><div class="line">                document.add(<span class="keyword">new</span> Field(<span class="string">"url"</span>,con.get(<span class="number">1</span>),Field.Store.YES,Field.Index.NO));</div><div class="line">                document.add(content);</div><div class="line">                document.add(<span class="keyword">new</span> Field(<span class="string">"path"</span>,f.getPath(), Field.Store.YES,Field.Index.NO));</div><div class="line">                <span class="comment">//4.索引对象加入索引创建中</span></div><div class="line">                indexWriter.addDocument(document);</div><div class="line">                <span class="comment">//提交索引并关闭</span></div><div class="line">                closeWriter();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        Date date2=<span class="keyword">new</span> Date();</div><div class="line">        System.out.println(<span class="string">"创建索引成功\t耗时： "</span>+(date2.getTime()-date1.getTime())+<span class="string">"ms\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/23/Python爬虫/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/23/Python爬虫/" itemprop="url">
                  Python爬虫--《山大主页》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-23T00:00:00+08:00">
                2017-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/23/Python爬虫/" class="leancloud_visitors" data-flag-title="Python爬虫--《山大主页》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h1><h2 id="URL管理器"><a href="#URL管理器" class="headerlink" title="URL管理器"></a>URL管理器</h2><p>声明两个集合 new_urls,old_urls. 一个存储待爬取的URL，一个存储已经爬取过的URLS。其中有四个函数，分别是</p>
<ul>
<li>add_new_url: 如果传入的url不在带爬取页面和已爬取页面中，向new_urls中加入一个新的待爬取页面。</li>
<li>add_new_urls:传入很多urls，将urls的每一个url调用add_new_url判断是否加入待爬取集合中</li>
<li>has_new_url:判断是否有待爬取页面</li>
<li>get_new_url:从待爬取集合中返回一个url并将其加入已爬取集合中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlManager</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.new_urls = set()</div><div class="line">        self.old_urls = set()</div><div class="line">    <span class="comment"># 向管理器添加url</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_url</span><span class="params">(self, url)</span>:</span></div><div class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 如果URL不在待爬取页面和已爬取页面中，将页面加入到待爬取页面</span></div><div class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.new_urls <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.old_urls:</div><div class="line">            self.new_urls.add(url)</div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_urls</span><span class="params">(self, urls)</span>:</span></div><div class="line">        <span class="comment"># 如果urls为空 或者 其长度为0 退出</span></div><div class="line">        <span class="keyword">if</span> urls <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(urls) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 调用单个url加入到集合中</span></div><div class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</div><div class="line">            self.add_new_url(url)</div><div class="line"></div><div class="line">    <span class="comment"># 是否有新的url</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_new_url</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 长度不为0表明有待爬取的url</span></div><div class="line">        <span class="keyword">return</span> len(self.new_urls) != <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_url</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 从待获取url集合中获取一个url，并加入到已爬取集合</span></div><div class="line">        new_url = self.new_urls.pop()</div><div class="line">        self.old_urls.add(new_url)</div><div class="line">        <span class="keyword">return</span> new_url</div></pre></td></tr></table></figure>
<h2 id="URL下载器"><a href="#URL下载器" class="headerlink" title="URL下载器"></a>URL下载器</h2><p>将传入的url，使用urllib2.urlopen下载，并返回结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, url)</span>:</span></div><div class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        response = urllib2.urlopen(url)</div><div class="line">        <span class="keyword">if</span> response.getcode() != <span class="number">200</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span> response.read()</div></pre></td></tr></table></figure>
<h2 id="URL解析器"><a href="#URL解析器" class="headerlink" title="URL解析器"></a>URL解析器</h2><ul>
<li>_get_new_urls: 根据传入的BeautifulSoup对象查找符合要求的url，即需要爬取的url。找到所有a标签中符合url标准的 href值。并且根据格式生成对应的url加入到new_urls集合中。</li>
<li>_get_new_data: 解析页面中的数据，声明一个字典res_data，保存url、title、date、content、author</li>
<li>parse: 传入页面内容和url，分别爬取页面的url和data并返回</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> urlparse</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_new_urls</span><span class="params">(self, page_url, soup)</span>:</span></div><div class="line">        new_urls = set()</div><div class="line">        <span class="comment"># view.sdu.edu.cn/new/2017~~~~</span></div><div class="line">        <span class="comment">#^\d+/([^# ]*)| 导航栏： ^/new/\w+/$  上下一页^\w+/\d+.html ：sdnews/23.html  ^/new/\w+/$</span></div><div class="line">        links = soup.find_all(<span class="string">'a'</span>, href=re.compile(<span class="string">r"^\d+/([^# ]*)|^/new/\w+|^\w+/\d+.html"</span>))    <span class="comment"># 正则表达式  /view/123.htm</span></div><div class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</div><div class="line">            new_url = link[<span class="string">'href'</span>]</div><div class="line">            <span class="comment"># print (new_url)</span></div><div class="line">            <span class="keyword">if</span> new_url[<span class="number">0</span>:<span class="number">4</span>] == <span class="string">"/new"</span>:</div><div class="line">                new_full_url = urlparse.urljoin(page_url, new_url)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                new_full_url = <span class="string">"http://www.view.sdu.edu.cn/new/"</span>+new_url</div><div class="line">            <span class="comment">#</span></div><div class="line">            <span class="comment"># print (new_full_url)</span></div><div class="line">            new_urls.add(new_full_url)</div><div class="line">        <span class="keyword">return</span> new_urls</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_new_data</span><span class="params">(self, page_url, soup)</span>:</span></div><div class="line">        <span class="comment"># 解析数据</span></div><div class="line">        res_data = &#123;&#125;</div><div class="line">        res_data[<span class="string">'url'</span>] = page_url</div><div class="line">        <span class="comment"># &lt;div class="text"&gt; &lt;h1&gt;山东大学召开创新转化学院课程与教材建设研讨会&lt;/h1&gt;</span></div><div class="line">        <span class="keyword">if</span> soup.find(<span class="string">'div'</span>, class_=<span class="string">"text"</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 标题</span></div><div class="line">        title_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"text"</span>).find(<span class="string">'h1'</span>)</div><div class="line">        res_data[<span class="string">'title'</span>] = title_node.get_text()</div><div class="line">        <span class="comment"># 时间</span></div><div class="line">        <span class="comment">#&lt;div class="text_a"&gt;</span></div><div class="line">        date_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"text_a"</span>)</div><div class="line">        res_data[<span class="string">'date'</span>] = date_node.get_text()</div><div class="line"></div><div class="line">        <span class="comment"># &lt;div class="text_s" id="content"&gt;</span></div><div class="line">        <span class="comment"># 内容</span></div><div class="line">        summary_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"text_s"</span>, id=<span class="string">"content"</span>)</div><div class="line">        res_data[<span class="string">'summary'</span>] = summary_node.get_text()</div><div class="line">        <span class="comment"># &lt;div class ="text_c" &gt; 【作者：邹晓东　来自：《文史】 &lt; / div &gt;</span></div><div class="line">        <span class="comment"># 作者</span></div><div class="line">        author_node = soup.find(<span class="string">'div'</span>,class_=<span class="string">"text_c"</span>)</div><div class="line">        res_data[<span class="string">'author'</span>] = author_node.get_text()</div><div class="line">        <span class="keyword">return</span> res_data</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, page_url, html_cont)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> page_url <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> html_cont <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        soup = BeautifulSoup(html_cont, <span class="string">'html.parser'</span>, from_encoding=<span class="string">'utf-8'</span>)</div><div class="line">        <span class="comment"># soup = BeautifulSoup(html_cont)</span></div><div class="line">        new_urls = self._get_new_urls(page_url, soup)</div><div class="line">        new_data = self._get_new_data(page_url, soup)</div><div class="line">        <span class="keyword">return</span> new_urls, new_data</div></pre></td></tr></table></figure>
<h2 id="DATA输出器"><a href="#DATA输出器" class="headerlink" title="DATA输出器"></a>DATA输出器</h2><p>集合datas保存所有内容</p>
<ul>
<li>collect_data: 保存所有爬取的新闻内容数据</li>
<li>output_html: 将datas中所有保存的数据写入到文件中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlOutputer</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.datas = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect_data</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        self.datas.append(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_html</span><span class="params">(self)</span>:</span></div><div class="line">        foutAll = open(<span class="string">'output.html'</span>, <span class="string">'w'</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;meta charset=\"UTF-8\"&gt;"</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;html&gt;"</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;body&gt;"</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;table&gt;"</span>)</div><div class="line">        count = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> self.datas:</div><div class="line">            <span class="comment">#记录每一篇文章的html</span></div><div class="line">            foutAll.write(<span class="string">"&lt;tr&gt;"</span>)</div><div class="line">            foutAll.write(<span class="string">"&lt;td&gt;&lt;a href=%s&gt;%s&lt;/a&gt;&lt;/td&gt;"</span> % (data[<span class="string">'url'</span>], data[<span class="string">'url'</span>]))</div><div class="line">            foutAll.write(<span class="string">"&lt;td&gt;%d&lt;/td&gt;"</span> % count)</div><div class="line">            foutAll.write(<span class="string">"&lt;td&gt;%s&lt;/td&gt;"</span> % data[<span class="string">'title'</span>].encode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line">            fout=open(<span class="string">'test/%d'</span> % count, <span class="string">'w'</span>)</div><div class="line">            fout.write(data[<span class="string">'title'</span>].encode(<span class="string">'utf-8'</span>))</div><div class="line">            fout.write(data[<span class="string">'summary'</span>].encode(<span class="string">'utf-8'</span>))</div><div class="line">            fout.write(data[<span class="string">'url'</span>])</div><div class="line">            fout.close()</div><div class="line">            count += <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="爬虫启动器"><a href="#爬虫启动器" class="headerlink" title="爬虫启动器"></a>爬虫启动器</h2><ul>
<li>初始化爬虫对象：URL管理器、URL下载器、URL解析器、URL输出器</li>
<li>爬虫调度程序：将root_url加入到URL管理器的待爬集合中。如果待爬集合不为空循环执行：取一个url，将其内容下载；将url，cont传入到解析器；解析器返回页面中所有的url和data。将url加入待爬、将data加入输出器。循环结束，调用输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> html_downloader</div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> html_output</div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> html_parser</div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> url_manager</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMain</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="comment"># 构造函数初始化对象</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.urls = url_manager.UrlManager()                    <span class="comment"># URL管理器</span></div><div class="line">        self.downloader = html_downloader.HtmlDownloader()      <span class="comment"># URL下载器</span></div><div class="line">        self.parser = html_parser.HtmlParser()                  <span class="comment"># URL解析器</span></div><div class="line">        self.output = html_output.HtmlOutputer()                <span class="comment"># 输出器</span></div><div class="line">    <span class="comment"># 爬虫调度程序</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self, root_url)</span>:</span></div><div class="line">        count = <span class="number">1</span></div><div class="line">        self.urls.add_new_url(root_url)</div><div class="line">        <span class="keyword">while</span> self.urls.has_new_url():</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                new_url = self.urls.get_new_url()</div><div class="line">                <span class="comment"># print 'craw %d : %s' % (count, new_url)</span></div><div class="line">                html_cont = self.downloader.download(new_url)</div><div class="line">                new_urls, new_data = self.parser.parse(new_url, html_cont)</div><div class="line">                self.urls.add_new_urls(new_urls)</div><div class="line">                self.output.collect_data(new_data)</div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'craw failed'</span></div><div class="line">                <span class="keyword">print</span> count</div><div class="line">        self.output.output_html()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># root_url = "http://www.view.sdu.edu.cn/"             # 入口地址</span></div><div class="line">    <span class="comment"># root_url = "http://www.view.sdu.edu.cn/new/2015/1028/76105.html"             # 入口地址</span></div><div class="line">    root_url = <span class="string">"http://www.view.sdu.edu.cn/"</span></div><div class="line">    <span class="comment"># root_url = "http://www.view.sdu.edu.cn/new/sdnews/"</span></div><div class="line">    obj_spider = SpiderMain()</div><div class="line">    obj_spider.craw(root_url)</div></pre></td></tr></table></figure>
<p><a href="http://download.csdn.net/detail/li201400130091/9859107" target="_blank" rel="external">源代码请参考</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/20/vocabulary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/20/vocabulary/" itemprop="url">
                  vocabulary
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T20:41:30+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/20/vocabulary/" class="leancloud_visitors" data-flag-title="vocabulary">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Media"><a href="#Media" class="headerlink" title="Media"></a>Media</h2><p>current affairs 实事    the press新闻界    the print media印刷媒体    the electronic media电子媒体news outlets新闻报道机构        无处不在的、普遍的、流行的 prevalent,ubiquitous,pervasive            be awash with,be inundated with,be saturated with    </p>
<p>lay the foundation for</p>
<p>increasingly:  Cash in China is increasingly unnecessary.</p>
<p>e-commerce</p>
<p>roughly:  roughtly the population of all Europe</p>
<p>reasonably: We may reasonably conclude that the meeting has been postponed.</p>
<p>freshman 大学一年级学生；新手    sophomore大学二年级学生    junior大学三年级学生    senior大学四年级学生</p>
<p>sampling rate    sampling frequency</p>
<p>Firefighters tried to extinguish the flame.</p>
<p>unfavorable : I got an unfavorable score. /  I am surprised you got an unfavorbale impression of him.</p>
<p>cope with: For all his learning, he didn’t know how to cope with the situation.</p>
<p>civil rights </p>
<p>Sweet are the uses of adversity. 苦尽甘来u</p>
<p>pessism    optimism</p>
<p>harassed 疲倦的，厌烦的   </p>
<p>a house among the trees</p>
<p>cyber 电脑的，网络的    cyber attack </p>
<p>glitch n.小故障  computer glitch</p>
<p>anecdote n.轶事，奇闻</p>
<p>tens of thousands of </p>
<p>vengeance n.报仇，复仇  retaliate v.报复，回敬</p>
<p>mortality n. 死亡数目 Infant mortality was 20 deaths per thousand live births in 1986.</p>
<p>allergy n.敏感症，反感 I have an allergy to animal hair.</p>
<p>lethal adj.致命的 a lethal weapon </p>
<p>oral learing: The mechanism of oral learing is largely that of continuous repetition.</p>
<p>phase out : 逐渐减少 The Palace Museum will decide whether to phase out the sale of paper tickects and sell all tickets via the internet.</p>
<p>in a bid to : 以便， in a bid to avoid too many tourists at a time.</p>
<p>set a daily visitor cap 设置每日游客访问量</p>
<p>restriction: The swimming club is open to families in the neighborhood without restriction.</p>
<p>meditated a visit to her daughter ,  He meditate on his past life.</p>
<p>reception 接待，招待会  receipt n.收据</p>
<p>The book contains many mathmatical theorems.</p>
<p>conform: I can’t conform what you said</p>
<p>entrancing music 令人陶醉的音乐</p>
<p>composite, composition, comprise</p>
<p>speculate: It’s useless to speculate why he did it.</p>
<p>cheat: I would rather fail than cheat in the examination.</p>
<p>suspicious: suspicious behavior, I was suspicious of his motives.</p>
<p>fluctuate: My weight fluctuated widly depending on how muach I ate.</p>
<p>resent-hate: I resent having to get his permission for everything I do.</p>
<p>elevation: The house is at an elevation of 1000 meters.</p>
<p>population: One third of the world’s population consume two thirds of the world’s resources.</p>
<p>fitness: fitness equipment , fitness centers ; Her fitness for the job cannot be questioned.</p>
<p>certainty: We have no certainty of success.</p>
<p>substitute: a meat substitute</p>
<p>tentative: We made a tentative arrangement to meet on Friday. tentative conclusions.</p>
<p>infectious disease,  tourist attraction旅游胜地</p>
<p>a definitive agreement/answer/statement  The definitive version of text is ready to be published.</p>
<p>Don’t keep us in suspense. Tell us what happened!</p>
<p>a muscle spasm 肌肉痉挛</p>
<p>It takes a lot of stamina to run a marathon.</p>
<p>maximum temperature 最高气温</p>
<p>There are some indications that the prices will rise.</p>
<p>eternal truth不朽的真理  She felt eternal gratitude to him for saving her life.</p>
<p>index of corpulence.肥胖指数</p>
<p>2017-05-08</p>
<p>renowned adj.有名的，有声誉的 He is renowned as novelist.</p>
<p>decisive: the decisive vote决定性的一票 .The government must take decisive action on gun control.  </p>
<p>a divorce settlement</p>
<p>He made many efforts to enhance his reputation.</p>
<p>The book shows that he is an ingenious author.</p>
<p>The knowledge is beyond my scope.知识超过了我的范围</p>
<p>Malls in the town reach saturation point.</p>
<p>He consoled her with flowers.  Nothing could console him when his pet dog died.</p>
<p>I refuse to lie about it , it’s against my principles.</p>
<p>He give me a duplicate key of his house.</p>
<p><u>Stern as he is , he is full of sympathy.</u></p>
<p>quench熄灭（镇压）  extinguish熄灭（根除） Firemen try to quench the flames raging through the building.</p>
<p>The house has an ample parlor.</p>
<p>He could no longer distinguish between illusion and reality</p>
<p>Reading good books elevates your mind.</p>
<p>The sun has bleached her yellow skirt.</p>
<p>We’re having difficulty keeping up our mortgage payments.</p>
<p>They pledged never to tell the secret.</p>
<p>a crucial factor / issue / decision</p>
<p>ambient temperature 室温  Ambient noise may come from any direction.</p>
<p>Rice is our staple food.</p>
<p>The external walls of the building.</p>
<p>Our relationship is based on reciprocal respect. 我们的关系是以相互尊重为基础的。</p>
<p>The stillness was broken by the sound of footsteps.</p>
<p>There was a suddent stillness in the air.</p>
<p>They asked him to be merciful to the prisoners.</p>
<p>He is a man always speaking with restraint.</p>
<p>She’s tired of the perpetual complaints.   </p>
<p>In his job, patience is an invalueable asset.</p>
<p>The meeting may be prolong into the evening.</p>
<p>He sent the letter our of malice.</p>
<p>Henceforth I expect you to be punctual for meeting.</p>
<ul>
<li>permanent指总是处于相同的情况和地位，可长期持续下去，永久不变</li>
<li>eternal语体较庄重，侧重指永远存在，无始无终。 </li>
<li>perpetual语气最强，指保持永久不变，没有中断的行为，永无止境地持续下去。有时用于贬义，指令人厌烦之事。</li>
</ul>
<p>You don’t have to be a dieter.</p>
<p>It’s the job of the police to enforce the law.</p>
<p>2017-05-10</p>
<p>She made an emotional plea for help.</p>
<p>Her denial of my advice hurts me.</p>
<p>There is no further reference to him in her diary</p>
<p>The dispute coule develop into open warfare.</p>
<p>Be careful not to damage other people’s property.</p>
<p>Thank you so much for your timely help.</p>
<p>Some people are never contented.</p>
<p>A new work programme for young people will be implemented.</p>
<p>It is doubtless that Taiwan belongs to China.</p>
<p>I affirm that waht he said is true.</p>
<p>The missing girl is presumed dead.</p>
<p>I am accustomed to sleeping late.</p>
<p>an elaborately decorated room</p>
<p>He was resolute in carrying out his plan.</p>
<p>2017-05-11 </p>
<p>national anthem国歌</p>
<p>think twice再三考虑</p>
<p>A smile often denotes pleasure and friendship</p>
<p>2017-05-12</p>
<p>astonishing惊人的</p>
<p>without intervention</p>
<p>epidemic： childhood obesity was neither an epidemic nor a public health problem.</p>
<p>obesity is also a risk factor for a variety of chronic diseases.</p>
<p>The company was granted a charted trade in the occupied.</p>
<p>I wouldn’t have dared to defy my teachers.</p>
<p>Adolescence is the period of transition between childhood and adulthood.</p>
<p>Her perdominant characteristic is honesty.</p>
<p>I fail to see the logic behind his argument.</p>
<p>Technically the building is a masterpiece, but few people like it.</p>
<p>To be specific, the argument in your graduation thesis is logical.</p>
<p>She was pressurized into agreeing to a merger.</p>
<p>She was expelled from his company.</p>
<p>2017-05-13 </p>
<p>Implicit in his speech was the a assumption that they guilty.</p>
<p>2017-05-14 </p>
<p>There’s only a minimal amount of risk involved.</p>
<p>If you get up early, you should not disturb others.</p>
<p>Why should I say sorry when it’s not my fault?</p>
<p>I really hate your abandonment of study.</p>
<p>2017-05-15</p>
<p>struggling with 艰苦奋斗</p>
<p>distinctly:  Though they talked in a low voice, they could be heard distinctly.</p>
<p>reportedly:  The  star is reportedly very ill.</p>
<p>engage in:  Let’s not engage in personalities.</p>
<p>category: We are divided into several categories by grades.</p>
<p>sequence: He had to attend a sequence of meetings.</p>
<p>under way: He gave his content for the project to get under way.</p>
<p>elapse:  Three years have elapsd since we met last time.</p>
<p>situated: The village is situated in a valley.</p>
<p>cleanliness: We require the cleanliness from our child.</p>
<p>designate: She was designated sportswoman of the year.</p>
<p>regulatory: There were privacy and regulatory worries.</p>
<p>inviolable: inviolable territory, the inviolable right to life</p>
<p>2017-05-16 </p>
<p>No previous experience is necessary for this job.</p>
<p>He refused the proffered assistance.</p>
<p>Children swim at the pool, under the watchful eye of lifeguards.</p>
<p>The problem is that it’s not profitable.</p>
<p>violence   ultraviolet</p>
<p>in a stew over the lost keys</p>
<p>case history</p>
<p>deviant</p>
<p>introverted</p>
<p>2017-05-18</p>
<p>His action is out of greed</p>
<p>instantaneous  He had an instantaneous response.</p>
<p>He used to be a literary agent.</p>
<p>civilized  : Such behavior is unacceptable in a civilized society.</p>
<p>faltering: A pause of faltering in speech.</p>
<p>2017-05-20</p>
<p>The realization of his ambition makes hime very happy.</p>
<p>The deficiency of this plan is very clear and it can’t possibly succeed.</p>
<p>She couldn’t stand any more of their ridicule.</p>
<p>instiution</p>
<p>2017-05-21</p>
<p>We’re not sure whether we still want to proceed the sale.</p>
<p>He had practically finished his meal when I arrived.</p>
<p>The big match tonight is England versus Spain.</p>
<p>a massive dose of a drug.</p>
<p>We restrict the number of students per class to 10</p>
<p>2017-05-22</p>
<p>institution 制度</p>
<p>fundamental adj. 基本的，基础的</p>
<p>2017-05-28</p>
<p>sponsored</p>
<p>ceaseless adj. 不断的，不停的</p>
<p>awfully adv.可怕地，非常地</p>
<h2 id="教育意义"><a href="#教育意义" class="headerlink" title="教育意义"></a>教育意义</h2><ol>
<li>gain knowledge about…… 获取关于……的知识</li>
<li>develop a wide range of skills  </li>
<li>improve/sharpen their skills</li>
<li>academic performance<ol>
<li>get good grades / achieve good grades</li>
<li>communication skills </li>
<li>problem-solving skills</li>
</ol>
</li>
<li>provide a well-rounded education<ol>
<li>have a wide range of interests and skills</li>
</ol>
</li>
<li>a broad and balance curriculum<ol>
<li>place more importance on……</li>
</ol>
</li>
<li>an optinal course</li>
<li>academic subjects</li>
<li>develop good learning habits</li>
<li>give them a sense of achievement</li>
<li>reduce distractions 减少干扰</li>
</ol>
<h2 id="Listening-List"><a href="#Listening-List" class="headerlink" title="Listening List"></a>Listening List</h2><h3 id="House-renting"><a href="#House-renting" class="headerlink" title="House renting"></a>House renting</h3><p>renting 出租、real-estate agency房屋中介、Landlord房东、Landlady女房东、deposit押金、lease租约、available可租的、unfurnished没有家具的、furnished有家具的、facilities设备、surrounding周边环境、fence篱笆、driveway车道、garage车库、corridor走廊、fountain喷泉、suburb\outskirts郊区、downtown市区、style风格、bungalow平房、flat、accommodation住宿、dormitory宿舍、motel汽车旅馆、shared social area共享休息区、Wing翼、Annex副楼、Lobby前厅、Foyer门厅、balcony阳台、a single/double bedroom 单人间/双人间、a twin room双床房、Laundry room洗衣间、Attic阁楼、Bunk bed上下铺、Wardrobe衣柜、Mirror镜子、cupboard橱柜、cabinet衣柜、drawer柜子、Mattress床垫、king/queen-size bed特大/大号床、electronics电器、Central heating中央供暖、radiator暖气片、air-conditioner空调、washing machine洗衣机、fridge冰箱、vacuum cleaner吸尘器、micro-wave oven微波炉、(Hair)dryer、cable TV有线电视、stereo system立体音响、kettle电水壶、decoration装饰、carpet地毯、pillow枕头、sheet床单、blanket毯子、curtain窗帘、shutter百叶窗、soap肥皂、shampoo香波、body wash沐浴液、body lotion润肤乳、towel浴巾、toothpaste牙膏、toothbrush牙刷、filter过滤器</p>
<h3 id="Job-hopping"><a href="#Job-hopping" class="headerlink" title="Job hopping"></a>Job hopping</h3><p>vacant position空缺职位、job applicant工作申请者、candidate求职者、day shift 日班、shift work倒班、challenging job有挑战的工作、CV=resume简历、arm badge/name badge 胸章/臂章、job interview求职面试、starting salary起薪、wage工资、commission佣金、perks红包、bonus分红、pension养老金、public house fund住房公积金、health insurance健康保险、duration时长、career plan职业规划、work irregular hours不规则工作时间、achievement成就、random selection随机选择、occupational factor职业因素、satisfaction满足感、routine work日常工作、staff advantages员工福利、window dressing橱窗展示、cashier收银员、serve customers服务客户、performance at work工作表现、performance绩效、keep an eye on stock关注库存、stimulating刺激、human resources人力资源、financial officer财政人员、public servant公务员、airplane飞机、ferry轮渡、hovercraft气垫船、tube地铁、subway地铁、underground地铁、metro地铁、cab出租车、4-wheel-drive四驱车、hybrid混合动力车、airport shuttle bus机场穿梭巴士、minibus小巴、express train高铁</p>
<h3 id="Shopping"><a href="#Shopping" class="headerlink" title="Shopping"></a>Shopping</h3><p>shop assistant售货员、counter柜台、corner shop街角小店、general store综合商店、Hypermarket大型超级市场、stall货摊、booth流动商店、kiosk报亭 公用电话亭、boutique时装精品小店、bazaar市场、arcade拱廊市场？、precinct购物区、shopping mall购物中心、department store百货商店、free parking lot免费停车场、mail-order store邮购商店、auction拍卖、second-hand store二手商店、bid喊价、discount折扣、change找零、cosmetic化妆品、stationery文具、fabrics纺织品、sports good体育用品、daily necessities日常必需品、cash现金、cheque支票、cheque book支票本、signature签名、visa、balance余额、overdraft透支、installment分期还款、duty-free shop免税店、credit card信用卡、quality质量、service服务、brand品牌、compact紧凑车型、sedan小轿车、</p>
<h3 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h3><p>barley 大麦</p>
<p>Section 3 Listen words</p>
<p>Now this is rather disturbing</p>
<p>life span 寿命   longevity寿命</p>
<p>spouse法律意义上 的伴侣   partner </p>
<p>nursing care </p>
<p>To start with ,  Since , Furthermore </p>
<p>It is the in playground that we meet each other. </p>
<p>subsidy 津贴补助 allownce</p>
<p>social security 社保 social ins</p>
<p>informative消息灵通的，资料多的，信息量大的</p>
<p>initiative主动权(计划，决定) profitable有利益的</p>
<p>rare breeds animals 稀有物种 </p>
<p>circular area </p>
<p>rear</p>
<p>address the problem解决问题</p>
<p>erect a </p>
<p>enable traffic to exit at all times.</p>
<p>Top/bottom </p>
<p>Above/ below</p>
<p>##连接的词汇</p>
<h3 id="由于，因为"><a href="#由于，因为" class="headerlink" title="由于，因为"></a>由于，因为</h3><ul>
<li>on account of </li>
<li>As a result of 由于，  As a result ，因此</li>
</ul>
<h4 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h4><p>wax and wane 起伏、改变   The stock waxs and wanes</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/小作文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/小作文/" itemprop="url">
                  IELTS小作文
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T23:30:58+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/19/小作文/" class="leancloud_visitors" data-flag-title="IELTS小作文">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol>
<li>曲线的变化趋势：上升、下降、保持平稳、波动</li>
<li>特殊点：起点、终点、交点、极值点、转折点</li>
<li>特殊曲线</li>
</ol>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol>
<li>简单介绍逻辑 paraphrase    不能抄题</li>
<li>所有曲线的起点  信息处理逻辑（从大到小），相近的点一句话处理（顺序）</li>
<li>所有下降的曲线及除了交点之外的所有特点</li>
<li>所有上升的曲线及包含交点的所有特点        （按幅度分组）</li>
<li>图标的Overview  图的最大特点，第一眼看 (1)各个曲线的趋势（2）特殊曲线</li>
</ol>
<h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>按柱子的分类分段（主要方法）</p>
<p>按横坐标的组数分段（补充方法）    原则4~6</p>
<p>按时态分段（适用于)</p>
<p>分段不参考 动静</p>
<p>两倍关系 ：第一 的从句 将一半的带出</p>
<ol>
<li>柱状图即可提现数据变化趋势</li>
</ol>
<h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><ol>
<li><p>写几块？ 为什么？</p>
<p>（x-1）块，x=总块数 ；</p>
</li>
<li><p>主要特点是</p>
<p>1st 2nd last。找数字关系</p>
</li>
<li><p>写作顺序</p>
<p>从大到小</p>
</li>
<li><p>余下的块看情况，找数字之间的关系</p>
</li>
</ol>
<h2 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h2><h4 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h4><ul>
<li>上升： rise / climb / increase / soar / show an upward trend /</li>
<li>下降：fall / decline / decrease / slash大幅度削减 /detract from /descend</li>
<li>保持平稳：(keep/remain)  (stable/steady)</li>
<li>波动： fluctuate</li>
<li>显著地： obviously  / consideratly / significantly</li>
<li>大约：about / around / almost /approximately / roughly / just over or below</li>
<li>超过：overtake / exceed / surpass</li>
<li>展现： show / illustrate / give information about</li>
<li>很多：a great deal</li>
<li>占据：account for</li>
</ul>
<h3 id="静态图句型"><a href="#静态图句型" class="headerlink" title="静态图句型"></a>静态图句型</h3><p>百分之…的…被用来/被用在…了 </p>
<p><u>40% of money was used/spent in food.</u></p>
<p><u>There is 40% of money that is spent on food.</u></p>
<p><u>Money spent on food occupies/takes up/consititute/  40%  of all/collectively</u>(不适用纯数字)</p>
<p><u>The percentage/proportion of money spent on food is 40%.</u>    number/quantity/amount</p>
<h3 id="动态图句型"><a href="#动态图句型" class="headerlink" title="动态图句型"></a>动态图句型</h3><p> A increased to XXX(单位) in 2000</p>
<p>There was an obvious decrease/increase in D.</p>
<p>E rose and peaked at XXX(单位) in 1990 before fell significantly to XXX [单位] in 1996</p>
<p>F soared to XXX[单位] in 1993 after a slow increase from 1990 to 1991.</p>
<p>占据  consititue ,  account for , takes up ,  occupies    species 单复数通行</p>
<p>collectively 总体、集体</p>
<p>纯数字，带单位，百分数没有单位</p>
<p>diploma  degree        Bachelor degree</p>
<p>相等</p>
<p>be + amost / around  same with   equal to  ,  similar to  ,  close to</p>
<p>There is no difference between the two in quantitative terms.</p>
<p>倍数</p>
<p>A is twice as big as B</p>
<p>A is twice bigger than B </p>
<p>The percentage of money spent on rent was 20%, which was about twice bigger than taht of clothes.</p>
<p>There was 9% of money spent entertainment, which was similar/close to that of clothes.</p>
<p>多个饼图 动静结合</p>
<ol>
<li><p>数据的变化趋势</p>
<p>参考曲线图</p>
</li>
<li><p>具有代表性的数字</p>
<p>1^st^  2^nd^  last</p>
</li>
<li><p>数字之间的倍数</p>
<p>相等、倍数</p>
</li>
<li><p>Overview</p>
<p>寻找每个饼的overview之间的联系</p>
</li>
</ol>
<p>pie charts </p>
<p>趋势（上升、下降）：  明显的一组 不明显的一组</p>
<p>分段：</p>
<p>总结：多幅图各个击破，找最大的overview；寻找共同点。</p>
<h2 id="表格-table"><a href="#表格-table" class="headerlink" title="表格(table)"></a>表格(table)</h2><p>静态还是动态</p>
<p>​    看情况、曲线图、</p>
<p>表格的主要特点</p>
<p>​    </p>
<p>表格的overview</p>
<p>​    最大的数</p>
<p>横着看，竖着看都有结论</p>
<p>时间按  最早、第二早、最晚。</p>
<p>相关的数据关系。</p>
<p>兼顾纵横</p>
<p>表格作业</p>
<h2 id="地图题"><a href="#地图题" class="headerlink" title="地图题"></a>地图题</h2><h4 id="历史变迁型-difference"><a href="#历史变迁型-difference" class="headerlink" title="历史变迁型(difference)"></a>历史变迁型(difference)</h4><p>Before - After: </p>
<p>difference的角度  <u>数量的变化、面积的变化、位置的变化</u></p>
<p><u>顺序  顺时针，第二幅图 按照第一幅图的顺序</u></p>
<p>基本功：</p>
<p>数量：</p>
<p>0-1修建：build construct</p>
<p>1-0去除：remove demolish</p>
<p>1-2倍数：倍数的表达</p>
<p>位置：</p>
<p>move to, relocate at ,<u>to in</u></p>
<p>面积：area , size </p>
<p>后面这个比前面这个变了很多</p>
<h4 id="规划类-layout"><a href="#规划类-layout" class="headerlink" title="规划类(layout)"></a>规划类(layout)</h4><p>注意比较二者的区别最后得出结论</p>
<p>总而言之，我觉得 …… 更适合 </p>
<h2 id="流程图-Flow-chart"><a href="#流程图-Flow-chart" class="headerlink" title="流程图 Flow chart"></a>流程图 Flow chart</h2><p>Life cycle生命周期</p>
<p>Production物品生产</p>
<p>基本功 ： 找谓语，词汇很关键</p>
<p>产卵spawn  生长发育 thrive</p>
<p>immigrate 人的移民</p>
<p>emmigrate 动物的迁徙  dwell     inhabit栖息</p>
<p>Washing powder</p>
<p>grind / ground   laminate  磨碎</p>
<p>process 处理(加工)</p>
<p>undergo  high temerature</p>
<p>spwan产卵 lay下蛋    thrive , grow   。  grow into 长成  live on 以……为生</p>
<p>knit</p>
<p>First , then , stage/phase , step</p>
<p>intelligible 通俗易懂</p>
<p>总结，产品 的 流程 比较清楚、清晰易懂</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/迷宫问题A*搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/迷宫问题A*搜索/" itemprop="url">
                  A*算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T19:23:57+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/19/迷宫问题A*搜索/" class="leancloud_visitors" data-flag-title="A*算法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h1><h1 id="A-搜索算法"><a href="#A-搜索算法" class="headerlink" title="A*搜索算法"></a>A*搜索算法</h1><blockquote>
<p><a href="http://www.cnblogs.com/mingjiatang/p/5967681.html" target="_blank" rel="external">http://www.cnblogs.com/mingjiatang/p/5967681.html</a></p>
</blockquote>
<h2 id="A-搜索算法简介"><a href="#A-搜索算法简介" class="headerlink" title="A*搜索算法简介"></a>A*搜索算法简介</h2><p>A*搜索算法是一种启发式算法。即在盲目搜索的过程加入一个启发函数，对于当前结点搜索完毕后，使用启发函数对每一个子结点的状态计算代价，选择代价最小的节点作为下一步的搜索节点。通过不断求最优，就可以找到最优解。</p>
<p>DFS，BFS都是属于盲目搜索，选择子结点是根据固定顺序选择，在某些情况下求解会产生大量的冗余步骤。而A*搜索算法会是根据一个启发函数值来判别从哪一个节点继续进行搜索。启发函数的表达形式为：</p>
<p>​                            $f(n)=g(n)+h(n)$ </p>
<p>其中$f(n)$是每个节点的估值或者代价值。$g(n)$表示从起点到搜索点的代价，$h(n)$代表搜索点到目标点的代价，$h(n)$会直接影响到A*算法的效率。</p>
<p>一种具有$f(n)=g(n)+h(n)$的启发式算法能成为A*算法的充分条件是：</p>
<ol>
<li>搜索树上存在从起点到终点的最优路径</li>
<li>问题域有限</li>
<li>所有子结点的搜索代价值都大于0</li>
<li>$h(n)\leq h*(n)$</li>
</ol>
<h2 id="A-搜索算法描述"><a href="#A-搜索算法描述" class="headerlink" title="A*搜索算法描述"></a>A*搜索算法描述</h2><p>A*算法的流程如下：</p>
<p>A*算法需要两个额外的存储空间，OPEN表和CLOSE表。</p>
<ol>
<li>初始化OPEN表和CLOSE表，将开始节点（开始节点的Hvalue和Gvalue都视为0）放入OPEN表中</li>
<li>重复下面步骤(循环)<ol>
<li>在开始列表中查找具有最小Fvalue的节点作为当前节点</li>
<li>把当前节点从OPEN表中删除，并加入到CLOSED表中</li>
<li>对当前节点的每一个相邻节点依次执行以下步骤：<ol>
<li>如果相邻节点不可通行或者该节点已经在CLOSE表中，则什么操作也不执行</li>
<li>如果该相邻节点不在OPEN表中，则将该节点添加到OEPN表中，并<u>将该相邻节点的父节点设置为当前节点</u>，同时计算保存相邻节点的Fvalue</li>
<li>如果该相邻节点在OPEN表中，则判断若经由当前节点到达该相邻节点的Fvalue是否小雨原来保存的Fvalue，若小于则将该相邻节点的父节点设置为当前节点，并重新计算该相邻节点的Fvalue</li>
<li>若当终点节点被加入到OPEN表作为待检验节点时，表示路径已经找到，此时应终止循环；若当OPEN表为空，表示没有从开始节点到终点节点的路径，此时循环结束</li>
</ol>
</li>
</ol>
</li>
<li>循环终止后，从终点节点开始沿父节点往前遍历，从后到前输出搜索路径。</li>
</ol>
<p>其中，设置相邻节点的父节点为当前节点为了记录从起始节点到终止节点的路径，方便搜索路径后对路径进行输出。</p>
<h2 id="A-算法对于八数码问题"><a href="#A-算法对于八数码问题" class="headerlink" title="A*算法对于八数码问题"></a>A*算法对于八数码问题</h2><h3 id="启发式A-算法"><a href="#启发式A-算法" class="headerlink" title="启发式A*算法"></a>启发式A*算法</h3><p>open表：存放所有待扩展的节点</p>
<p>closed表：存放所有已扩展的节点</p>
<p>spring表：存放所有待处理的节点状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;State&gt; open = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//open表</span></div><div class="line">List&lt;State&gt; closed = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">//close表</span></div><div class="line">List&lt;State&gt; spring = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">//spring表</span></div><div class="line"><span class="keyword">int</span> start[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;            <span class="comment">//初始状态数组</span></div><div class="line"><span class="keyword">int</span> goal[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;           <span class="comment">//目标状态数组</span></div><div class="line">State startState = <span class="keyword">new</span> State();         <span class="comment">//初始状态</span></div><div class="line">State goalState = <span class="keyword">new</span> State();          <span class="comment">//目标状态</span></div></pre></td></tr></table></figure>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><p>检查是否有解（逆序数）</p>
<p>将9宫格横向展开，左边的数大于右边的数的组数称为逆序数。横向平移逆序数增量为0、2或-2。纵向平移逆序数增长为0、4或-4。因此，初态和目标态的逆序数和应该是偶数。（即初态逆序奇数、末态逆序也为奇数和为偶数）若不是偶数代表此八数码无解。</p>
</li>
<li><p>初始化open表（存放待扩展的节点）、close表（存放已扩展的节点）、spring表（存放答案）、初始状态、目标状态。</p>
</li>
<li><p>计算初始状态的g、h、f值后，将初始状态加入到open表中</p>
</li>
<li><p>检查问题是否有解</p>
</li>
<li><p>循环()</p>
<ol>
<li><p>在open表中取出一个状态getOfOpen，判断是否是目标状态。是目标状态则结束</p>
</li>
<li><p>将状态getOfOpen加入closed表</p>
</li>
<li><p>将状态getOfOpen产生后继节点</p>
<ol>
<li>获取0的位置，将0进行四个方向移动的尝试，可以则移动。</li>
<li>判断该移动方向得到的结果是否与其前驱节点相似。</li>
<li>不相似创建新的状态点加入到spring中。</li>
</ol>
</li>
<li><p>检查spring表中所有的节点(state)</p>
<p>如果在open表中有相同节点(stateInOpen)。如果state的g值&lt;stateInOpen的g值，则改变open表中(stateInOpen)的参数，并将open表中的状态按gvalue重排。并从spring表删除该节点。</p>
<p>如果在closed表中有相同节点(stateInClosed)，state的g值&lt;stateInClosed的g值，则改变closed表中(stateInClosed)的参数，将stateInClosed加入open表并排序。并从spring表删除该节点</p>
<p>否则将state加入open表，并从spring表中删除该节点</p>
</li>
</ol>
</li>
</ol>
<h3 id="算法空间表示"><a href="#算法空间表示" class="headerlink" title="算法空间表示"></a>算法空间表示</h3><p>状态用一维数组表示，每个节点状态存以一个State对象存储。包括存储Fvalue，Gvalue，Hvalue。对于九宫格按行展开存入数组，用0表示移动位置（空格）。</p>
<h2 id="A-算法对于迷宫问题"><a href="#A-算法对于迷宫问题" class="headerlink" title="A*算法对于迷宫问题"></a>A*算法对于迷宫问题</h2><p>采用A*算法对迷宫路径求解中，$g(n)$和$h(n)$都采用==曼哈顿距离==，曼哈顿距离代表两个点在标准坐标上的绝对轴距总和。<br>$$<br>d(i,j)=|x_1-x_2|+|y_1-y_2|<br>$$<br>即每次获取的当前通道块，都会对其到入口通道块和出口通道开的曼哈顿距离进行计算。求算当前通道块的Fvalue进行保存。该函数满足启发式算法的充分条件1、2、3、4。</p>
<p>对于迷宫问题需要将A*算法进行更改，其中2-3-1，如果相邻节点不可通行或者该节点已经在close表或open表中，则什么也不执行；2-3-2，如果该节点不在open表和close表中，则将该节点添加到open表中，并将该节点的父节点设置为当前节点，同时计算保存相邻节点的$Fvalue$。</p>
<p>在迷宫求解中使用A*搜索算法不需要更新OPEN表中已存在节点的Fvalue，因为每个节点的位置都是确定的，所以曼哈顿九黎就是固定的。如果是带权值的网路求解最短路径，那么就需要去更新open表中节点的$Fvalue$，如$Dijkstra$算法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/Section1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/Section1/" itemprop="url">
                  Listenning notes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T23:49:00+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/17/Section1/" class="leancloud_visitors" data-flag-title="Listenning notes">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Listenning"><a href="#Listenning" class="headerlink" title="Listenning"></a>Listenning</h1><h3 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1"></a>Section 1</h3><ol>
<li><p>租房</p>
<ol>
<li>房租价格（数字，水电气，定金）</li>
<li>地理位置（市区、郊区）</li>
<li>内部设施（厨房）</li>
<li>外部设置（花园、车库和交通状况）</li>
<li>专有名词（房东、租客、地址）</li>
<li>生活习惯（双方的要求）</li>
<li>实地看房（时间）</li>
<li>入住后的问题（complaint）</li>
</ol>
<ul>
<li><p>支付信息：</p>
<p>currency 货币、charge 费用、cost成本、deposit押金</p>
<p>pay by cheque/check, cash, credit card</p>
<p>daliy, weekly, monthly, quarterly, annual basis</p>
</li>
<li><p>地址信息：</p>
<p>road    street    avenue    lane</p>
<p>Pallisades/West Lake Street</p>
<p>city centre = central area    市中心，中心那部分</p>
<p>downtown/urban area    市中心，闹市区</p>
<p>suburb = outskirt            郊区，边缘</p>
<p>country = rural area        农村，乡村</p>
<ul>
<li><p>常考地址</p>
<p>South Street, Market Street, Mills Road, University Drive, Hill Road, Forest Road, Cross Street, Castle Road</p>
</li>
</ul>
</li>
<li><p>参与人物：</p>
<p>房东：landlord/landlady    租户：tenant/occupant    中介：real estate agency   学校：accommodation office    出租：to let    租期：length of let</p>
</li>
<li><p>房屋类型：</p>
<p>homestay寄宿家庭, flat/apartment, student hall, dormitory dorm, halls of residence, b&amp;b</p>
</li>
<li><p>房屋类型和家用设施：</p>
<p>balcony阳台, double room双人间, bathroom, kitchen, garden花园, yard庭院, garage车库, laundry洗衣房, study书房, hall, lobby, porch走廊</p>
<p>fridge电冰箱, microwave微波炉, hairdryer吹风机, toaster烤箱, washing machine洗衣机,air-conditioner空调, heater暖气</p>
</li>
<li><p>家具用品与费用：</p>
<p>pillow, curtain, bed sheet床单, blanket毛毯, mattess床垫, towel毛巾, carpet地毯 rent, deposit押金, phone  bill, gas bill, water/electricity bill, <em><u>share petrol一起支付汽油</u></em>, utilities物业费</p>
</li>
<li><p>complaint</p>
<ul>
<li>not near the center, not near the railway station, far from the bus stop,</li>
<li>near the airport, noisy.</li>
<li>share kitchen</li>
<li>insects</li>
<li>a stranger in the next bed, have no privacy</li>
<li>have to prepare some repellent, insects haunting</li>
</ul>
</li>
<li><p>其他考点</p>
<ul>
<li>个人信息（年龄、性别、国籍、专业）</li>
<li>职业</li>
<li>饮食要求</li>
</ul>
</li>
<li><p>国籍</p>
<p>Australia/Australian</p>
<p>Canada/Canadian</p>
<p>India/Indian</p>
<p>Mexico/Mexican</p>
<p>Scotland/Scottish</p>
<p>Germany/German</p>
</li>
<li><p>职业</p>
<p>engineer, architect, secretary, cook/chef, programmer, technician, manager</p>
</li>
</ul>
</li>
<li><p>银行</p>
<ol>
<li><p>账户：</p>
<p>open an account开户    bank/pass book存折    cheque account支票账户    savings account储蓄账户    current account活期账户    deposit account定期账户    monthly savings account按月计息账户    daily interest account按天计息账户    instant account速成户头  joint account联名账户    expense    account公款支付账户    signature card签名卡    credit card信用卡    cash card现金卡    debit card借记卡    cheque guarantee card支票担保卡</p>
</li>
<li><p>人员：</p>
<p>cashier收银员   teller/clerk银行职员  accountant会计   service charge服务费    commercial/merchant bank商业银行   full refund全额偿还    extension延期   overdraw/overdraft透支   mortgage抵押    rebate回扣  payday发薪日     pay slip/envelop薪水单 a princely sum(an excessive amount)巨款  by installment 分期付款    apply for/grant  a loan 申请/批准贷款  collateral担保物    debt债务  loan贷款  statement对账单  money order汇票 unit货币单位      ounce盎司    penny便士  nickel (美/加)五分硬币  dime(美/加) 十分硬币</p>
</li>
<li><p>交易动作：</p>
<p>deposit存款    draw/withdraw取款  earn interest赚取利息 annual insterest rate年利率    service charge服务费/手续费  cheque book支票簿  cash the check(A.) /cheque(B.)兑现支票 blank cheque空白支票      traveler’s cheque旅行支票  exchange rate汇率 denomination=face value面额  value/worth面值  bill钞票  cash现金  password/code 密码  change零钱  coin硬币 four in hundred四张一百元面额  give the money in fives换成五元面额  fill out/in填写  amount in figures小写金额  amount in words大写金额</p>
</li>
</ol>
</li>
<li><p>图书馆</p>
<ol>
<li><p>图书分类</p>
<p>fiction小说   periodical期刊   journal杂志   current/back issue现刊/过刊brochure小册子,手册   prospectus说明书,章程,简介   leaflet传单   index索引 encyclopedia百科全书   front/back over封面,封底   catalog(ue)目录,目录册   bibliography文献目录,参考书目</p>
</li>
<li><p>借书规则</p>
<p>call slip借单,借书证   library card借书证   loan period借书期   renew续借   due到期   overdue过期   annual fee年费   fine罚款</p>
</li>
<li><p>借阅服务</p>
<p>librarian图书管理员   available可提供的,可借到的   in stock有库存   out an loan 已借出   Closed Reserved关闭预定   interlibrary service馆际互借服务   magnetically coded加过词条的   touch screen information service触摸屏查询台   limited number少数   book/order/reserve 预定   in advance提前   laptop笔记本(portable computer)</p>
</li>
<li><p>常考思路</p>
<ol>
<li><p>办理借书证</p>
<p>五种所需证件：ID card ,  driving licence ,  driver’s license ,  passport photos , bank statement(银行结单，银行对账单), student card</p>
</li>
<li><p>具体内容</p>
<p>A. 开关门时间： 注意周末、节假日等特殊时间</p>
<p>B. 具体情况：借阅量borrowng loads</p>
<p>C.特殊借阅物：CD（Compact Disk）/DVD(Digital Video Disk)/Video</p>
</li>
<li><p>复印</p>
<p>设备：photocopying facilities；photocopier影印机；copy，copier，printer</p>
<p>用纸：A3/A4(5 pence); black&amp;whiter ;  colour;  double sides photocopying</p>
<p>付款方式：by a card/coin</p>
</li>
<li><p>计算机房 computer room</p>
<p>24 hours online service；limited computers；book/reserve a place；24/48hours in advance; book a place for one hour / a timeslot 时间段</p>
</li>
<li><p>不同借阅条件</p>
<p>本校生在本校借：</p>
<p>本校生在外校借：</p>
<p>外校生来本校借：</p>
<p>非学生来本校借：</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/读书笔记《费尔巴》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/读书笔记《费尔巴》/" itemprop="url">
                  读书笔记《关于费尔巴的提纲》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T21:46:14+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/17/读书笔记《费尔巴》/" class="leancloud_visitors" data-flag-title="读书笔记《关于费尔巴的提纲》">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于背景"><a href="#关于背景" class="headerlink" title="关于背景"></a>关于背景</h3><p>1845 年 2 月，马克思被法国政府驱逐，离开巴黎来到布鲁塞尔。在这里，他重读了费尔巴哈的著作，自觉意识到他的世界观与包括费尔巴哈在内的旧唯物主义有了重大的、本质的区别，在笔记本上写下了供进一步研究用的 《关于费尔巴哈的提纲》,共十一条。</p>
<h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><ol>
<li>旧唯物主义的立脚点是“市民”社会，新唯物主义的立脚点则是人类社会或社会化的人类。</li>
<li>人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题。人应该在实践中证明自己思维的真理性，即自己思维的现实性和力量，自己思维的此岸性。</li>
<li>从前的一切唯物主义（包括费尔巴哈的唯物主义）的主要缺点是：对对象、现实、感性，只是从客体的或者直观的形式去理解，而不是把它们当作感性的人的活动，当作实践去理解，不是从主体方面去理解。因此，和唯物主义相反，能动的方面却被唯心主义抽象地发展了，但只是抽象地发展了，因为唯心主义当然是不知道现实的、感性的活动本身的。</li>
<li>全部社会生活在本质上是实践的。凡是把理论引向神秘主义的神秘东西，都能在人的实践中以及对这个实践的理解中得到合理的解决。</li>
<li>直观的唯物主义，即不是把感性理解为实践活动的唯物主义至多也只能达到对单个人和市民社会的直观。</li>
<li>环境的改变和人的活动或自我改变的一致，只能被看作是并合理地理解为革命的实践。</li>
<li>费尔巴哈是从宗教上的自我异化，从世界被二重化为宗教的、想象的世界和现实的世界这一事实出发的。他做的工作是把宗教世界归结于它的世俗基础。他没有注意到，在做完这一工作之后，主要的事情还没有做。因为，世俗基础使自己从自身中分离出去，并在云霄中固定为一个独立王国，这一事实，只能用这个世俗基础的自我分裂和自我矛盾来说明。因此，对于这个世俗基础本身首先应当从它的矛盾中去理解，然后用消除矛盾的方法在实践中使之发生革命</li>
</ol>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>摘录1：《提纲》中，马克思将自己的哲学称为新唯物主义。新唯物主义的落脚点是“人类社会或社会化的人类”，而旧唯物主义的落脚点是“市民”社会。市民社会应该指的是资本主义的社会与市场的关系，而社会化的人类或人类社会指社会主义社会和市场。</p>
<p>摘录3：《提纲》通过对费尔巴哈的清算，将包括费尔巴哈等的以前的唯物主义作为批评对象。阐述了费尔巴哈旧唯物主义忽视人的主观能动性和唯心主义夸大主观能动性的错误。将马克思的思想从新的角度，阐明以实践为基础的新唯物主义哲学与旧唯物主义和唯心主义的区别。从而反映出实践是马克思主义哲学与旧哲学的根本观点。</p>
<p>摘录2、4：实践是检验真理的标准。人的认识、人的思维是否正确，只有在实践中才能证明。检验真理的标准不是主观的理念或者客观的事物，应该从实践中出发去鉴别真理。真理是人们的主观认识对客观世界的评判，而实践对联系主观与客观举足轻重。离开实践去探讨人的思维是否正确毫无意义。</p>
<p>摘录5、6:  新唯物主义的主要价值与思想在于通过实践改造实际。它认为全部的生活本质上是实践的。通过指导无产阶级通过革命去改造世界，改变不合理的制度。即通过实践认知并改变世界。</p>
<p>摘录7：马克思认为费尔巴哈的宗教观有错误，并阐述了宗教产生的社会根源，由于“世俗基础的自我分裂和自我矛盾”，才产生了人对自然的恐惧和对神的依赖。消除的办法是，对世俗基础实践改造，消灭人与人之间的矛盾。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a strive programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("KzDP5NgGACc0bKLgfEtJ8Xrk-gzGzoHsz", "nGixqUVUQJjtTFuvDaoKrMo0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

  

  

  

</body>
</html>
