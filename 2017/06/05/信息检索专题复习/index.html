<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="信息检索,复习," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="信息检索Made by ® Isaac. Ty  信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型 IR新课题 自然语言理解 多媒体检索 垂直检索技术 移动搜索 对社会媒体信息检索 问答 知识发现 行为分析、舆情控制 自动对话  2.布尔检索信息检索模型概述定义文档表示一个文档被表示为关键词(bag of words)的集合 查询表示查询式（Queries）被表示为关">
<meta name="keywords" content="信息检索,复习">
<meta property="og:type" content="article">
<meta property="og:title" content="信息检索专题复习">
<meta property="og:url" content="http://yoursite.com/2017/06/05/信息检索专题复习/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="信息检索Made by ® Isaac. Ty  信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型 IR新课题 自然语言理解 多媒体检索 垂直检索技术 移动搜索 对社会媒体信息检索 问答 知识发现 行为分析、舆情控制 自动对话  2.布尔检索信息检索模型概述定义文档表示一个文档被表示为关键词(bag of words)的集合 查询表示查询式（Queries）被表示为关">
<meta property="og:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png">
<meta property="og:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E9%87%87%E9%9B%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%AF%B9%E6%95%B0%E9%A2%91%E7%8E%87.png">
<meta property="og:updated_time" content="2017-06-23T03:11:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="信息检索专题复习">
<meta name="twitter:description" content="信息检索Made by ® Isaac. Ty  信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型 IR新课题 自然语言理解 多媒体检索 垂直检索技术 移动搜索 对社会媒体信息检索 问答 知识发现 行为分析、舆情控制 自动对话  2.布尔检索信息检索模型概述定义文档表示一个文档被表示为关键词(bag of words)的集合 查询表示查询式（Queries）被表示为关">
<meta name="twitter:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/05/信息检索专题复习/"/>





  <title> 信息检索专题复习 | Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/信息检索专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                信息检索专题复习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T19:27:51+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/05/信息检索专题复习/" class="leancloud_visitors" data-flag-title="信息检索专题复习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h1><p>Made by ® Isaac. Ty </p>
<p>信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型</p>
<h4 id="IR新课题"><a href="#IR新课题" class="headerlink" title="IR新课题"></a>IR新课题</h4><ul>
<li>自然语言理解</li>
<li>多媒体检索</li>
<li>垂直检索技术</li>
<li>移动搜索</li>
<li>对社会媒体信息检索</li>
<li>问答</li>
<li>知识发现</li>
<li>行为分析、舆情控制</li>
<li>自动对话</li>
</ul>
<h2 id="2-布尔检索"><a href="#2-布尔检索" class="headerlink" title="2.布尔检索"></a>2.布尔检索</h2><h3 id="信息检索模型概述"><a href="#信息检索模型概述" class="headerlink" title="信息检索模型概述"></a>信息检索模型概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="文档表示"><a href="#文档表示" class="headerlink" title="文档表示"></a>文档表示</h5><p>一个文档被表示为<strong><u>关键词</u></strong>(bag of words)的集合</p>
<h5 id="查询表示"><a href="#查询表示" class="headerlink" title="查询表示"></a>查询表示</h5><p>查询式（Queries）被表示为<strong><u>关键词的布尔组合</u></strong>，用“与、或、非”连接起来（主析取范式）</p>
<h5 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h5><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是二值匹配</li>
</ul>
<h5 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h5><p>没有清晰和明显的语义结构的数据，计算机不易处理这些数据</p>
<h5 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h5><p>最典型的时关系数据库，用来保存公司的产品清单和人事记录</p>
<h5 id="聚类（clustering）"><a href="#聚类（clustering）" class="headerlink" title="聚类（clustering）"></a>聚类（clustering）</h5><p>基于文档内容进行自动聚团的任务。很像在书架上将一系列书按照它们所属的主题重新摆放的过程。</p>
<h5 id="分类（classification）"><a href="#分类（classification）" class="headerlink" title="分类（classification）"></a>分类（classification）</h5><p>根据<strong><u>给定的主题</u></strong>、固定的信息需求或者其他类别体系，将每一个文档分到一个或多个类别的任务。</p>
<h4 id="布尔模型：优缺点"><a href="#布尔模型：优缺点" class="headerlink" title="布尔模型：优缺点"></a>布尔模型：优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>查询<strong>简单</strong>，容易理解</li>
<li>通过使用复杂的布尔表达式，可方便地控制查询结果</li>
<li>相当有效的实现方法</li>
<li>经过某种训练的用户可以容易地写出布尔查询式</li>
<li>布尔模型可以通过扩展来包含排序的功能</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><strong>弱</strong>，不支持部分匹配，完全匹配会导致结果太多或太少</li>
<li>非常<strong>刚性</strong>：“与”意味着全部；“或”意味着任何一个，所有匹配文档都将被返回</li>
<li>不考虑索引词的权重，所有文档都以相同的方式和查询相匹配</li>
<li>很难进行自动的相关反馈</li>
</ul>
<h4 id="信息检索的基本假设"><a href="#信息检索的基本假设" class="headerlink" title="信息检索的基本假设"></a>信息检索的基本假设</h4><ul>
<li>集合：固定数量的文档</li>
<li>目标：找到与用户信息需求相关的含有信息量的文档，帮助用户完成一个任务。</li>
</ul>
<h4 id="典型的搜索模型"><a href="#典型的搜索模型" class="headerlink" title="典型的搜索模型"></a>典型的搜索模型</h4><ul>
<li><strong>构造矩阵→信息需求→文字形式→查询→查询优化→结果</strong></li>
</ul>
<h4 id="返回文档的好坏"><a href="#返回文档的好坏" class="headerlink" title="返回文档的好坏"></a>返回文档的好坏</h4><h5 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h5><p>返回的能满足用户信息需求的文档占<strong>总的返回文档</strong>的百分比</p>
<h5 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h5><p>返回的能满足用户信息需求的文档占<strong>总的能满足用户信息需求的文档</strong>的百分比</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><ul>
<li>对于每一个词项，存储所有包含这个词项的文档的一个<u><strong>列表</strong></u>。一个文档用一个<strong><u>序列号</u></strong>docID来表示</li>
<li>应当使用可变长度的记录表<ul>
<li>在硬盘上，一串连续的记录是正常的，也是最好的</li>
<li>在内存里，可以使用链表，或者可变长度的数组</li>
</ul>
</li>
</ul>
<h4 id="倒排索引建立步骤"><a href="#倒排索引建立步骤" class="headerlink" title="倒排索引建立步骤"></a>倒排索引建立步骤</h4><ol>
<li>收集需要建立索引的文档</li>
<li>将每篇文档转换成一个个词条（token）的列表，此个过程称为词条化（tokenization)</li>
<li>进行语言预处理，产生归一化的词条来作为词项</li>
<li>对所有文档按照其中出现的词项来建立倒排索引，索引中包括一部分词典和一个全体倒排索引表</li>
</ol>
<ul>
<li>词条序列Token Sequence</li>
</ul>
<p>（修改过的词条，文档ID）对序列</p>
<ul>
<li><p>排序</p>
<p>先按照词条排序，再按照docID排序</p>
</li>
<li><p>词典和倒排表</p>
<ul>
<li>同一篇文档中多次出现的词被合并</li>
<li>分割成<strong>词典</strong>和<strong>倒排表</strong></li>
<li>词汇的<strong><u>文档频率</u></strong>也被记录</li>
</ul>
</li>
<li><p>查询的处理:AND</p>
<ul>
<li>考虑这样的查询： Brutus AND Caesar<ul>
<li>在字典中找到Brutus，得到它的倒排记录表</li>
<li>在字典中找到Caesar，得到它的倒排记录表</li>
<li>合并两个倒排列表</li>
<li>同时扫描两个倒排记录表求交集，所需时间和倒排记录的数量呈线性关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="布尔检索模型"><a href="#布尔检索模型" class="headerlink" title="布尔检索模型"></a>布尔检索模型</h3><h4 id="文档表示-1"><a href="#文档表示-1" class="headerlink" title="文档表示"></a>文档表示</h4><p>一个文档被表示为关键词的集合</p>
<h4 id="查询表示-1"><a href="#查询表示-1" class="headerlink" title="查询表示"></a>查询表示</h4><p>查询式(Queries)被表示为<strong>关键词的布尔组合</strong>，用“与、或、非”连接起来(主析取范式DNF)</p>
<h4 id="相关度计算-1"><a href="#相关度计算-1" class="headerlink" title="相关度计算"></a>相关度计算</h4><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是<strong>二值匹配</strong>{0,1}</li>
</ul>
<h4 id="形式化表示"><a href="#形式化表示" class="headerlink" title="形式化表示"></a>形式化表示</h4><ol>
<li>定义：用q~dnf~ 表示查询q的析取范式，q~cc~表示q~dnf~的任意合取分量</li>
<li>文献d~j~与查询q的相似度为</li>
</ol>
<h4 id="布尔检索模型：布尔代数"><a href="#布尔检索模型：布尔代数" class="headerlink" title="布尔检索模型：布尔代数"></a>布尔检索模型：布尔代数</h4><h5 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h5><ul>
<li>只有“真”、“假”取值的变量</li>
</ul>
<h5 id="布尔操作（关系）"><a href="#布尔操作（关系）" class="headerlink" title="布尔操作（关系）"></a>布尔操作（关系）</h5><h5 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h5><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>布尔模型可以用来处理布尔表达式形式的查询</p>
<ul>
<li>布尔查询使用AND,OR和NOT来连接查询词汇<ul>
<li>将文档看作词汇的集合</li>
<li>精确：匹配或不匹配</li>
</ul>
</li>
<li>布尔模型式IR系统中最简单的模型</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul>
<li>按照文档频率的顺序进行处理。先处理文档频率小的，再处理大的。</li>
</ul>
<h2 id="3-词项词典和倒排记录表"><a href="#3-词项词典和倒排记录表" class="headerlink" title="3.词项词典和倒排记录表"></a>3.词项词典和倒排记录表</h2><h3 id="建立词项词典"><a href="#建立词项词典" class="headerlink" title="建立词项词典"></a>建立词项词典</h3><h4 id="文档解析"><a href="#文档解析" class="headerlink" title="文档解析"></a>文档解析</h4><ul>
<li>文档格式</li>
<li>文档中的语言</li>
<li>文档的编码方式</li>
</ul>
<h4 id="词条化"><a href="#词条化" class="headerlink" title="词条化"></a>词条化</h4><ul>
<li><p>将给定的字符序列拆分成一系列子序列的过程，其中每一个子序列称之为一个“词</p>
<p>条”Token。</p>
</li>
<li><p>词条(Tokens)、词项(Terms)</p>
</li>
<li><p>针对不同的语言，采用不同策略的词条化方法</p>
</li>
<li><p>分词的基本方法：</p>
<ul>
<li>基于词典的最大匹配法</li>
<li>机器学习方法</li>
</ul>
</li>
</ul>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><ul>
<li>停用词表：将词项按照<strong>文档集频率</strong>，从高到低排列。选取与文档意义不大，<strong>高频</strong>出现的词，例如a ,an , the , and, ….</li>
<li>优点：停用词消除可以减少term的个数</li>
<li>缺点：有时消除的停用词对检索有意义的 。 的士 ， to be or not to be</li>
<li>消除方法：查表法，基于文档频率</li>
</ul>
<h4 id="词项归一化"><a href="#词项归一化" class="headerlink" title="词项归一化"></a>词项归一化</h4><ul>
<li>将不完全一致的多个词条归纳成一个等价类，以便在它们之间进行匹配。</li>
<li>归一化结果：在IR系统的词项词典中，形成多个<strong>近似词项的一个等价类</strong></li>
<li>归一化策略：建立同义词扩展表</li>
</ul>
<h4 id="词干还原"><a href="#词干还原" class="headerlink" title="词干还原"></a>词干还原</h4><ul>
<li><strong>很粗略的去除单词两端的词缀的启发式过程</strong></li>
<li>能提高召回率，但是会降低准确率</li>
<li>porter算法</li>
</ul>
<h4 id="词形归并"><a href="#词形归并" class="headerlink" title="词形归并"></a>词形归并</h4><ul>
<li>利用词汇表和词形分析来减少曲折变化的形式，将其转变为基本形式 </li>
<li>词形归并可以减少词项词典中的词项数量</li>
</ul>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>词干还原在一般情况下会将多个派生相关词合并在一起</li>
<li>词形归并通常只将同一词元的不同曲折形式进行合并</li>
</ul>
<h3 id="实现倒排记录表"><a href="#实现倒排记录表" class="headerlink" title="实现倒排记录表"></a>实现倒排记录表</h3><h4 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h4><ul>
<li>通过在两个倒排表之间同时移动指针来实现合并，此时的操作与线性表的总数成线性关系。</li>
</ul>
<h4 id="基于调表的倒排记录表快速合并算法"><a href="#基于调表的倒排记录表快速合并算法" class="headerlink" title="基于调表的倒排记录表快速合并算法"></a>基于调表的倒排记录表快速合并算法</h4><ul>
<li>跳表指针能够跳过那些不可能出现在检索结果中的记录项</li>
<li>如果倒排表的长度是L，那么在每个$\sqrt L$处均放置跳表指针</li>
<li>跳表指针只对AND类型查询有用，对OR类型查询不起作用</li>
</ul>
<h4 id="短语查询"><a href="#短语查询" class="headerlink" title="短语查询"></a>短语查询</h4><h5 id="二元词索引"><a href="#二元词索引" class="headerlink" title="二元词索引"></a>二元词索引</h5><ul>
<li>将文档中每个连续词对看成一个短语，其中的每个二元词对豆浆作为词典中的词项。</li>
</ul>
<h5 id="扩展的二元词索引"><a href="#扩展的二元词索引" class="headerlink" title="扩展的二元词索引"></a>扩展的二元词索引</h5><h5 id="位置信息索引"><a href="#位置信息索引" class="headerlink" title="位置信息索引"></a>位置信息索引</h5><ul>
<li><p>在此索引中，对每个词项，都采取以下方式存储倒排表记录：</p>
<p> &lt;词项，词项频率;</p>
<p>   文档1：位置1，位置2，……</p>
<p>   文档2：位置1，位置2，……</p>
</li>
</ul>
<h2 id="4-索引构建"><a href="#4-索引构建" class="headerlink" title="4.索引构建"></a>4.索引构建</h2><h3 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h3><h3 id="语资料库"><a href="#语资料库" class="headerlink" title="语资料库"></a>语资料库</h3><h3 id="索引构建算法"><a href="#索引构建算法" class="headerlink" title="索引构建算法"></a>索引构建算法</h3><h4 id="基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）"><a href="#基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）" class="headerlink" title="基于块的排序索引算法（BSBI：Blocked sort-based Indexing）"></a>基于块的排序索引算法（BSBI：Blocked sort-based Indexing）</h4><ul>
<li>在索引构建过程中需要依次分析所有的文档，不能很容易利用压缩技巧。只有分析完所有文档，最终的倒排记录表才会完整。</li>
</ul>
<ul>
<li>基本思想：对每一个<strong>块</strong>都生成倒排记录，并排序，写入硬盘。然后将这些块<strong>合并</strong>成一个长的排好序的倒排记录。</li>
<li>每条数据占用12字节（4+4+4）（词项，文档，频数）</li>
<li>在内存中处理，累积放满固定的块，排序后写入硬盘f~i~ ，合并所有索引文件成一个</li>
</ul>
<h5 id="基于BSBI排序算法存在的问题"><a href="#基于BSBI排序算法存在的问题" class="headerlink" title="基于BSBI排序算法存在的问题"></a>基于BSBI排序算法存在的问题</h5><ul>
<li>假设能够将<strong><u>词典存入内存</u></strong>中</li>
<li>需要该词典动态增长去查找任一词项和词项ID之间的对应关系。</li>
<li>（一个可扩展的，但效率非常低的构建索引算法）</li>
</ul>
<h4 id="内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing"><a href="#内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing" class="headerlink" title="内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)"></a>内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)</h4><ul>
<li><p>核心思想：为每个块<strong>单独</strong>生成一个词典—— （不需要维护全局的&lt;词项,词项ID&gt;映射表）</p>
</li>
<li><p><strong>不进行排序</strong>。有新的&lt;词项,文档ID&gt;对时直接在倒排记录表中增加一项。</p>
<ul>
<li>可以为每个块生成一个完整的倒排索引，然后将这些单独的索引合并为一个大的索引</li>
</ul>
</li>
<li>压缩技术将会使SPIMI算法更加高效<ul>
<li>压缩词项</li>
<li>压缩倒排记录表</li>
</ul>
</li>
</ul>
<h4 id="分布式索引构建（Distributed-indexing）"><a href="#分布式索引构建（Distributed-indexing）" class="headerlink" title="分布式索引构建（Distributed indexing）"></a>分布式索引构建（Distributed indexing）</h4><ul>
<li><p>Web规模的索引构建</p>
<p>必须使用一个分布式的计算机集群</p>
</li>
<li><p>计算机都是故障频发的</p>
<ul>
<li>可能会在任意时刻失效</li>
</ul>
</li>
<li><p>利用集群中的主控节点来指挥索引构建工作</p>
<ul>
<li>认为主控节点是“安全的”</li>
</ul>
</li>
<li><p>将索引构建过程<strong>分解</strong>成一组并行的任务</p>
</li>
<li><p>主控计算机从集群中选取一台空闲的机器并将<strong>任务分配</strong>给它</p>
</li>
<li><p>采用两组不同的并行任务</p>
<ul>
<li><p>Parsers分析器</p>
<ol>
<li><p>主节点将一个数据片分配给一台空闲的分析服务器</p>
</li>
<li><p>分析器依次读取文档并生成&lt;词项,文档&gt;对。</p>
</li>
<li><p>分析器将这些&lt;词项,文档&gt;按照<em><strong>词项对</strong></em>分成$j$个段</p>
</li>
<li><p>每一段是按照词项首字母划分的一个区间。</p>
<p>例如：a-f,g-p,q-z 这里j=3</p>
</li>
<li><p>然后进行索引的倒排</p>
</li>
</ol>
</li>
<li>Inverters倒排器<ol>
<li><strong><em>对于一个词项分区</em></strong>，倒排器收集所有的&lt;词项,文档&gt;对（倒排记录）。</li>
<li>排序，并写入最终的倒排记录表。</li>
</ol>
</li>
</ul>
</li>
<li><p>首先，将输入文档集分割成n个数据片</p>
<ul>
<li>每个数据片就是一个文档子集（与BSBI/SPIMI算法中的数据块相对应）</li>
<li>两种分割方法<ul>
<li>基于词项的分割</li>
<li>基于文档的分割</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="数据流图"></p>
</li>
</ul>
<h3 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h3><h4 id="动态索引构建方法"><a href="#动态索引构建方法" class="headerlink" title="动态索引构建方法"></a>动态索引构建方法</h4><p>文档集通常不是静态的</p>
<ul>
<li>文档会不断的加入进来</li>
<li>文档也会被删除或者被修改</li>
</ul>
<p>词典和倒排记录表需要修改</p>
<ul>
<li>对于已在词典中的词项更新倒排记录</li>
<li>新的词项加入到词典中</li>
</ul>
<ol>
<li>周期性索引重构</li>
</ol>
<ul>
<li>建立索引的同时，旧索引继续工作</li>
<li>条件<ul>
<li>更新次数不是很多</li>
<li>能够接受对新文档检索的一定延迟（重构之前新文档检索不到）</li>
<li>有足够的资源进行重构</li>
</ul>
</li>
</ul>
<ol>
<li>维护一个大的主索引<ul>
<li>新文档信息存储在一个小的<strong>辅助索引</strong>中（位于内存）</li>
<li>检索可以同时遍历两个索引并将结果<strong>合并</strong></li>
<li>删除<ul>
<li>文档的删除记录在一个<strong>无效位向量</strong>中</li>
<li>在返回结果前利用它过滤掉已删除文档</li>
</ul>
</li>
<li>定期地将辅助索引合并到主索引中</li>
<li>文档更新通过先删除后插入的方式实现</li>
</ul>
</li>
</ol>
<h4 id="主索引与辅助索引存在的问题"><a href="#主索引与辅助索引存在的问题" class="headerlink" title="主索引与辅助索引存在的问题"></a>主索引与辅助索引存在的问题</h4><ul>
<li>频繁的合并带来很大开销</li>
<li>合并过程效率低<ul>
<li>如果每个词项的倒排记录表都单独成一个文件，那么合并主索引和辅助索引将会很高效。</li>
<li>合并是一个简单的添加操作</li>
<li>需要使用很多倒排文件—— 对文件系统来说是低效的</li>
</ul>
</li>
</ul>
<h4 id="对数合并"><a href="#对数合并" class="headerlink" title="对数合并"></a>对数合并</h4><ul>
<li>维护一系列索引$I_0, I_1 , I_2, … ,$每个都是前一个的两倍大小</li>
<li>辅助索引$Z_0$存储在内存中，而较大的（$I_0, I_1 , I_2, … ,$）存储在磁盘中</li>
<li>当$Z_0$达到上限时，将它写入磁盘$I_0$中，当下一次达到上限时，它会和$I_0$合并，生成$Z_1$<ul>
<li>此时，如果$I1$不存在，存储到$I1$中</li>
<li>如果$I1$已存在，则$Z1$与$I1$合并成$Z2 $(大小$2^{2*n}$)</li>
<li>此时，如果$I2$不存在，存储到$I2$中</li>
<li>如果$I2$已存在，则$Z2$与$I2$合并成Z3 (大小$2^{2*n}$)</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="4-索引压缩"><a href="#4-索引压缩" class="headerlink" title="4.索引压缩"></a>4.索引压缩</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>节省磁盘空间</li>
<li>提高内存的利用率（加快速度）</li>
<li>加快数据从磁盘到内存的传输速度<ul>
<li>[读取压缩数据][解压缩] 比直接 [读取未压缩的数据]快</li>
<li>前提：解压缩算法要很快</li>
</ul>
</li>
</ul>
<h4 id="压缩倒排索引的原因"><a href="#压缩倒排索引的原因" class="headerlink" title="压缩倒排索引的原因"></a>压缩倒排索引的原因</h4><ul>
<li>词典<ul>
<li>压缩的足够小以便放入内存中</li>
<li>当词典足够小时，也可以在内存中存储一部分倒排索引记录表</li>
</ul>
</li>
<li>倒排记录文件<ul>
<li>减少所需要的磁盘空间</li>
<li>减少从磁盘读取倒排记录文件所需的时间</li>
<li>大的搜索引擎在内存中存储了很大一部分倒排记录表<ul>
<li>压缩可以在内存中存储的更多</li>
</ul>
</li>
</ul>
</li>
<li>将涉及各种基于IR系统的压缩架构</li>
</ul>
<h3 id="词项统计量"><a href="#词项统计量" class="headerlink" title="词项统计量"></a>词项统计量</h3><h3 id="词典压缩"><a href="#词典压缩" class="headerlink" title="词典压缩"></a>词典压缩</h3><h4 id="有损压缩和无损压缩"><a href="#有损压缩和无损压缩" class="headerlink" title="有损压缩和无损压缩"></a>有损压缩和无损压缩</h4><ul>
<li>无损压缩：压缩之后所有原始信息都被保留<ul>
<li>在IR系统中常采用无损压缩</li>
</ul>
</li>
<li>有损压缩：丢掉一些信息</li>
<li>一些<strong>预处理步骤可以看成是有损压缩</strong>：大小写转化，停用词剔除，词干还原，数字去除等</li>
<li>有损还是无损与需求相关</li>
</ul>
<h4 id="Heaps定律：M-kT-b"><a href="#Heaps定律：M-kT-b" class="headerlink" title="Heaps定律：M=kT^b^"></a>Heaps定律：M=kT^b^</h4><ul>
<li>M是<strong>词项</strong>的数目，T是文档集中<strong>词条</strong>的个数</li>
<li>词汇量大小M和文档集大小T在对数空间存在斜率为1/2的线性关系。</li>
<li><strong>不同单词的数目与文本篇幅之间存在幂函数的关系</strong>，其幂指数小于1</li>
<li><strong>提供了对文档集中词汇量的估计</strong></li>
</ul>
<h4 id="Zipf定律"><a href="#Zipf定律" class="headerlink" title="Zipf定律"></a>Zipf定律</h4><ul>
<li><strong>词项在文档中的分布情况</strong></li>
</ul>
<ul>
<li>排名<strong>第i多</strong>的词项的文档集频率与1/i成正比</li>
<li>词项t~i~在文档集中出现的次数</li>
<li><strong>高频词项很少，低频罕见词项很多</strong></li>
</ul>
<h4 id="为什么要压缩词典"><a href="#为什么要压缩词典" class="headerlink" title="为什么要压缩词典"></a>为什么要压缩词典</h4><ul>
<li>搜索从词典开始</li>
<li>想将词典放入内存中和其他应用程序共享内存资源</li>
<li>手机或者嵌入式设备通常只有很小的内存</li>
<li>即使不在内存中，也希望足够小以便搜索能够快速启动</li>
</ul>
<h4 id="压缩词项列表：将词典看成单一字符串"><a href="#压缩词项列表：将词典看成单一字符串" class="headerlink" title="压缩词项列表：将词典看成单一字符串"></a>压缩词项列表：将词典看成单一字符串</h4><ul>
<li>将所有词项存储为一个长字符串<ul>
<li>指向下一词项的指针同时也标识着当前词项的结束</li>
<li>期望节省60%词典空间</li>
</ul>
</li>
</ul>
<h4 id="按块存储（Blocking）"><a href="#按块存储（Blocking）" class="headerlink" title="按块存储（Blocking）"></a>按块存储（Blocking）</h4><ul>
<li>每k个词项分词一块，只保留第一个指针</li>
<li>需要存储词项长度（额外一字节）</li>
</ul>
<h4 id="前端编码"><a href="#前端编码" class="headerlink" title="前端编码"></a>前端编码</h4><ul>
<li>按照词典顺序排列的连续词项之间往往具有<strong>公共前缀</strong></li>
<li>（块内k个词项的最后k-1个）</li>
</ul>
<h3 id="倒排记录表压缩"><a href="#倒排记录表压缩" class="headerlink" title="倒排记录表压缩"></a>倒排记录表压缩</h3><ul>
<li>倒排记录表远大于词典，至少10倍</li>
<li>紧密地存储每一个倒排记录表</li>
<li>每个倒排记录用<strong>文档ID</strong>来定义</li>
</ul>
<h4 id="倒排记录表：相反的两点"><a href="#倒排记录表：相反的两点" class="headerlink" title="倒排记录表：相反的两点"></a>倒排记录表：相反的两点</h4><ul>
<li>像“arachnocentric”这样的词项可能在一百万 个文档中才会出现一次 可以用log21M ≈ 20 bits来存储这一倒排记录。</li>
<li>像“the”这样的词项在每个文档中都会出现， 所以对它采用20bit/倒排记录太浪费了。<ul>
<li>这种情况更希望是0/1的bit向量<h4 id="倒排记录表项中文档ID的间距（GAP）"><a href="#倒排记录表项中文档ID的间距（GAP）" class="headerlink" title="倒排记录表项中文档ID的间距（GAP）"></a>倒排记录表项中文档ID的间距（GAP）</h4></li>
</ul>
</li>
<li>按照文档ID的递增顺序来存储一个词项的倒排列表<ul>
<li>Computer： 33，47，154，159，202，…</li>
</ul>
</li>
<li>可以存储间距<ul>
<li>33，14，107，5，43，…</li>
</ul>
</li>
<li>期望：绝大多数间距存储空间都远小于20bit</li>
</ul>
<h4 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h4><ul>
<li>目标：<ul>
<li>对于arachnocentric，使用20bit/间距项</li>
<li>对于the，使用1 bit/间距项</li>
</ul>
</li>
<li>如果词项的评价间距为G，我们想使用log2Gbit/间距项</li>
<li>关键问题：需要利用整个字节对每个间距编码<ul>
<li>可变长度编码：对一些小数字用短码来实现</li>
</ul>
</li>
<li>可变字节码：<ul>
<li>用一个字节来存储G，并分配1bit作为延续位</li>
<li>G$\le$127 对7位有效码采用二进制编码并设置延续位c=1（结束)</li>
<li>G$&gt;$127 则先对G低阶的7位编码，然后采用相同的算法用额外字节对高阶bit位进行编码</li>
<li>设置最后一个字节的延续位为1（c=1)，其他字节的c=0（未结束）</li>
</ul>
</li>
</ul>
<h2 id="5-Web搜索"><a href="#5-Web搜索" class="headerlink" title="5.Web搜索"></a>5.Web搜索</h2><h3 id="Web搜索基础"><a href="#Web搜索基础" class="headerlink" title="Web搜索基础"></a>Web搜索基础</h3><h4 id="重复文档"><a href="#重复文档" class="headerlink" title="重复文档"></a>重复文档</h4><ul>
<li>完全复制Duplication ： 可以通过指纹（fingerprints）来检测精确匹配</li>
<li>近似重复Near-Duplication：通过编辑距离计算语法上的相似性</li>
</ul>
<h4 id="相似性计算"><a href="#相似性计算" class="headerlink" title="相似性计算"></a>相似性计算</h4><ul>
<li>搭叠Shingles（N元词N-Grams）<ul>
<li>给定正整数K及文档d的一个词项序列可以定义文档d的k-shingle为d中所有k个连续词项构成的序列</li>
</ul>
</li>
<li>Jaccard系数：衡量重复度<ul>
<li>表示公式： 交集 / 并集</li>
<li>计算所有文档对之间搭叠的<strong>精确交集</strong>非常费时而且难以处理</li>
<li>使用冲Shingles中选出一个<strong>子集</strong>（素描sketch）来近似计算（抽样Sample）</li>
</ul>
</li>
</ul>
<h4 id="小结：近似重复检测"><a href="#小结：近似重复检测" class="headerlink" title="小结：近似重复检测"></a>小结：近似重复检测</h4><ul>
<li>Shingle算法的核心思想是将<strong>文件相似性</strong>问题转换为<strong>集合的相似</strong>性问题</li>
<li>数量较大时，对Shingle集合进行<strong>抽样</strong>，以降低空间和时间计算复杂性</li>
<li>shingle取样三种方法：Min-Wise,Modm,Mins</li>
</ul>
<h3 id="Web采集"><a href="#Web采集" class="headerlink" title="Web采集"></a>Web采集</h3><h4 id="采集器"><a href="#采集器" class="headerlink" title="采集器"></a>采集器</h4><ol>
<li>从已知种子URL开始</li>
<li>获取页面并解析<ol>
<li>提取页面中包含的链接</li>
<li>将链接放入URL队列</li>
</ol>
</li>
<li>对队列中的URL转2</li>
</ol>
<h5 id="采集器必须具有的功能"><a href="#采集器必须具有的功能" class="headerlink" title="采集器必须具有的功能"></a>采集器必须具有的功能</h5><ul>
<li>礼貌性：Web服务器有显示或隐式的策略控制采集器的访问</li>
<li>鲁棒性：能从采集器陷阱中跳出，能处理Web服务器的其他恶意行为</li>
<li>分布式：可以在多台机器上分布运行</li>
<li>可扩展性：添加更多机器后采集效率应该提高</li>
<li>性能和效率：充分利用不同的系统资源，包括处理器、存储器和网络带宽</li>
<li>新鲜度：对原来爬取的网页进行更新</li>
<li>功能可扩展性：支持多方面的功能扩展，例如处理新的数据格式、抓取新的协议。</li>
</ul>
<h4 id="采集器基本架构"><a href="#采集器基本架构" class="headerlink" title="采集器基本架构"></a>采集器基本架构</h4><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E9%87%87%E9%9B%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="采集器"></p>
<h4 id="Web-图"><a href="#Web-图" class="headerlink" title="Web 图"></a>Web 图</h4><h5 id="Web-→Web图"><a href="#Web-→Web图" class="headerlink" title="Web →Web图"></a>Web →Web图</h5><ul>
<li>将静态Web看成静态HTML网页通过超链接互相连接而成的有向图，其中每个<strong>网页</strong>是<strong>图的顶点</strong>，而每个超链接式图的<strong>有向边</strong>。</li>
<li>该有向图可能不是一个强连通图，即从一个网页出发，沿着超链接前进，有可能永远不会到达另外某个网页</li>
<li><strong>指向</strong>某个网页的链接称为 <strong><u>入链接</u></strong>（in-link)，而从某个网页指出去的链接称为<strong><u>出链接</u></strong>（out-link）。</li>
<li>入度：网页的入链数目。  出度：网页的出链数目</li>
</ul>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><ul>
<li>每个网页都用唯一的整数来表示</li>
<li>建立一个<strong>类似于倒排索引</strong>的邻接表，每行对应一个网页，按照其对应的整数大小排序。</li>
<li>任一网页P对应的行中包含的也是一系列整数的排序结构，每个整数对应<strong><u>链向P</u></strong>的网页编号。（那些网页指向P）</li>
</ul>
<h4 id="链接分析"><a href="#链接分析" class="headerlink" title="链接分析"></a>链接分析</h4><h5 id="Web是有向图"><a href="#Web是有向图" class="headerlink" title="Web是有向图"></a>Web是有向图</h5><ul>
<li>假设1：A到B的超链接表示A的作者对B的认可</li>
<li>假设2：指向页面B的锚文本式对B一个很好的描述</li>
</ul>
<h5 id="索引锚文本"><a href="#索引锚文本" class="headerlink" title="索引锚文本"></a>索引锚文本</h5><ul>
<li>索引文档D的时候，也索引指向文档D的锚文本</li>
<li>可以根据锚文本<strong><u>所在页面的权威性</u></strong>来确定锚文本的权重</li>
</ul>
<h5 id="小结：锚文本"><a href="#小结：锚文本" class="headerlink" title="小结：锚文本"></a>小结：锚文本</h5><ul>
<li>Web上很多网页的内容并不包含对自身的精确描述</li>
<li>Web搜索者不一定要使用网页中的词项来对网页进行查询，而使用锚文本。</li>
<li>锚文本周围窗口中的文本也可以当成锚文本一样来使用。</li>
</ul>
<h4 id="链接分析：PageRank"><a href="#链接分析：PageRank" class="headerlink" title="链接分析：PageRank"></a>链接分析：PageRank</h4><h5 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h5><ul>
<li>对Web图中的每个节点赋一个0~1间的分值，这个分值为PageRank</li>
<li><strong>查询词无关</strong>的排序</li>
<li>第一代版本：使用<strong>链接的数目</strong>作为流行程度的最简单度量</li>
<li>两个改进：<ul>
<li>无向流行度：赋予每个页面一个分：出链数+入链数</li>
<li>有向流行度：页面分数 = <strong>入链数</strong></li>
</ul>
</li>
</ul>
<h5 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h5><ul>
<li>检索出所有满足文本查询词的页面，然后把这些页面按照链接的流行的排序。</li>
<li>更复杂：把链接按流行度当作静态得分，结合文本匹配的分数进行综合排序</li>
</ul>
<h5 id="PageRank打分"><a href="#PageRank打分" class="headerlink" title="PageRank打分"></a>PageRank打分</h5><ul>
<li>假设一个浏览者在网络上随机行走<ul>
<li>从一个随机页面开始，每一步从当前页等概率地选择一个链接，进入链接所在页面</li>
</ul>
</li>
<li>在稳定状态下，每个页面都有一个访问概率——用这个概率作为页面的分数</li>
<li>当浏览者在Web上进行节点间的随机游走时，某些节点的访问次数会比其他的节点更多</li>
<li>访问频繁的节点具有很多从其它频繁访问节点中指向的入链接</li>
<li>PageRank思路：<strong>在随机游走过程中越频繁访问的网页越重要</strong></li>
</ul>
<h5 id="随机跳转（Teleporting）"><a href="#随机跳转（Teleporting）" class="headerlink" title="随机跳转（Teleporting）"></a>随机跳转（Teleporting）</h5><ul>
<li>遇到dead end时，随机跳转到一个页面，如果页面总数总是N，那么随机跳转的概率式1/N</li>
<li>非dead end， 以$a$(值较小)的概率跳转到一个随机页面；以剩余1-a的概率从页面的出链中选择一个</li>
<li>随机跳转结果：不会再困在一个地，将会有比率表示所有网页长期被访问的概率</li>
</ul>
<h5 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h5><ul>
<li>一个Markov链有<strong>N个状态</strong>，以及一个NxN的<strong>转移概率矩阵P</strong>。每一步只能处在一个状态</li>
<li>$1 \le i,j\le N$，转移概率矩阵P~ij~给出了从状态i到下一个状态j的条件转移概率</li>
<li>P中每一行的元素之和为1，从该页面跳转道其所有出链的概率之和为1</li>
<li>满足上述性质的非负矩阵被成为随机矩阵。最大特征值是1，与该特征值对应的有一个<strong>左特征向量</strong></li>
<li>马尔科夫链中下一个状态的分布仅仅依赖于当前的状态，与如何到达当前状态无关。</li>
<li>马尔科夫链的状态概率分布可以看成一个概率向量，每个元素都在[0,1]，且所有元素的和为1（行）</li>
</ul>
<h5 id="邻接矩阵A→概率转移矩阵P"><a href="#邻接矩阵A→概率转移矩阵P" class="headerlink" title="邻接矩阵A→概率转移矩阵P"></a>邻接矩阵A→概率转移矩阵P</h5><ul>
<li>如果一行没有1（没有出链），用1/N代替每个元素</li>
<li>否则<ul>
<li>每行中用1的个数除每个1。（归一化） 若某行3个1，每个1用1/3表示</li>
<li>上面处理的结果矩阵乘以1-a</li>
<li>上面结果矩阵元素加上  a/N </li>
</ul>
</li>
</ul>
<h5 id="概率向量的变化"><a href="#概率向量的变化" class="headerlink" title="概率向量的变化"></a>概率向量的变化</h5><ul>
<li>最终访问频率收敛与固定的、稳态概率π</li>
<li>算法： 给 <strong><em>X</em></strong> 乘上P的k次方，k不断增加，直到乘积稳定</li>
<li><strong><em>π</em></strong>P = <strong><em>π</em></strong>  <ul>
<li>解矩阵等式得到<strong><em>π</em></strong></li>
<li><strong><em>π</em></strong>是P的主左特征向量，<strong><em>π~i~</em></strong>是页面i的PageRank</li>
</ul>
</li>
</ul>
<h3 id="链接分析：HITS"><a href="#链接分析：HITS" class="headerlink" title="链接分析：HITS"></a>链接分析：HITS</h3><ul>
<li>对每个网页给出两个得分 hub值（导航） ，authority值（权威）</li>
<li>确定基本集</li>
<li>精选出Hub页和Authority页</li>
<li>迭代跟新h(x),a(x)<ul>
<li>输出h(x)最高作为Top Hub页，a(x)最高作为Top Authority页</li>
</ul>
</li>
<li>大概5次迭代就会稳定</li>
<li>h是$AA^t$的特征向量，a是$A^tA$的特征向量</li>
</ul>
<h2 id="6-向量模型"><a href="#6-向量模型" class="headerlink" title="6.向量模型"></a>6.向量模型</h2><h3 id="排序式检索"><a href="#排序式检索" class="headerlink" title="排序式检索"></a>排序式检索</h3><p>布尔检索：文档要么匹配要么不匹配。对自身需求和文档集性质非常了解的专家而言，布尔查询式不错的选择。然而对大多数用户来说不方便</p>
<ul>
<li>布尔查询的结果不是太多就是太少</li>
<li>需要花费很多精力去<strong>构造一个合适的query</strong>才可以获得一个在数量上可以接受的查询结果。</li>
</ul>
<h4 id="排序检索模型"><a href="#排序检索模型" class="headerlink" title="排序检索模型"></a>排序检索模型</h4><ul>
<li>在排序检索模型中，系统根据<strong>文档与query的相关性排序</strong>返回文档集合中的文档，而不是简单地返回所有满足query描述的文档集合。</li>
<li>自由文本查询：用户query是自然语言的一个或多个词语而不是由查询语言构造的表达式。</li>
<li>总体上，排序检索模型中有布尔查询和自由文本查询两种方式，但是实际中排序检索模型总是与自由文本查询联系在一起，反之亦然。</li>
</ul>
<h4 id="过多、过少不再是问题"><a href="#过多、过少不再是问题" class="headerlink" title="过多、过少不再是问题"></a>过多、过少不再是问题</h4><ul>
<li>当系统给出的式有序的查询结果，查询结果数目多不再是问题。只需要给出<strong>top K</strong>（10个左右）个结果，为用户减轻负担。</li>
<li>前提是有<strong>合适的排序算法</strong></li>
</ul>
<h4 id="排序检索的基本—-评分"><a href="#排序检索的基本—-评分" class="headerlink" title="排序检索的基本—-评分"></a>排序检索的基本—-评分</h4><p>希望根据文档对查询者的有用性大小顺序将文档返回给查询者</p>
<ul>
<li>给每个“查询—文档”对进行评分，在[0,1]之间</li>
<li><strong><em><em>这个评分值衡量文档与query的匹配程度</em></em></strong></li>
<li>以单个单词组成的query为例<ul>
<li>如果单词不出现在文档中，该文档得分为0</li>
<li>该词项在文档中出现的频率越高，则评分越高</li>
</ul>
</li>
</ul>
<h5 id="评分方案一—-Jaccard系数"><a href="#评分方案一—-Jaccard系数" class="headerlink" title="评分方案一—-Jaccard系数"></a>评分方案一—-Jaccard系数</h5><p>一种常用的衡量<strong>两个集合A,B重叠度</strong>的方法</p>
<ul>
<li>$Jaccard(A,B) = |A \cap B| / |A \cup B|$</li>
<li>$Jaccard(A,A) = 1$</li>
<li>$Jaccard(A,B) = 0 \ if\  A \cap B=0$</li>
<li>集合A和B不需要具有同样的规模</li>
<li>Jaccard(A,B)的取值在[0,1]</li>
</ul>
<p>用Jaccard系数评分的问题</p>
<ul>
<li>没有考虑<strong><em>词项频率</em></strong>（词项在文档中出现的次数）</li>
<li>没有考虑<strong><em>罕见词比高频词的信息量更大，更具区分度</em></strong></li>
</ul>
<h3 id="词项频率"><a href="#词项频率" class="headerlink" title="词项频率"></a>词项频率</h3><h4 id="词项–文档二值关联矩阵"><a href="#词项–文档二值关联矩阵" class="headerlink" title="词项–文档二值关联矩阵"></a>词项–文档二值关联矩阵</h4><ul>
<li>每个文档用一个二值向量表示 $\in {0,1}^{|v|}$  。每个词项是否属于某个文档</li>
</ul>
<h4 id="词项—文档词频关联矩阵"><a href="#词项—文档词频关联矩阵" class="headerlink" title="词项—文档词频关联矩阵"></a>词项—文档词频关联矩阵</h4><ul>
<li>考虑词项在文档中出现的频率，将每个文档看成是一个<strong><em>词频向量</em></strong>：矩阵中的一列</li>
</ul>
<h4 id="词袋模型（Bag-of-words）"><a href="#词袋模型（Bag-of-words）" class="headerlink" title="词袋模型（Bag of words）"></a>词袋模型（Bag of words）</h4><ul>
<li><p><strong>不考虑词在文档中出现的顺序</strong></p>
<p>“John is quicker than Mary” 和 “Mary is quicker than John” 的表示结果一样</p>
</li>
</ul>
<h5 id="词项频率tf（Term-frequency）"><a href="#词项频率tf（Term-frequency）" class="headerlink" title="词项频率tf（Term frequency）"></a>词项频率tf（Term frequency）</h5><p>词项频率：词项t在文档d中出现的次数，记为$tf_{t,d}$</p>
<ol>
<li>采用原始tf值（raw tf）<ul>
<li>某个词项在A文档中出现10次，即tf=10，在B文档中tf=1，那么A比B更相关，但是相关度不会相差10倍</li>
<li><strong><em>相关性不会正比于词项频率</em></strong></li>
</ul>
</li>
<li>对数词频<ul>
<li>词项t在文档d中的对数频率权重</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%AF%B9%E6%95%B0%E9%A2%91%E7%8E%87.png" alt="对数词频"><ul>
<li>文档——词项的<strong><em>匹配得分</em></strong>是所有<strong>同时出现</strong>在<u>query</u>和<u>文档d</u>中的词项的词频的对数之和</li>
<li>$Score(q,d) = \sum<em>{t\in q\cap d} (1+log^{tf</em>{t,d}})$</li>
<li>评分为0，表示文档和query没有<strong><em>公共词项</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="tf-idf权重计算"><a href="#tf-idf权重计算" class="headerlink" title="tf-idf权重计算"></a>tf-idf权重计算</h3><p>除词项频率tf之外，利用<strong>词项在整个文档集中</strong>的频率进行权重和评分计算</p>
<h4 id="罕见词所期望的权重"><a href="#罕见词所期望的权重" class="headerlink" title="罕见词所期望的权重"></a>罕见词所期望的权重</h4><ul>
<li><strong>罕见词比常见词所蕴含的信息更多</strong></li>
<li>考虑查询中某个词项，它会在整个文档集中非常罕见</li>
<li><strong>某篇包含该词项的文档很可能相关</strong>，故罕见词项将有较高权重</li>
</ul>
<h4 id="常见词项所期望的权重"><a href="#常见词项所期望的权重" class="headerlink" title="常见词项所期望的权重"></a>常见词项所期望的权重</h4><ul>
<li>常见词项的<strong>信息量</strong>不如罕见词</li>
<li>考虑一个查询此项，它频繁出现在文档集中</li>
<li>一篇包含该词项的文档当然比不包含该词项的文档的相关度要高</li>
<li>但是，这些词对于相关度而言并<strong><em><em>不是非常强的指示词</em></em></strong>，故<strong><em><em>给一个正的权重，但是整个权重小于罕见词权重</em></em></strong></li>
</ul>
<h4 id="文档频率（Document-frequency，df）"><a href="#文档频率（Document-frequency，df）" class="headerlink" title="文档频率（Document frequency，df）"></a>文档频率（Document frequency，df）</h4><ul>
<li>罕见词项赋予高权重</li>
<li>常见词项赋予正的低权重</li>
<li>文档频率$df$因子来计算 查询–文档的匹配得分</li>
<li><strong><em>文档频率</em></strong>：出现词项的文档数目</li>
</ul>
<h4 id="idf（inverse-document-frequency）逆文档频率"><a href="#idf（inverse-document-frequency）逆文档频率" class="headerlink" title="idf（inverse document frequency）逆文档频率"></a>idf（inverse document frequency）逆文档频率</h4><ul>
<li>$df_t$是词项t的<strong>文档频率</strong>：<strong>文档集合中包含t的文档数目</strong><ul>
<li>$df_t$与词项t包含的<strong>信息量</strong>成<strong>反比</strong>（出现文档数目越多，该词项的信息量相对较小）</li>
<li>$df_t \le N$ (N是文档的总数)</li>
</ul>
</li>
<li><p>定义t的<strong>逆文档频率</strong>为$idf$</p>
<p>  $idf<em>t = log</em>{10}(N/df_t)$</p>
</li>
<li>$idf_t$是反应<strong>词项t的信息量</strong>的一个指标</li>
<li>用$log_{10}(N/df_t)$来代替$\frac{N}{df_t}$来抑制idf的作用</li>
</ul>
<h4 id="idf对排序的影响"><a href="#idf对排序的影响" class="headerlink" title="idf对排序的影响"></a>idf对排序的影响</h4><ul>
<li>对于含有<strong>两个以上查询词的query</strong>，$idf$才会影响排序结果；只有一个查询词的query，idf对排序结果没有影响</li>
<li>例如 Query: arachnocentric line ， idf会提高 arachnocentric的相对权重，同时减低line的相对权重</li>
</ul>
<h4 id="文档集频率和文档频率"><a href="#文档集频率和文档频率" class="headerlink" title="文档集频率和文档频率"></a>文档集频率和文档频率</h4><ul>
<li>文档集频率（collection frequency,cf）是<u>指t在整个文档集合中出现的<strong><em><em>词的次数</em></em></strong></u>。</li>
<li>文档频率（document frequency，df）<u>包含该词项的<strong><em><em>文档数目</em></em></strong></u></li>
<li>df比cf更适合权重计算</li>
</ul>
<h4 id="tf–idf文档-逆文档频率（单个词）"><a href="#tf–idf文档-逆文档频率（单个词）" class="headerlink" title="tf–idf文档-逆文档频率（单个词）"></a>tf–idf文档-逆文档频率（单个词）</h4><ul>
<li>tf-idf是信息检索中最著名的权重计算方法</li>
<li>词项t的tf-idf式由它的tf和idf组合而成</li>
<li>$w<em>{t,d} = (1+logtf</em>{t,d})\times\log_{10}(N/df_t)$</li>
<li>tf-idf值随着<strong><em>词项在单个文档中出现次数(tf)增加而增加</em></strong>，随着<strong><em>词项在文档集中数目(df)增加而减小</em></strong></li>
</ul>
<h4 id="Query-最终文档排序"><a href="#Query-最终文档排序" class="headerlink" title="Query 最终文档排序"></a>Query 最终文档排序</h4><p>$Score(q,d) = \sum<em>{t\in q \cap d}tf*idf</em>{t,d}$</p>
<h3 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h3><ul>
<li>二值关联矩阵：每个文档用一个二值向量表示 $\in {0,1}^{|v|}$</li>
<li>词频矩阵：每篇文档表示成一个词频向量 $\in N^{|v|}$</li>
<li>tf-idf矩阵：每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$</li>
</ul>
<h4 id="文档表示成向量"><a href="#文档表示成向量" class="headerlink" title="文档表示成向量"></a>文档表示成向量</h4><ul>
<li>每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$(V式词项集合，|v|表示词项个数)</li>
<li>|v|维实向量空间<ul>
<li>空间每一维都对应<strong>词项</strong></li>
<li><strong>文档</strong>是空间的点或者向量</li>
<li>维度非常高：特别是互联网搜索引擎，空间可达千万维或更高</li>
<li>向量空间非常<strong>稀疏</strong>：对每个向量来说大部分都是0</li>
</ul>
</li>
</ul>
<h4 id="Queries表示成向量"><a href="#Queries表示成向量" class="headerlink" title="Queries表示成向量"></a>Queries表示成向量</h4><ol>
<li>对于查询做同样的处理，即将查询表示成统一高维空间的向量</li>
<li>在向量空间内根据query与<strong>文档相量间的距离</strong>来排序</li>
</ol>
<h4 id="利用夹角代替距离"><a href="#利用夹角代替距离" class="headerlink" title="利用夹角代替距离"></a>利用夹角代替距离</h4><ul>
<li>按query与文档夹角递减给文档排序，按余弦递增给文档排序 是的等价的。</li>
<li>按余弦cosine(query,document)递减给文档排序，只考虑相对顺序</li>
</ul>
<h4 id="文档长度归一化"><a href="#文档长度归一化" class="headerlink" title="文档长度归一化"></a>文档长度归一化</h4><ul>
<li>利用二范数对文档长度进行归一化，一个文档向量除以它的L~2~范数就是给这个文档进行长度归一化</li>
</ul>
<h2 id="6-检索系统"><a href="#6-检索系统" class="headerlink" title="6.检索系统"></a>6.检索系统</h2><h3 id="排序的重要性"><a href="#排序的重要性" class="headerlink" title="排序的重要性"></a>排序的重要性</h3><ul>
<li>用户只希望看到一些而不是成千上万的结果</li>
<li>很难构造只产生一些结果的查询，即使是专家也很难</li>
<li>→排序能够将成千上万条结果缩减至几条结果，因此非常重要</li>
<li>实际上大部分用户只看到1-3条结果</li>
</ul>
<h4 id="摘要阅读"><a href="#摘要阅读" class="headerlink" title="摘要阅读"></a>摘要阅读</h4><p>用户更可能阅读前几页(1, 2, 3, 4)的结果的摘要</p>
<h4 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h4><p>点击的分布甚至更有偏向性</p>
<ul>
<li>一半情况下，用户点击排名最高的页面<ul>
<li>即使排名最高的页面不相关，仍然有30%的用户会点击它            </li>
</ul>
</li>
<li>正确排序相当重要，把相关的页面放在首页非常重要</li>
</ul>
<h3 id="结果排序的实现"><a href="#结果排序的实现" class="headerlink" title="结果排序的实现"></a>结果排序的实现</h3><h4 id="tf和idf的存储"><a href="#tf和idf的存储" class="headerlink" title="tf和idf的存储"></a>tf和idf的存储</h4><ul>
<li><p>词典中保存每个词的idf</p>
</li>
<li><p>词项频率tf存入倒排索引</p>
<p>term|idf    →  d1,tf , \<p1,p2,…> d5, tf, \<p1,p2,…></p1,p2,…></p1,p2,…></p>
</li>
</ul>
<h4 id="精确top-K检索机器加速办法"><a href="#精确top-K检索机器加速办法" class="headerlink" title="精确top K检索机器加速办法"></a>精确top K检索机器加速办法</h4><ul>
<li>从文档集所有文档中找出K个离查询最近的文档</li>
<li>步骤：对每个文档频繁（余弦相似度），按评分高低排序，选出前K个结果</li>
<li>如何加速：<ul>
<li>加快每个余弦相似度的计算</li>
<li>不对所有文档的评分结果排序而直接选出top K篇</li>
<li>能否不需要计算所有N篇文档的得分</li>
</ul>
</li>
</ul>
<h4 id="快速计算余弦相似度"><a href="#快速计算余弦相似度" class="headerlink" title="快速计算余弦相似度"></a>快速计算余弦相似度</h4><ul>
<li>检索排序就是找查询的k临近</li>
<li>如果查询很短，可以加速<ul>
<li>查询的多个词项无权重</li>
<li>排序只需要相对得分</li>
</ul>
</li>
</ul>
<h4 id="堆排序法N中选K"><a href="#堆排序法N中选K" class="headerlink" title="堆排序法N中选K"></a>堆排序法N中选K</h4><ul>
<li>检索时，通常只需要返回前K条结果</li>
<li>令J=具有非零余弦相似度值的文档数目，利用对结构从J中选K个最大的</li>
</ul>
<h4 id="提前终止计算"><a href="#提前终止计算" class="headerlink" title="提前终止计算"></a>提前终止计算</h4><h4 id="非精确top-K检索的可行性"><a href="#非精确top-K检索的可行性" class="headerlink" title="非精确top K检索的可行性"></a>非精确top K检索的可行性</h4><ul>
<li>索引去除：<ul>
<li>对于一个包含多个词项的查询来说，可以只考虑<strong>至少包含一个查询词项的文档</strong></li>
<li>只考虑那些词项的<strong>idf值</strong>超过一定阈值的文档</li>
<li>只考虑包含<strong>多个查询词项</strong></li>
</ul>
</li>
<li>胜者表<ul>
<li>对于词典中的每个词项t，预先计算出r个最高权重的文档<ul>
<li>词项t所对应的tf值最高的r篇文档构成t的胜者表，r值<strong>在索引建立时给定</strong>可能r&lt;k</li>
</ul>
</li>
<li>根据给定查询q，对查询q中所有词项的胜者表求并集生成集合A。根据余弦相似度大小从A中选取前top K个文档</li>
</ul>
</li>
<li>静态得分<ul>
<li>希望排序考前的文档既相关又是权威的<ul>
<li>相关性通过余弦相似度得分来判断</li>
<li>权威性由文档本身的属性决定</li>
</ul>
</li>
<li>​</li>
</ul>
</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>信息检索的目标式<strong><em><em>较少消耗情况下尽快、全面返回准确的结果。</em></em></strong></p>
<h3 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h3><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><ul>
<li>时间开销</li>
<li>空间开销</li>
<li>响应速度<h4 id="效果（Effectiveness）"><a href="#效果（Effectiveness）" class="headerlink" title="效果（Effectiveness）"></a>效果（Effectiveness）</h4></li>
<li>返回的文档中有多少相关文档</li>
<li>所有相关文档中反回了多少</li>
<li>返回得靠不靠前<h4 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h4></li>
<li>覆盖率（Coverage）</li>
<li>访问量</li>
<li>数据更新速度</li>
</ul>
<h4 id="评价效果"><a href="#评价效果" class="headerlink" title="评价效果"></a>评价效果</h4><ul>
<li><strong>相同的文档</strong>集合，<strong>相同的查询</strong>主题集合，<strong>相同的评价指标</strong>，<strong>不同</strong>的检索系统进行比较。</li>
</ul>
<h3 id="无序检索结果的评价"><a href="#无序检索结果的评价" class="headerlink" title="无序检索结果的评价"></a>无序检索结果的评价</h3><h4 id="对单个查询进行评估的指标"><a href="#对单个查询进行评估的指标" class="headerlink" title="对单个查询进行评估的指标"></a>对单个查询进行评估的指标</h4><h5 id="对整个文档集合的划分"><a href="#对整个文档集合的划分" class="headerlink" title="对整个文档集合的划分"></a>对整个文档集合的划分</h5><ul>
<li>未检索出（Not Retrieved）<ul>
<li>未检索出的相关文档(NR)</li>
<li>未检索出的不相关文档 (NN)</li>
</ul>
</li>
<li>检索出（Retrieved）<ul>
<li>检索出的相关文档(RR)</li>
<li>检索出的不相关文档(RN)<h5 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h5></li>
</ul>
</li>
<li>召回率(Recall):RR/(RR+NR),返回的相关结果数占实际相关结果总数的比率，也称为查全率，$R\in[0,1]$</li>
<li>正确率(Precision):RR/(RR+RN),返回的结果中真正相关的比率，也称查准率，$P\in[0,1]$</li>
<li>两个指标分别度量检索效果的某个方面，忽略任何一个方面都有偏失。</li>
<li>两个极端情况<ol>
<li>返回有把握的1篇，P=100%，但R极低</li>
<li>全部文档都返回，R=1，但P极低</li>
</ol>
</li>
<li>虽然Precision和Recall都很重要，但是不同的应用、不同的用户对两者的要求不一样。</li>
</ul>
<h4 id="正确率和召回率的问题"><a href="#正确率和召回率的问题" class="headerlink" title="正确率和召回率的问题"></a>正确率和召回率的问题</h4><ul>
<li>应用领域<ul>
<li>拼写校对、中文分词、文本分类、人脸识别、…… </li>
</ul>
</li>
</ul>
<ul>
<li>召回率难以计算<ul>
<li>Pooling方法，或则不考虑召回率</li>
</ul>
</li>
<li>两个指标分别衡量了系统的某个方面，但是如何评价哪个系统好<ul>
<li>将两个指标融成一个指标</li>
</ul>
</li>
<li>两个指标都是基于<strong><em>集合（无序）进行</em></strong>计算，并没有考虑序的作用<ul>
<li>引入序的作用</li>
</ul>
</li>
</ul>
<h5 id="召回率的计算"><a href="#召回率的计算" class="headerlink" title="召回率的计算"></a>召回率的计算</h5><p>对于大规模语料集合，列举每个查询的所有相关文档不可能，因此不可能准确地计算召回率</p>
<ul>
<li>缓冲池（Pooling）方法：对多个检索系统的TopN个结果组成的集合进行人工标注，标注相关文档集合作为整个相关文档集合</li>
</ul>
<h5 id="使用查准率-查全率的问题"><a href="#使用查准率-查全率的问题" class="headerlink" title="使用查准率/查全率的问题"></a>使用查准率/查全率的问题</h5><ul>
<li>需要在<strong>大规模</strong>的文档集合和查询集合上进行计算</li>
<li><p>需要<strong>人工</strong>对返回的文档进行评价</p>
<ul>
<li>由于人的主观因素，人工评价往往不可靠</li>
</ul>
</li>
<li><p>评价是二值的</p>
<ul>
<li>无法体现细微的差别</li>
</ul>
</li>
<li>文档结合和数据来源不同，结果也不同，有严重的偏差<ul>
<li>评价结果只适用于某个范围，很难引申到其他范围</li>
</ul>
</li>
</ul>
<h4 id="综合评价准则-F-P和R融合"><a href="#综合评价准则-F-P和R融合" class="headerlink" title="综合评价准则 F=P和R融合"></a>综合评价准则 F=P和R融合</h4><ul>
<li>F值（F-measure):召回率R和查准率的加权调和平均值</li>
<li>$F = \frac{1}{\alpha^\frac{1}{p}+(1-\alpha)^\frac{1}{R}}=\frac{(\beta^2+1)PR}{\beta^2P+R}$</li>
<li>$F_\beta$ ：表示召回率的重要程度是查准率的$\beta(&gt;=0)$倍<ul>
<li>$\beta&gt;1$ 更重视召回率，$\beta&lt;1$更重视查准率</li>
<li>取等权重</li>
<li>$F_{\beta=1} = \frac{2PR}{P+R}$</li>
</ul>
</li>
<li>调和平均比较保守</li>
</ul>
<h4 id="精确率不适合IR的原因"><a href="#精确率不适合IR的原因" class="headerlink" title="精确率不适合IR的原因"></a>精确率不适合IR的原因</h4><ul>
<li>和查询相关的文档占文档集的极少数，即使什么都不返回也会得到很高的精确率</li>
<li>用户希望找到某些文档并且能够容忍结果中有一定的不相关性</li>
<li>返回一些即使不好的文档也比不反回任何文档好</li>
</ul>
<h3 id="有序检索结果的评价"><a href="#有序检索结果的评价" class="headerlink" title="有序检索结果的评价"></a>有序检索结果的评价</h3><h4 id="评价排序后的结果"><a href="#评价排序后的结果" class="headerlink" title="评价排序后的结果"></a>评价排序后的结果</h4><ul>
<li>P、R、F值都是基于集合的评价方法，它们都是利用无序的文档集合进行计算。如果搜索引擎输出为有序的检索结果时，需要扩展</li>
<li>对于特定检索词的有序检测结果<ul>
<li>系统可能返回任意数量的结果（=N）</li>
<li>考虑Top k返回的情形</li>
<li>则每个k的取值对应一个R和P</li>
</ul>
</li>
<li>计算得到查准率-查全率曲线</li>
</ul>
<h4 id="P-R的优缺点"><a href="#P-R的优缺点" class="headerlink" title="P-R的优缺点"></a>P-R的优缺点</h4><ul>
<li>优点：<ul>
<li>简单直观</li>
<li>既考虑了检索结果的覆盖度，又考虑了检索结果的排序情况</li>
</ul>
</li>
<li>缺点:<ul>
<li>单个查询的P-R曲线虽然直观，但是难以明确表示两个查询的检索结果的优劣</li>
</ul>
</li>
</ul>
<h4 id="基于P-R曲线的单一指标"><a href="#基于P-R曲线的单一指标" class="headerlink" title="基于P-R曲线的单一指标"></a>基于P-R曲线的单一指标</h4><ul>
<li>固定检索等级的查准率<ul>
<li>Precision@k：前k个结果的查准率</li>
<li>对大多数的web搜索适合，因为用户看重在前几页中有多少好结果</li>
<li>平均的方式不好，通常所用指标中最不稳定的</li>
</ul>
</li>
<li>11点平均正确率<ul>
<li>对每个信息需求，插值的<strong>正确率</strong>定义在0,0.1,0.2,…,0.9,1共11个召回率水平上</li>
<li>对每个召回率水平，对测试集中<strong>多个查询</strong>在该点的插值正确率<strong>求算术平均</strong></li>
</ul>
</li>
</ul>
<h4 id="更多的评价准则：AP"><a href="#更多的评价准则：AP" class="headerlink" title="更多的评价准则：AP"></a>更多的评价准则：AP</h4><ul>
<li><p>平均查准率(Average Precision,AP)：对不同召回率点上的正确率进行平均</p>
<ul>
<li><p><strong>未插值AP</strong>：某个查询Q共有6个相关结果，某系统排序反回了5篇相关文档，其位置分别为 第1，第2，第5，第10，第20位。</p>
<ul>
<li>$AP = (\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20}+0)/6$，等价于6点平均</li>
</ul>
</li>
<li><p><strong>插值的AP</strong>：在召回率分别为0, 0.1, 0.2, … ,1.0的十一个点上的正确率求平均，等价于11点平均</p>
<ul>
<li><p><strong>只对返回的相关文档</strong>进行计算的AP</p>
<p>$AP =(\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20})/5$，倾向返回那些快速返回结果的系统，<strong>没有考虑召回率</strong>，等价于5点平均</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="不考虑召回率"><a href="#不考虑召回率" class="headerlink" title="不考虑召回率"></a>不考虑召回率</h4><ul>
<li>Precision@N：在第N个位置上的正确率<ul>
<li>对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页结果。因此P@10、P@20对大规模搜索引擎来说是很好的指标</li>
</ul>
</li>
</ul>
<h4 id="宏平均vs微平均"><a href="#宏平均vs微平均" class="headerlink" title="宏平均vs微平均"></a>宏平均vs微平均</h4><ul>
<li>平均的求法：<ul>
<li>宏平均（Macro Average）：对<strong>每个查询</strong>求出某个指标，然后对这些指标进行算术平均</li>
<li>微平均（Micro Average）：将所有查询视为<strong>一个查询</strong>，将各种情况的文档总数求和，然后进行指标运算。（一个系统的所有查询）<ul>
<li>Eg： $ Micro Precision = \frac{对所有检验出的相关文档总数} {对所有查询检出的文档总数}$</li>
<li>宏平均对所有<strong>查询一视同仁</strong>，微平均受返回相关文档数目比较大的查询影响（宏平均保护弱者）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="平均查准率均值-Mean-Average-Precision-MAP"><a href="#平均查准率均值-Mean-Average-Precision-MAP" class="headerlink" title="平均查准率均值 Mean Average Precision(MAP)"></a>平均查准率均值 Mean Average Precision(MAP)</h4><ul>
<li>每个<strong><u><em>相关文档位置上</em></u></strong>查准率的平均值，被称为<strong>平均查准率</strong>（AP）</li>
<li>对所有查询求宏平均，就得到平均查准率均值（MAP）</li>
<li>$Map(Q)= \frac{1}{|Q|}\sum_{j=1}^{|Q|}\frac{1}{m<em>j}\sum</em>{k=1}^{m<em>j}Precision(R</em>{jk})$</li>
<li>Q为信息需求，$q_j \in Q$所对应的所有相关文档集合为${d_1,d<em>2,…,d</em>{mj}}$ ，$R_{ij}$是查询$q<em>j$的返回结果，该结果中包含而不含有$d</em>{k+1}$及以后的相关文档</li>
</ul>
<h4 id="面向用户的评价指标"><a href="#面向用户的评价指标" class="headerlink" title="面向用户的评价指标"></a>面向用户的评价指标</h4><ul>
<li>假定用户<strong>已知的相关文档集合为U</strong>，检索结果和U的交集为$R_u$，则<strong>覆盖率</strong><ul>
<li>$C=\frac{R_u}{U}$，<strong>检索系统找到的用户已知的相关文档比例</strong></li>
</ul>
</li>
<li>假定检索结果中返回一些用户<strong>以前未知的相关文档$R_k$</strong>，则可以定义<strong>新颖率</strong><ul>
<li>$N=\frac{|R_k|}{|R_u|+|R_k|}$，表示系统返回的新相关文档的比例</li>
</ul>
</li>
</ul>
<h4 id="GMAP"><a href="#GMAP" class="headerlink" title="GMAP"></a>GMAP</h4><ul>
<li>AP的集合平均值（更能体现细微差别）</li>
</ul>
<h4 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h4><ul>
<li>每个文段不仅仅只有相关和不相关，而是有相关级别<ul>
<li>相关度级别越高的结果越多越好</li>
<li>相关度级别越高的结果越靠前越好</li>
</ul>
</li>
</ul>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><ul>
<li>标题通常是从文档的元数据中自动抽取出来的<ul>
<li>用户根据描述信息来判断这个文档是否相关</li>
</ul>
</li>
<li>两种基本类型<ul>
<li>静态：不论输入什么查询，文档的静态摘要都是不变的</li>
<li>动态：动态摘要<strong>依赖于查询</strong>，试图解释当前文档返回的原因</li>
</ul>
</li>
</ul>
<h4 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>信息检索的评价方法<ul>
<li>不考虑序的检索评价指标：P、R、F</li>
<li>考虑序的评价指标：P/R曲线、MAP、NDCG</li>
</ul>
</li>
<li>检索结果的摘要</li>
</ul>
<h2 id="相关反馈及查询扩展"><a href="#相关反馈及查询扩展" class="headerlink" title="相关反馈及查询扩展"></a>相关反馈及查询扩展</h2><ul>
<li>交互式相关反馈：在初始检索结果基础上，通过用户指定哪些文档相关或不相关，然后改进检索的结果。Rocchio相关反馈</li>
<li>查询扩展（Query expansion）：通过在查询中加入同义或者相关的词项来提供检索结果。人工编辑的同义词辞典、自动构造的同义词词典、查询日志</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h4 id="搜索中提高召回率的方法"><a href="#搜索中提高召回率的方法" class="headerlink" title="搜索中提高召回率的方法"></a>搜索中提高召回率的方法</h4><ul>
<li>提高召回率的方法—— 相关反馈及查询扩展</li>
<li>返回不包含查询词项的相关文档</li>
</ul>
<h4 id="关于召回率Recall"><a href="#关于召回率Recall" class="headerlink" title="关于召回率Recall"></a>关于召回率Recall</h4><ul>
<li>放松召回率的定义，给用户返回更多的相关文档</li>
</ul>
<h4 id="提高召回率的方法"><a href="#提高召回率的方法" class="headerlink" title="提高召回率的方法"></a>提高召回率的方法</h4><ul>
<li>局部（local）方法：对用户查询进行局部的实时分析<ul>
<li>主要局部方法：<strong>相关反馈</strong>（relevance feedback）</li>
</ul>
</li>
<li>全局（global）方法：进行一次性的全局分析产生同/近义词词典(thesaurus)<ul>
<li>利用该词典进行查询扩展</li>
</ul>
</li>
</ul>
<h3 id="相关反馈基础"><a href="#相关反馈基础" class="headerlink" title="相关反馈基础"></a>相关反馈基础</h3><h4 id="相关反馈的基本思想"><a href="#相关反馈的基本思想" class="headerlink" title="相关反馈的基本思想"></a>相关反馈的基本思想</h4><ul>
<li>用户提交一个（简短的）查询</li>
<li>搜索引擎返回一系列文档</li>
<li>用户将部分返回文档标记为<strong>相关</strong>的，将部分文档标记为<strong>不相关</strong>的</li>
<li>搜索引擎根据标记结果计算得到信息需求的一个<strong>新查询表示</strong>。（希望好于初始查询）</li>
<li>对新查询进行处理，返回新结果。</li>
<li>新结果渴望有更高的<strong>召回率</strong></li>
</ul>
<h4 id="相关反馈分类"><a href="#相关反馈分类" class="headerlink" title="相关反馈分类"></a>相关反馈分类</h4><ul>
<li>用户相关反馈或显示相关反馈（User Feedback or Explicit Feedback）：用户显示参加交互过程</li>
<li>隐式相关反馈（Implicit Feedback）：系统跟踪用户的行为来推测返回文档的相关性，从而进行反馈</li>
<li>伪相关反馈或盲目相关反馈：（Pseduo Feedback or Blind Feedback）：没有用户参与，系统直接假设返回文档的前K篇相关的，然后进行反馈。</li>
</ul>
<h3 id="相关反馈详细介绍"><a href="#相关反馈详细介绍" class="headerlink" title="相关反馈详细介绍"></a>相关反馈详细介绍</h3><h4 id="相关反馈中的核心概念：质心"><a href="#相关反馈中的核心概念：质心" class="headerlink" title="相关反馈中的核心概念：质心"></a>相关反馈中的核心概念：质心</h4><ul>
<li>质心是一系列点的中心</li>
<li>前面将文档表示成高维空间中的点</li>
<li>计算文档质心的公式：</li>
</ul>
<h4 id="相关反馈基本理论"><a href="#相关反馈基本理论" class="headerlink" title="相关反馈基本理论"></a>相关反馈基本理论</h4><ul>
<li>基本理论：假定要找一个最有查询向量q，它与相关文档之间的相似度最大且同时又和不相关文档之间的相似度最小。</li>
<li><strong><em>q~opt~</em></strong>是将相关文档与不相关文档区分开的向量</li>
<li>当sim()函数采用余弦相似度计算时，能够将相关文档与不相关文档区分开的最有查询向量为：</li>
<li>最优查询向量等于<strong>相关文档的质心向量和不相关文档的质心向量的差</strong></li>
</ul>
<h4 id="Rocchio算法"><a href="#Rocchio算法" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>假定有一个用户查询，并知道部分相关文档和不相关文档的信息，最优查询向量为</li>
<li>q-</li>
<li>修改后的新查询从q~0~开始，向相关文档质心靠近，同时与不相关文档质心远离。</li>
<li>将<strong>相关文档</strong>的质心移动一个量，该量为相关文档质心和不相关文档质心的差异量</li>
<li>修改后的新查询，向着相关文档的质心向量靠近了一段距离，与不相关文档的质心向量远离了一段距离。</li>
</ul>
<h4 id="相关反馈策略的评价"><a href="#相关反馈策略的评价" class="headerlink" title="相关反馈策略的评价"></a>相关反馈策略的评价</h4><ul>
<li>使用初始查询q~0~ ，计算”查准率-查全率“曲线</li>
<li>使用相关反馈后修改查询q~m~，然后计算”查准率-查全率“曲线<ul>
<li>方案1：在<strong>整个文档集合</strong>上评价<ul>
<li>有显著的改善，但是有作弊嫌疑部分原因是会把已知的相关文档排在很前</li>
<li>需要用用户没有看到的文档集合来评价</li>
</ul>
</li>
<li>方案2：使用<strong>剩余的文档</strong>集合来评价（总的文档集合减去评价过的相关性文档）<ul>
<li>评价结果往往<strong>比初始查询的结果差</strong>，但是这种方法更现实</li>
<li>可以用来有效比较不同相关反馈方法之间的相对效果</li>
</ul>
</li>
<li>方案3：使用<strong>两个文档</strong>集合<ul>
<li>在第一个文档集合上使用初始查询q~0~，并进行相关反馈</li>
<li>在第二个文档集合上使用初始查询q~0~和修改过的查询q~m~进行评价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="评价的误区"><a href="#评价的误区" class="headerlink" title="评价的误区"></a>评价的误区</h4><ul>
<li>评价不同相关反馈的效用的时候，必须考虑消耗时间的要素。</li>
<li>代替相关反馈的方法：用户修改并重新提交查询</li>
<li>相对于判断文档的相关性，用户可能更愿意修改并重新提交查询</li>
<li>没有证据能表明相关反馈占用了用户的时间就能给用户带来最大的效用。</li>
</ul>
<h4 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h4><ul>
<li>提高召回率</li>
<li>查询重构的全局方法。在全局查询扩展中，查询基于一些<strong>全局的资源</strong>进行修改。</li>
<li>主要使用 同义词或近义词词典（人工构建和自动构建）</li>
</ul>
<h2 id="概率检索模型"><a href="#概率检索模型" class="headerlink" title="概率检索模型"></a>概率检索模型</h2><h3 id="向量空间模型回顾"><a href="#向量空间模型回顾" class="headerlink" title="向量空间模型回顾"></a>向量空间模型回顾</h3><h4 id="向量空间模型-1"><a href="#向量空间模型-1" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>文档表示成向量</li>
<li>查询也表示成向量</li>
<li>计算两个向量之间的相似度：余弦相似度、内积相似度</li>
<li>向量表示中的词项权重计算方法主要是tf-idf公式，实际考虑<strong>tf、idf及文档长度</strong>3个因素</li>
</ul>
<h4 id="向量空间模型优缺点"><a href="#向量空间模型优缺点" class="headerlink" title="向量空间模型优缺点"></a>向量空间模型优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>简洁直观，可以应用到很多其他领域(文本分类、生物信息学)</li>
<li>支持部分匹配和近似匹配，结果可以排序</li>
<li>检索效果不错</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>理论上不够：基于直觉的经验性公式</li>
<li>索引项之间的独立性假设与实际不符：实际上，term的出现之间是有关系的，不是完全独立。</li>
</ul>
<h3 id="基本概率统计知识"><a href="#基本概率统计知识" class="headerlink" title="基本概率统计知识"></a>基本概率统计知识</h3><h4 id="随机试验和随机事件"><a href="#随机试验和随机事件" class="headerlink" title="随机试验和随机事件"></a>随机试验和随机事件</h4><h4 id="概率和条件概率"><a href="#概率和条件概率" class="headerlink" title="概率和条件概率"></a>概率和条件概率</h4><h4 id="乘法公式、全概率公式和贝叶斯公式"><a href="#乘法公式、全概率公式和贝叶斯公式" class="headerlink" title="乘法公式、全概率公式和贝叶斯公式"></a>乘法公式、全概率公式和贝叶斯公式</h4><h4 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h4><h4 id="概率检索模型-1"><a href="#概率检索模型-1" class="headerlink" title="概率检索模型"></a>概率检索模型</h4><ul>
<li>概率检索模型：通过<strong>概率的方法</strong>将查询和文档联系起来<ul>
<li>定义3个随机变量R、Q、D：<strong>相关度R</strong>={0，1}，<strong>查询Q</strong>={q1,q2,…}，<strong>文档D</strong>={d1,d2,…}</li>
<li>通过计算<strong>条件概率$P(R=1|Q=q,D=d)$</strong>来度量文档和查询的相关度</li>
</ul>
</li>
</ul>
<h4 id="概率排序原理PRP"><a href="#概率排序原理PRP" class="headerlink" title="概率排序原理PRP"></a>概率排序原理PRP</h4><ul>
<li>利用概率模型来估计每篇文档和需求的<strong><em>相关概率P(R=1|d,q)</em></strong>，然后对结果进行排序</li>
<li>最简单的PRP情况<ul>
<li>检索没有任何迭代因子，或者说不会对不同行为或错误采用不同的权重因子。</li>
<li>在返回一篇不想管文档或者返回一篇相关文档不成功的情况下，将失去1分</li>
<li>而检索的目标是对于用户给定的k值，返回可能性最高的文档前k篇作为结果输出。即RPR希望可以按照$P(R=1|d,q)$值的<strong>降序</strong>来排列所有文档</li>
</ul>
</li>
<li>公式的理解</li>
</ul>
<h4 id="基于检索代价的概率排序原理"><a href="#基于检索代价的概率排序原理" class="headerlink" title="基于检索代价的概率排序原理"></a>基于检索代价的概率排序原理</h4><ul>
<li>C~1~表示一篇<strong>相关文档未返回</strong>所发生的代价</li>
<li>C~0~表示<strong>返回一篇不相关文档</strong>所发生的代价</li>
<li>PRP认为，如果对于一篇特定的文档d及其所有其他未返回的文档d’都满足：</li>
<li>$C_0\cdot P(R=1|d)-C_1\cdot P(R=0|d) \le C_0\cdot P(R=1|d’)-C_1\cdot P(R=0|d’)$<ul>
<li>$C_0\cdot P(R=1|d)$：当d不相关时却返回的代价（判为相关）</li>
<li>$C_1\cdot P(R=0|d)$：当d相关却没有返回的代价</li>
<li>两者相减表示返回文档d的<strong>代价函数</strong>，即此时前者越低越好，后者越高越好</li>
</ul>
</li>
<li>那么d就应该是下一篇被返回的文档</li>
</ul>
<h4 id="二值独立概率模型BIM"><a href="#二值独立概率模型BIM" class="headerlink" title="二值独立概率模型BIM"></a>二值独立概率模型BIM</h4><ul>
<li>为了对概率函数P(R|q,d)进行估计，引入了一些简单假设。<ul>
<li>”二值“等价于布尔值：文档和查询都表示为<strong><u>词项出现与否的布尔向量</u></strong></li>
<li>类似，查询q表示成词项出现向量q</li>
<li>”独立性“指的式词项在文档中的出现是相互独立的，BIM不识别词项之间的关联。</li>
</ul>
</li>
</ul>
<h4 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h4><ul>
<li>在减少出现事件的概率估计值的同时提高未出现事件的概率估计值的方法</li>
</ul>
<h4 id="BIM模型的优缺点"><a href="#BIM模型的优缺点" class="headerlink" title="BIM模型的优缺点"></a>BIM模型的优缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>BIM模型建立在数学基础上，理论性较强</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>需要估计参数</li>
<li>原始BIM没有考虑TF、文档长度因素</li>
<li>BIM中同样存在词项独立性假设</li>
</ul>
<h4 id="理论上的概率估计方法"><a href="#理论上的概率估计方法" class="headerlink" title="理论上的概率估计方法"></a>理论上的概率估计方法</h4><ul>
<li>P~t~词项出现在一篇相关文档中的概率</li>
<li>$p_t = P(x_t=1|R=1,q) = s/S$</li>
<li>u~t~词项出现在一片不相关文档中的概率</li>
<li>$u_t=P(x_t=1|R=0, q)= (df_t-s)/(N-S)$</li>
</ul>
<h2 id="基于语言建模的检索模型"><a href="#基于语言建模的检索模型" class="headerlink" title="基于语言建模的检索模型"></a>基于语言建模的检索模型</h2><ul>
<li>传统概率模型<ul>
<li>需要对文档d与查询q的相关概率$P(R=1|q,d)$进行显示建模</li>
</ul>
</li>
<li>概率语言模型<ul>
<li>首先对每篇文档d建模得到文档的<strong>概率语言模型 $M_d$</strong></li>
<li>然后按照<strong>模型生成查询q</strong>的概率$P(q|M_d)$的高低来对文档进行排序</li>
</ul>
</li>
</ul>
<h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><h4 id="最简单的语言生成器模型"><a href="#最简单的语言生成器模型" class="headerlink" title="最简单的语言生成器模型"></a>最简单的语言生成器模型</h4><ul>
<li>一个简单的又穷自动机及其生成语言中的一些字符串<ul>
<li>$\rightarrow$指向的是自动机的初始状态</li>
<li>双圈节点对应的是终止状态</li>
</ul>
</li>
<li>如果每一个节点都有一个生成不同词项的概率分布，便得到一个语言模型，或概率语言模型，或统计语言模型<ul>
<li>语言模型的概念本质上是基于概率的</li>
</ul>
</li>
</ul>
<h4 id="有穷自动机-rightarrow-语言模型"><a href="#有穷自动机-rightarrow-语言模型" class="headerlink" title="有穷自动机$\rightarrow$语言模型"></a>有穷自动机$\rightarrow$语言模型</h4><ul>
<li>一个语言模型（LM）是从某词汇表上抽取的<strong>字符串概率的一个映射函数</strong>。对字母表$\sum$上的语言模型M有：$\sum_{s\in \sum^*}P(s)=1$</li>
<li>最简单的语言模型等价于一个仅仅包含一个节点的概率有穷自动机，只有一个生成不同词项的概率分布，因此有$\sum_{t\in V}P(t)=1$</li>
<li>假定停止概率是固定的，因此不会影响文档的排序。因此可以不考虑停止概率，但形式上得到的结果将不再是概率，而只是概率的部分项</li>
</ul>
<h4 id="语言模型的比较"><a href="#语言模型的比较" class="headerlink" title="语言模型的比较"></a>语言模型的比较</h4><ul>
<li>比较两个模型，可计算似然比，即将其中一个模型的数据生成概率除以另外一个模型数据的生成概率。</li>
</ul>
<h3 id="语言模型的种类"><a href="#语言模型的种类" class="headerlink" title="语言模型的种类"></a>语言模型的种类</h3><h4 id="对于词项序列如何求解其生成的概率值"><a href="#对于词项序列如何求解其生成的概率值" class="headerlink" title="对于词项序列如何求解其生成的概率值"></a>对于词项序列如何求解其生成的概率值</h4><ul>
<li>根据链式规则将一系列事件的概率分解成多个连续事件概率之积，每个概率是每个事件基于其历史事件的条件概率。</li>
<li>$P(t_1t_2t_3t_4)=P(t_1)P(t_2|t_1)P(t3|t_1t_2)P(t_4|t_1t_2t_3)$</li>
</ul>
<h4 id="语言模型的种类n-gram"><a href="#语言模型的种类n-gram" class="headerlink" title="语言模型的种类n-gram"></a>语言模型的种类n-gram</h4><ul>
<li><p>一元语言模型（Unigram LM）：上下文语言无关模型，是最简单的语言模型，去掉所有条件概率中的条件来独立地估计每个词项的概率</p>
<ul>
<li>$P_{uni}(t_1t_2t_3t_4) = P(t_1)P(t_2)P(t_3)P(t_4)$</li>
<li>词袋模型Bag of words</li>
</ul>
</li>
<li><p>二元语言模型（Bigram LM）：即计算条件概率时只考虑前一个词项的出现情况</p>
<ul>
<li>$P_{bi}(t_1t_2t_3t_4) = P(t_1)P(t_2|t_1)P(t_3|t_2)P(t_4|t_3)$</li>
</ul>
</li>
<li><p>三元语言模型（Trigram LM）</p>
</li>
</ul>
<h4 id="词的多项式分布"><a href="#词的多项式分布" class="headerlink" title="词的多项式分布"></a>词的多项式分布</h4><ul>
<li>词的多项式分布</li>
</ul>
<h3 id="语言模型应用到IR"><a href="#语言模型应用到IR" class="headerlink" title="语言模型应用到IR"></a>语言模型应用到IR</h3><h4 id="总体分布-amp-抽样"><a href="#总体分布-amp-抽样" class="headerlink" title="总体分布&amp;抽样"></a>总体分布&amp;抽样</h4><ul>
<li>文档模型实际是某种<strong>总体分布</strong></li>
<li>文档和查询都是该总体分布下的一个<strong>抽样样本示例</strong></li>
<li>根据文档，估计文档的模型，即求出该总体分布，然后计算该总体分布下抽样出查询的概率</li>
<li>文档 $\rightarrow$ 总体分布 $\rightarrow$ 查询</li>
</ul>
<h4 id="查询似然模型"><a href="#查询似然模型" class="headerlink" title="查询似然模型"></a>查询似然模型</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>将文档按照其余查询相关的似然$P(d|q)$排序<ul>
<li>$P(d|q)=P(d|q)\frac{P(d)}{P(q)}$</li>
</ul>
</li>
<li><p>最后会按照$P(d|q)$进行排序，它是在<strong>文档d对应的语言模型$M_d$下生成q的概率</strong></p>
</li>
<li><p>IR中的语言建模方法实际上是在<strong>对查询的过程</strong>进行建模</p>
<ul>
<li>首先每篇文档d对应一个文档模型$M_d$</li>
<li>然后计算查询被视为每个文档模型的随机抽样样本的概率</li>
<li>最后根据这些概率对文档排序<ul>
<li>$P(q|M_d) = K<em>q \prod</em>{t\in V}P(t|M<em>d)^{tf</em>{t,d}}$</li>
<li>$K_q$是查询q的多项式系数，对于某个特定查询，是一个常数可以忽略。</li>
</ul>
</li>
</ul>
</li>
<li>模型的直观意义是，用户脑子里有一篇原型文档，然后按照该文档中的词语用法来生成查询。</li>
</ul>
<h4 id="查询生成的概率估计"><a href="#查询生成的概率估计" class="headerlink" title="查询生成的概率估计"></a>查询生成的概率估计</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>采用最大似然估计：使得观察样本出现概率最大的估计<ul>
<li>$P(q|M<em>d)=\prod</em>{t\in q}P_{mle}(t|M<em>d)=\frac{tf</em>{t,d}}{L_d}$</li>
<li>$L_d$是d中的词条数目</li>
</ul>
</li>
</ul>
<h4 id="线性插值LM示例"><a href="#线性插值LM示例" class="headerlink" title="线性插值LM示例"></a>线性插值LM示例</h4><h4 id="平滑的方法：线性插值LM"><a href="#平滑的方法：线性插值LM" class="headerlink" title="平滑的方法：线性插值LM"></a>平滑的方法：线性插值LM</h4><ul>
<li><p>需要对文档LM的概率进行平滑（Smoothing），即对出现事件的概率结果进行折扣，并对未出现的词的概率赋予一定的值。</p>
</li>
<li><p>将基于<strong>文档的多项式</strong>分布和基于全部<strong>文档集</strong>估计出的多项式分布相混合</p>
</li>
<li>$P(t|d)= \lambda P_{mle}(t|M<em>d)+(1-\lambda)P</em>{mle}(t|M_c)$<ul>
<li>$\lambda \in (0,1)$ , $M_c$是基于全部文档集构造的LM</li>
</ul>
</li>
</ul>
<h4 id="扩展的LM方法"><a href="#扩展的LM方法" class="headerlink" title="扩展的LM方法"></a>扩展的LM方法</h4><ul>
<li>a查询似然类：文档建模，计算查询的似然<ul>
<li>基本QLM模型、翻译模型</li>
</ul>
</li>
<li>b文档似然类：查询建模，计算文档的似然<ul>
<li>BIM模型、相关性模型</li>
</ul>
</li>
<li>c模型比较类：文档建模，查询建模，kl距离模型</li>
</ul>
<h2 id="文本分类及朴素贝叶斯分类器"><a href="#文本分类及朴素贝叶斯分类器" class="headerlink" title="文本分类及朴素贝叶斯分类器"></a>文本分类及朴素贝叶斯分类器</h2><h3 id="本讲要点"><a href="#本讲要点" class="headerlink" title="本讲要点"></a>本讲要点</h3><ul>
<li>什么是文本分类</li>
<li>什么是朴素贝叶斯分类器</li>
<li>朴素贝叶斯分类器的生成模型</li>
<li>朴素贝叶斯分类器的性质<ul>
<li>条件独立假设&amp;位置独立性假设</li>
</ul>
</li>
<li>特征选择：互信息、x2统计量、词项频率</li>
<li>文本分类评价：宏平均和微平均</li>
</ul>
<h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><ul>
<li>给定分类体系，将一篇文本分到其中一个或者多个类别中的过程。</li>
</ul>
<ul>
<li>文本分类中，给定文档$d \in X$ 和一个固定的类别集合 $C={C_1,C_2,…,C_j}$ , 其中X表式文档空间，类别也通常称为类或类标签<ul>
<li>按类别书目：binary vs multi-class</li>
<li>按每篇文档赋予的标签书目： sing label vs multi label</li>
</ul>
</li>
</ul>
<h4 id="分类方法1：-手工方法"><a href="#分类方法1：-手工方法" class="headerlink" title="分类方法1： 手工方法"></a>分类方法1： 手工方法</h4><ul>
<li>使用人工分类方法来分类，如果专家来分类精度会非常高</li>
<li>如果问题规模和分类团队都很小时，能否保持分类结果的一致性</li>
</ul>
<h4 id="分类方法2：规则方法"><a href="#分类方法2：规则方法" class="headerlink" title="分类方法2：规则方法"></a>分类方法2：规则方法</h4><ul>
<li>繁琐，开销大</li>
</ul>
<h4 id="分类方法3：机器学习方法"><a href="#分类方法3：机器学习方法" class="headerlink" title="分类方法3：机器学习方法"></a>分类方法3：机器学习方法</h4><ul>
<li>文本分类被定义为一个学习问题，包括：<ul>
<li>通过有监督的学习，得到分类函数$\gamma$，然后将其应用于对新文档的分类</li>
</ul>
</li>
<li>一系列的分类方法：朴素贝叶斯、Rocchio、KNN、SVM</li>
<li>当学习方法基于统计时，此方法也称为统计文本分类：<ul>
<li>在统计文本分类中，对每个类别需要一些好的文档样例（训练文档）</li>
<li>需要人来标注训练文档，所以对人工分类的需求依然存在</li>
<li>标注（labeling）指对每篇文档赋予类别标签的过程</li>
</ul>
</li>
</ul>
<h4 id="基于学习的文本分类"><a href="#基于学习的文本分类" class="headerlink" title="基于学习的文本分类"></a>基于学习的文本分类</h4><ul>
<li>文档空间X<ul>
<li>文档都在该空间下表示—— 通常都是某种高维空间</li>
</ul>
</li>
<li>固定的类别集合$C={C_1,C_2,…,C_j}$<ul>
<li>类别往往根据应用的需求来人为定义</li>
</ul>
</li>
<li>训练集D，文档d用c来标记，$<d,c> \in X \times C$<ul>
<li>利用学习算法，可以学习一个分类器$\gamma$，它可以将文档映射成类别： $\gamma：X\rightarrow C$</li>
</ul>
</d,c></li>
<li>文档分类的实现<ul>
<li>对于文档空间中文档，$d \in X $,可确定$γ(d) \in C $即确定d最可能属于的类别$c_i = γ(d),c \in C$</li>
</ul>
</li>
</ul>
<h4 id="无监督-有监督的学习"><a href="#无监督-有监督的学习" class="headerlink" title="无监督/有监督的学习"></a>无监督/有监督的学习</h4><ul>
<li>supervised learning 监督学习<ul>
<li>利用一组<strong><u>已知类别的样本</u></strong>调整分类器的参数，使其达到所求性能的过程，也称为监督训练或有教师学习</li>
</ul>
</li>
<li>无监督学习<ul>
<li>若所给的学习样本<strong><em>不带有类别信息</em></strong>，就是无监督学习</li>
</ul>
</li>
</ul>
<h4 id="搜索引擎中的文本分类应用"><a href="#搜索引擎中的文本分类应用" class="headerlink" title="搜索引擎中的文本分类应用"></a>搜索引擎中的文本分类应用</h4><ul>
<li>语言识别</li>
<li>垃圾网页识别</li>
<li>是否包含淫秽内容</li>
<li>领域搜索或垂直搜索—— 搜索对象限制在某个垂直领域</li>
<li>静态查询</li>
<li>情感识别</li>
</ul>
<h4 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h4><ul>
<li>是一个概率分类器</li>
<li>文档d属于类别c的概率计算</li>
<li>$P(c|d)=\frac{P(c)P(d|c)}{P(d)} ∞ P(c)P(d|c)∞P(c)\prod_{1\le K \le n_d}{P(t_k|c)}$</li>
<li>t~k~是d中的词条，n~d~是文档的长度（词条个数）</li>
<li>P(t~k~|c)是此项t~k~出现在类别c中文档的概率，或类别c生成词项t~k~的概率，或是度量的是当c是正确类别时t~k~的贡献</li>
<li>P(c)是类别c的先验概率</li>
<li>如果文档的词项无法提供属于哪个类别的信息，那么直接选择P(c)最高的那个类别</li>
</ul>
<h3 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h3><h4 id="两种模型文本生成过程"><a href="#两种模型文本生成过程" class="headerlink" title="两种模型文本生成过程"></a>两种模型文本生成过程</h4><ul>
<li>给定类别时文档生成的条件概率计算有所不同<ul>
<li>多项式模型$P(d|c)=P(<t_1, …="" ,="" t_k,="" …,="" t_{nd}="">|c)$</t_1,></li>
<li>贝努利模型$P(d|c)=P(<e_1, …="" ,="" e_k,="" …,="" e_m="">|c)$</e_1,></li>
<li>其中 多项式模型是d中出现的词项序列（去掉词）</li>
<li>贝努利模型是一个M维的布尔向量，表示每个词项在文档d中存在与否。</li>
</ul>
</li>
<li>两种不同的文档表示方法<ul>
<li>多项式模型是文档空间X是所有词项序列的集合</li>
<li>贝努利模型是文档空间X是${0,1}^M$</li>
</ul>
</li>
</ul>
<h4 id="具有最大后验概率的类别"><a href="#具有最大后验概率的类别" class="headerlink" title="具有最大后验概率的类别"></a>具有最大后验概率的类别</h4><ul>
<li>朴素贝叶斯分类的目标是寻找“最佳”类别</li>
</ul>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ul>
<li>文本分类中，通常要将文本表示在一个<strong>高维空间</strong>下，<strong>每一维对应一个词项</strong>。特征选择是从训练集合出现的词项中选出一部分子集的过程。在文本分类过程也仅仅使用这个子集作为特征</li>
<li>特征选择有两个主要目的：<ol>
<li>通过减少有效的词汇空间来提高分类器训练和应用的效率。这对除NB之外的其他训练开销较大的分类器来说尤为重要。</li>
<li>特征选择能够去除噪音特征，从而提高分类的精度。</li>
</ol>
</li>
<li><strong>噪音特征</strong>：加入文本表示之后反而会增加新数据上的分类错误率的特征</li>
<li>由于训练集的偶然性导出的不正确的泛化结果称为<strong>过学习</strong></li>
</ul>
<h4 id="特征选择算法"><a href="#特征选择算法" class="headerlink" title="特征选择算法"></a>特征选择算法</h4><ul>
<li>给定类别c，对词汇表中的每个词项t，计算<strong>效用指标A(t,c)</strong>，然后从中选择k个具有最高值的词项作为最后的特征。</li>
</ul>
<h4 id="不同的特征选择方法"><a href="#不同的特征选择方法" class="headerlink" title="不同的特征选择方法"></a>不同的特征选择方法</h4><ul>
<li>特征选择方法主要基于其所使用特征效用指标来定义</li>
<li>特征效用指标<ul>
<li>频率法—— 选择高频词项</li>
<li>互信息—— 选择具有最高互信息的那些词项</li>
<li>卡方x^2^ </li>
</ul>
</li>
</ul>
<h3 id="分类评价"><a href="#分类评价" class="headerlink" title="分类评价"></a>分类评价</h3><ul>
<li>评价必须基于测试数据进行，而且该测试数据与训练数据完全独立。</li>
<li>很容易通过训练可以子训练集上达到很高的性能</li>
<li>常用指标：正确率、召回率、F~1~值、分类精确率等等</li>
<li>宏平均：在类别之间求平均值  微平均：将每篇文档在每个类别上的判定放入一个缓冲池，然后基于这个缓冲池计算效果指标。</li>
</ul>
<h4 id="宏平均"><a href="#宏平均" class="headerlink" title="宏平均"></a>宏平均</h4><ul>
<li>对类别集合C中的每个类都计算一个F~1~值</li>
<li>对C个结果求平均</li>
</ul>
<h4 id="微平均"><a href="#微平均" class="headerlink" title="微平均"></a>微平均</h4><ul>
<li>对类别集合C中的每个类都计算TP、FP和FN</li>
<li>将C中的这些数字累加</li>
<li>基于累加的TP、FP、FN计算P、R和F~1~</li>
</ul>
<h4 id="宏平均和微平均的适用范围"><a href="#宏平均和微平均的适用范围" class="headerlink" title="宏平均和微平均的适用范围"></a>宏平均和微平均的适用范围</h4><ul>
<li>宏平均和微平均的计算结果可能会相差很大。宏平均对每个类等同对待，而微平均则对每篇文档的判定结果等同对待</li>
<li>由于F1值忽略判断正确的负例，所以它的大小主要由判断正确的正例数目所决定，所以在微平均计算中大类起支配作用。</li>
</ul>
<h2 id="基于向量空间模型的文本分类"><a href="#基于向量空间模型的文本分类" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><ul>
<li>Rocchio方法<ul>
<li>基于质心或原型将整个向量空间划分成多个区域</li>
</ul>
</li>
<li>kNN方法<ul>
<li>将K个最邻近文档所属的主类别赋给测试文档</li>
</ul>
</li>
<li>线性分类器<ul>
<li>指基于特征的简单<strong>线性组合</strong>就可以对文档进行分类的分类器</li>
</ul>
</li>
</ul>
<h3 id="基于向量空间的分类方法"><a href="#基于向量空间的分类方法" class="headerlink" title="基于向量空间的分类方法"></a>基于向量空间的分类方法</h3><h4 id="向量空间表示"><a href="#向量空间表示" class="headerlink" title="向量空间表示"></a>向量空间表示</h4><ul>
<li>每个文档表示成一个<strong>向量</strong>，向量的每一维表示一个<strong>term</strong></li>
<li>向量可以归一化成单位长度</li>
<li>高维向量空间<ul>
<li>维度非常高</li>
<li>每个term就是一个坐标轴</li>
<li>文档表示为空间的向量</li>
</ul>
</li>
</ul>
<h4 id="向量空间模型-2"><a href="#向量空间模型-2" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>词项——文档矩阵：二值—&gt; 计数 —&gt; 权重矩阵（tf-idf）</li>
<li><p>相关性 = 向量距离 ： 欧式距离—&gt; 夹角 —&gt; 余弦相似度</p>
</li>
<li><p>利用向量空间模型进行文本分类的思路主要基于<strong>邻近假设</strong>：</p>
<ol>
<li>同一类的文档会构成一个邻近区域</li>
<li>不同类的邻近区域之间互不重叠</li>
</ol>
</li>
<li>如何找到<strong>分类面决策边界</strong>（decision boundary）</li>
</ul>
<h3 id="Rocchio方法"><a href="#Rocchio方法" class="headerlink" title="Rocchio方法"></a>Rocchio方法</h3><h4 id="Rocchio方法进行向量空间分类的思路"><a href="#Rocchio方法进行向量空间分类的思路" class="headerlink" title="Rocchio方法进行向量空间分类的思路"></a>Rocchio方法进行向量空间分类的思路</h4><ul>
<li>利用<strong>质心</strong>来定义分类边界</li>
<li>一个<strong>类别c的质心</strong>可以通过类中文档向量的平均向量或者质心想来来计算</li>
<li>计算公式：</li>
</ul>
<h4 id="Rocchio算法-1"><a href="#Rocchio算法-1" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>计算每个类的中心向量（所有文档向量的算术平均）</li>
<li>将每篇测试文档分到离它最近的那个中心向量</li>
</ul>
<h4 id="Rocchio算法中的决策边界"><a href="#Rocchio算法中的决策边界" class="headerlink" title="Rocchio算法中的决策边界"></a>Rocchio算法中的决策边界</h4><ul>
<li>利用质心来定义分类边界</li>
<li>两类的边界由那些<strong>到两个类质心等距的点集组成</strong>（超平面）</li>
</ul>
<h4 id="Rocchio分类方法的缺陷"><a href="#Rocchio分类方法的缺陷" class="headerlink" title="Rocchio分类方法的缺陷"></a>Rocchio分类方法的缺陷</h4><ul>
<li>为了遵循邻近性的要求，Rocchio 分类中的每个类别一定要近似球形，并且它们之间具有相似球半径。</li>
</ul>
<h3 id="KNN邻近方法"><a href="#KNN邻近方法" class="headerlink" title="KNN邻近方法"></a>KNN邻近方法</h3><h4 id="kNN（k邻近）方法"><a href="#kNN（k邻近）方法" class="headerlink" title="kNN（k邻近）方法"></a>kNN（k邻近）方法</h4><ul>
<li>kNN = k nearnest neighbors， k邻接</li>
<li>k = 1情况下的kNN：将每篇测试文档分给训练集中离它最近的那篇文档所属的类别。</li>
<li>1NN不很鲁棒 —— 一篇文档可能会分错类或者这篇文档本身就返常</li>
<li>k&gt;1情况下的kNN：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>kNN的基本依据<ul>
<li>根据邻近假设，一篇测试文档d将和其邻域中的训练文档应该具有相同的类别。</li>
</ul>
</li>
</ul>
<h4 id="1NN分类器"><a href="#1NN分类器" class="headerlink" title="1NN分类器"></a>1NN分类器</h4><ul>
<li>1NN分类器的判别边界是<strong>Voronoi剖分</strong>形成的多个线段的连接。Voronoi剖分会将整个平面分成|D|个凸多边形，每个多边形仅包含其对应的文档，而每个凸多边形是在二维空间种通过直线围成的凸区域。</li>
</ul>
<h4 id="小结：KNN方法"><a href="#小结：KNN方法" class="headerlink" title="小结：KNN方法"></a>小结：KNN方法</h4><ul>
<li>思路：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>KNN的基本依据：根据邻近假设，一篇测试文档d将和其领域中的训练文档应该具有相同的类别<ul>
<li>当训练集非常大的时候，KNN分类精度很高</li>
<li>当训练集非常小的时候，KNN效果很差</li>
</ul>
</li>
</ul>
<h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><ul>
<li>定义</li>
</ul>
<h2 id="基于向量空间模型的文本分类-1"><a href="#基于向量空间模型的文本分类-1" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><h3 id="二元线性SVM"><a href="#二元线性SVM" class="headerlink" title="二元线性SVM"></a>二元线性SVM</h3><ul>
<li>SVM是最大间隔分类器的一种，它是局域向量空间的机器学习方法，其目标是找到两个类别之间的一个决策边界，使之尽量远离训练集上的任意一点。</li>
<li>SVM定义的准则是<strong><u>寻找一个离数据点最远的决策面</u></strong>。从决策面到最近数据点的距离决定了<strong>分类器的间隔</strong></li>
</ul>
<h4 id="小结：SVM要点"><a href="#小结：SVM要点" class="headerlink" title="小结：SVM要点"></a>小结：SVM要点</h4><ul>
<li>线性SVM的结果分类器为：</li>
<li>SVM基本过程：<ul>
<li>基于给定训练数据集，通过二次优化过程寻找最佳的分类超平面</li>
<li>对于待分类的新数据点，利用分类函数计算该点到超平面的距离</li>
<li>距离的正负（分类函数的符号）决定了该数据点类别的归属</li>
<li>如果该点在分类器的间隔之内，分了器可以在原来的两个类之外，返回“类别未知”</li>
</ul>
</li>
<li>​</li>
</ul>
<h2 id="文本聚类"><a href="#文本聚类" class="headerlink" title="文本聚类"></a>文本聚类</h2><h3 id="聚类介绍"><a href="#聚类介绍" class="headerlink" title="聚类介绍"></a>聚类介绍</h3><h4 id="聚类的定义"><a href="#聚类的定义" class="headerlink" title="聚类的定义"></a>聚类的定义</h4><ul>
<li>文档聚类是将一系列文档按照相似性聚团成子集或者簇的过程</li>
<li>簇内文档之间应该彼此相似，相似度不大</li>
<li>聚类是一种最常见的无监督学习方法<ul>
<li>无监督学习意味着没有已标注好的数据集</li>
</ul>
</li>
</ul>
<h4 id="分类VS聚类"><a href="#分类VS聚类" class="headerlink" title="分类VS聚类"></a>分类VS聚类</h4><ul>
<li>分类：有监督的学习</li>
<li>聚类：无监督的学习</li>
<li>分类：类别事先人工定义好，并且是学习算法的输入的一部分</li>
<li>聚类：簇在没有人工输入的情况下从数据中推理而得<ul>
<li>但是很多因素会影响聚类的输出结果：簇的个数、相似度计算方法、文档的表示方式等。</li>
</ul>
</li>
</ul>
<h3 id="聚类在IR中的应用"><a href="#聚类在IR中的应用" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h3><h4 id="聚类假设"><a href="#聚类假设" class="headerlink" title="聚类假设"></a>聚类假设</h4><ul>
<li>在考虑文档和信息需求之间的相关性式，同一簇中的文档表现互相类似。</li>
<li>聚类在IR中的应用所有应用都直接或间接基于上述聚类假设</li>
</ul>
<h4 id="聚类在IR中的应用-1"><a href="#聚类在IR中的应用-1" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h4><table>
<thead>
<tr>
<th>应用</th>
<th>聚类对象</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>搜索结果聚类</td>
<td>搜索结果</td>
<td>提供面向用户的更有效的展示</td>
</tr>
<tr>
<td>“分散-集中”界面</td>
<td>文档集和文档子集</td>
<td>提供了另一种用户界面，即不需要人工输入关键词的搜索界面</td>
</tr>
<tr>
<td>文档聚类</td>
<td>文档集</td>
<td>提供了一种面向探索式浏览的有效性的信息展示法</td>
</tr>
<tr>
<td>基于语言建模的IR文档集</td>
<td>文档集</td>
<td>提高了正确率和/或召回率</td>
</tr>
<tr>
<td>基于聚类的检索</td>
<td>文档集</td>
<td>加快了搜索的速度</td>
</tr>
</tbody>
</table>
<h4 id="文档聚类用于提高召回率"><a href="#文档聚类用于提高召回率" class="headerlink" title="文档聚类用于提高召回率"></a>文档聚类用于提高召回率</h4><ul>
<li>实现将文档集中的文档进行聚类</li>
<li>当文档和查询匹配时，也返回包含d的簇所包含的其它文档</li>
<li>我们希望通过上述做法，在输入查询“car”时，也能包含“automobile”的文档</li>
<li>由于聚类算法会把包含“car”的文档和包含“automobile”的文档聚在一起</li>
</ul>
<h4 id="聚类的要求"><a href="#聚类的要求" class="headerlink" title="聚类的要求"></a>聚类的要求</h4><ul>
<li>一般目标： 将相关文档放到一个簇中，将不相关文档放到不同的簇中</li>
<li>簇的数目应该合适，以便于聚类的数据集吻合<ul>
<li>一开始，假设给定簇的数目为K</li>
<li>后面介绍K的半自动的方法</li>
</ul>
</li>
<li>其它目标：<ul>
<li>避免非常小和非常大的簇</li>
<li>定义的簇对用户来说很容易理解</li>
<li>其它……</li>
</ul>
</li>
</ul>
<h4 id="扁平聚类vs层次聚类"><a href="#扁平聚类vs层次聚类" class="headerlink" title="扁平聚类vs层次聚类"></a>扁平聚类vs层次聚类</h4><ul>
<li><p>扁平算法：</p>
<ul>
<li>通过一开始将全部或部分文档随机划分为不同的组</li>
<li>通过迭代不断修正</li>
<li>代表算法： K-均值聚类算法</li>
</ul>
</li>
<li><p>层次算法：</p>
<ul>
<li>构建具有层次结果的簇</li>
<li>自底向上（Bottom-up）的算法称为凝聚式算法</li>
<li>自顶向下的（Top-down）算法称为分裂式算法</li>
</ul>
</li>
</ul>
<h4 id="硬聚类vs软聚类"><a href="#硬聚类vs软聚类" class="headerlink" title="硬聚类vs软聚类"></a>硬聚类vs软聚类</h4><ul>
<li>硬聚类：每篇文档仅仅属于一个簇<ul>
<li>很普遍并且相对容易实现</li>
</ul>
</li>
<li>软聚类：一篇文档可以属于多个簇</li>
</ul>
<h4 id="扁平算法"><a href="#扁平算法" class="headerlink" title="扁平算法"></a>扁平算法</h4><ul>
<li>扁平算法将N篇文档划分成K个簇</li>
<li>给定一个文档集合及聚类结果簇的个数K</li>
<li><strong>寻找一个划分将这个文档集合分成K个簇，该结果满足最优划分规则</strong></li>
<li>全局优化：穷举所有的结果划分，从中选择最优的那个划分结果(无法处理)</li>
<li>高效的启发式方法：k-均值聚类算法</li>
</ul>
<h3 id="K-均值聚类算法"><a href="#K-均值聚类算法" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h3><p>最著名的聚类算法，算法十分简单，但是在很多情况下效果不错</p>
<h4 id="聚类中的文档表示"><a href="#聚类中的文档表示" class="headerlink" title="聚类中的文档表示"></a>聚类中的文档表示</h4><ul>
<li>向量空间模型</li>
<li>欧式距离计算向量之间的相关性</li>
</ul>
<h4 id="K-均值聚类算法-1"><a href="#K-均值聚类算法-1" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h4><ul>
<li>K-均值聚类算法中的每个簇都定义为其质心向量</li>
<li>划分准则：<strong>使得所有文档到其所在簇的质心向量的平方和最小</strong></li>
<li>质心向量的定义：</li>
<li>通过下列两部来实现目标优化：<ol>
<li>重分配：将每篇文档分配给离它最近的簇</li>
<li>重计算：重新计算每个簇的质心向量</li>
</ol>
</li>
</ul>
<h4 id="K-均值聚类算法一定会收敛"><a href="#K-均值聚类算法一定会收敛" class="headerlink" title="K-均值聚类算法一定会收敛"></a>K-均值聚类算法一定会收敛</h4><ul>
<li>RSS（Residual Sum of Squares）残差平方和 = 所有簇上的文档向量到质心向量的距离的平方和的总和</li>
<li>每次重新分配之后RSS会下降<ul>
<li>因为每个向量都被移到离它最近的质心向量所代表的簇中</li>
</ul>
</li>
<li>每次重新计算之后RSS也会下降</li>
<li>可能的聚类结果是有穷的，因此一定会收敛到一个固定点</li>
<li>如果出现了等值的情况，算法都采用前后一致的方法来处理</li>
<li>如果不关心少许文档在不同簇之间来回交叉的话，收敛速度通常会很快。但是完全收敛需要很庞大的迭代过程</li>
</ul>
<h4 id="K-均值聚类算法的最优性"><a href="#K-均值聚类算法的最优性" class="headerlink" title="K-均值聚类算法的最优性"></a>K-均值聚类算法的最优性</h4><ul>
<li>收敛并不意味着会达到<strong>全局最优</strong>的聚类结果，这是K-均值聚类算法最大缺点之一。如果开始的种子选择不好，最终的聚类结果可能会非常糟糕。</li>
</ul>
<h4 id="K-均值聚类算法的初始化"><a href="#K-均值聚类算法的初始化" class="headerlink" title="K-均值聚类算法的初始化"></a>K-均值聚类算法的初始化</h4><ul>
<li>种子的随机选择只是K-均值聚类算法的中初始化方法之一</li>
<li>随机选择不太鲁棒：可能会获得一个次优的聚类结果</li>
<li>更好的办法：<ul>
<li>非随机地采用某些启发式方法来选择种子（比如，过滤掉一些离群点，或则寻找具有较好文档空间覆盖度的种子集合）</li>
<li>采用层级聚类算法寻找好的种子</li>
<li>选择$i$次不同的随机种子集合，对每次产生的随机种子集合运行<strong><em>K</em></strong>-均值聚类算法，最后选择具有最小RSS的聚类结果。</li>
</ul>
</li>
</ul>
<h4 id="K-均值聚类算法的时间复杂度"><a href="#K-均值聚类算法的时间复杂度" class="headerlink" title="K-均值聚类算法的时间复杂度"></a>K-均值聚类算法的时间复杂度</h4><p>O(<em>IKNM</em>)-线性</p>
<h3 id="聚类评价"><a href="#聚类评价" class="headerlink" title="聚类评价"></a>聚类评价</h3><h4 id="内部准则"><a href="#内部准则" class="headerlink" title="内部准则"></a>内部准则</h4><p>一个内部准则的例子：K-均值聚类算法的$RSS$值。</p>
<p>但是内部准则往往不能评价聚类在应用中的实际效用</p>
<h4 id="外部准则"><a href="#外部准则" class="headerlink" title="外部准则"></a>外部准则</h4><ul>
<li>按照用户定义的<strong>分类</strong>结果来评价，即对一个分好类的数据集进行聚类，将聚类结果和事先的类别情况进行比照，得到最后的评价结果。</li>
<li>目标：<strong>聚类结果和给定分类结果一致</strong></li>
</ul>
<h4 id="纯度"><a href="#纯度" class="headerlink" title="纯度"></a>纯度</h4><ul>
<li>对每个簇，找到类别$c_j$，该类别包含$w<em>k$中的元素最多，为$n</em>{kj}$个，也就是说$w_k$的元素最多分布在$c_j$中</li>
<li>将所有n_{kj}求和，然后除以所有的文档数目N</li>
</ul>
<h3 id="簇个数确定"><a href="#簇个数确定" class="headerlink" title="簇个数确定"></a>簇个数确定</h3><ul>
<li>基本思路：<ul>
<li>从一个簇开始（K=1）</li>
<li>不断增加簇</li>
<li>对每个新的簇增加一个惩罚项</li>
</ul>
</li>
<li>在惩罚项和RSS之间折中，选择满足最佳折中条件的K</li>
<li>给定聚类结果，定义文档的代价为其到质心向量的距离(失真率)</li>
<li>定义全部失真率RSS(K)为所有文档代价和</li>
<li>对每个簇一个惩罚项$\lambda$ ，对于具有K个簇的聚类结果，总的聚类惩罚项为K$\lambda$。</li>
<li>定义聚类结果的所有开销为失真率和总聚类惩罚项的和：RSS(K)+K$\lambda$</li>
<li>选择使得(RSS(k)+Kℷ)最小的K值</li>
</ul>
<h4 id="本讲小结-1"><a href="#本讲小结-1" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>聚类的概念</li>
<li>聚类在IR中的应用</li>
<li>K-均值聚类算法</li>
<li>聚类评价</li>
<li>簇个数确定</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/信息检索/" rel="tag"># 信息检索</a>
          
            <a href="/tags/复习/" rel="tag"># 复习</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/19/计算机图形学专题复习/" rel="next" title="计算机图形学复习要点">
                <i class="fa fa-chevron-left"></i> 计算机图形学复习要点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/01/Create-reverse-table/" rel="prev" title="Create reverse table">
                Create reverse table <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a industrious programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#信息检索"><span class="nav-number">1.</span> <span class="nav-text">信息检索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IR新课题"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">IR新课题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-布尔检索"><span class="nav-number">1.1.</span> <span class="nav-text">2.布尔检索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信息检索模型概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">信息检索模型概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文档表示"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">文档表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询表示"><span class="nav-number">1.1.1.1.2.</span> <span class="nav-text">查询表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#相关度计算"><span class="nav-number">1.1.1.1.3.</span> <span class="nav-text">相关度计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非结构化数据"><span class="nav-number">1.1.1.1.4.</span> <span class="nav-text">非结构化数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结构化数据"><span class="nav-number">1.1.1.1.5.</span> <span class="nav-text">结构化数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#聚类（clustering）"><span class="nav-number">1.1.1.1.6.</span> <span class="nav-text">聚类（clustering）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分类（classification）"><span class="nav-number">1.1.1.1.7.</span> <span class="nav-text">分类（classification）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔模型：优缺点"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">布尔模型：优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信息检索的基本假设"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">信息检索的基本假设</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#典型的搜索模型"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">典型的搜索模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回文档的好坏"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">返回文档的好坏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查准率"><span class="nav-number">1.1.1.5.1.</span> <span class="nav-text">查准率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#召回率"><span class="nav-number">1.1.1.5.2.</span> <span class="nav-text">召回率</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#倒排索引"><span class="nav-number">1.1.2.</span> <span class="nav-text">倒排索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#倒排索引建立步骤"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">倒排索引建立步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔检索模型"><span class="nav-number">1.1.3.</span> <span class="nav-text">布尔检索模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文档表示-1"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">文档表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询表示-1"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">查询表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关度计算-1"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">相关度计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#形式化表示"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">形式化表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔检索模型：布尔代数"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">布尔检索模型：布尔代数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#布尔变量"><span class="nav-number">1.1.3.5.1.</span> <span class="nav-text">布尔变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#布尔操作（关系）"><span class="nav-number">1.1.3.5.2.</span> <span class="nav-text">布尔操作（关系）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#布尔表达式"><span class="nav-number">1.1.3.5.3.</span> <span class="nav-text">布尔表达式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精确匹配"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">精确匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询优化"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">查询优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-词项词典和倒排记录表"><span class="nav-number">1.2.</span> <span class="nav-text">3.词项词典和倒排记录表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建立词项词典"><span class="nav-number">1.2.1.</span> <span class="nav-text">建立词项词典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文档解析"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">文档解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词条化"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">词条化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停用词"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">停用词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词项归一化"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">词项归一化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词干还原"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">词干还原</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词形归并"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">词形归并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区别："><span class="nav-number">1.2.1.7.</span> <span class="nav-text">区别：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现倒排记录表"><span class="nav-number">1.2.2.</span> <span class="nav-text">实现倒排记录表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合并算法"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">合并算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于调表的倒排记录表快速合并算法"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">基于调表的倒排记录表快速合并算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#短语查询"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">短语查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二元词索引"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">二元词索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扩展的二元词索引"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">扩展的二元词索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#位置信息索引"><span class="nav-number">1.2.2.3.3.</span> <span class="nav-text">位置信息索引</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-索引构建"><span class="nav-number">1.3.</span> <span class="nav-text">4.索引构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件基础"><span class="nav-number">1.3.1.</span> <span class="nav-text">硬件基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语资料库"><span class="nav-number">1.3.2.</span> <span class="nav-text">语资料库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引构建算法"><span class="nav-number">1.3.3.</span> <span class="nav-text">索引构建算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">基于块的排序索引算法（BSBI：Blocked sort-based Indexing）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基于BSBI排序算法存在的问题"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">基于BSBI排序算法存在的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式索引构建（Distributed-indexing）"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">分布式索引构建（Distributed indexing）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态索引"><span class="nav-number">1.3.4.</span> <span class="nav-text">动态索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态索引构建方法"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">动态索引构建方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主索引与辅助索引存在的问题"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">主索引与辅助索引存在的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对数合并"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">对数合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-索引压缩"><span class="nav-number">1.4.</span> <span class="nav-text">4.索引压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#压缩"><span class="nav-number">1.4.1.</span> <span class="nav-text">压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩倒排索引的原因"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">压缩倒排索引的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词项统计量"><span class="nav-number">1.4.2.</span> <span class="nav-text">词项统计量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词典压缩"><span class="nav-number">1.4.3.</span> <span class="nav-text">词典压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有损压缩和无损压缩"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">有损压缩和无损压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Heaps定律：M-kT-b"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Heaps定律：M=kT^b^</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zipf定律"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Zipf定律</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要压缩词典"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">为什么要压缩词典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩词项列表：将词典看成单一字符串"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">压缩词项列表：将词典看成单一字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按块存储（Blocking）"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">按块存储（Blocking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前端编码"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">前端编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#倒排记录表压缩"><span class="nav-number">1.4.4.</span> <span class="nav-text">倒排记录表压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#倒排记录表：相反的两点"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">倒排记录表：相反的两点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#倒排记录表项中文档ID的间距（GAP）"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">倒排记录表项中文档ID的间距（GAP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变长度编码"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">可变长度编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Web搜索"><span class="nav-number">1.5.</span> <span class="nav-text">5.Web搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Web搜索基础"><span class="nav-number">1.5.1.</span> <span class="nav-text">Web搜索基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重复文档"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">重复文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相似性计算"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">相似性计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结：近似重复检测"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">小结：近似重复检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web采集"><span class="nav-number">1.5.2.</span> <span class="nav-text">Web采集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#采集器"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">采集器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#采集器必须具有的功能"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">采集器必须具有的功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#采集器基本架构"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">采集器基本架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web-图"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Web 图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Web-→Web图"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">Web →Web图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#邻接表"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接分析"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">链接分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Web是有向图"><span class="nav-number">1.5.2.4.1.</span> <span class="nav-text">Web是有向图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#索引锚文本"><span class="nav-number">1.5.2.4.2.</span> <span class="nav-text">索引锚文本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结：锚文本"><span class="nav-number">1.5.2.4.3.</span> <span class="nav-text">小结：锚文本</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接分析：PageRank"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">链接分析：PageRank</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PageRank"><span class="nav-number">1.5.2.5.1.</span> <span class="nav-text">PageRank</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询处理"><span class="nav-number">1.5.2.5.2.</span> <span class="nav-text">查询处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PageRank打分"><span class="nav-number">1.5.2.5.3.</span> <span class="nav-text">PageRank打分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#随机跳转（Teleporting）"><span class="nav-number">1.5.2.5.4.</span> <span class="nav-text">随机跳转（Teleporting）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#马尔科夫链"><span class="nav-number">1.5.2.5.5.</span> <span class="nav-text">马尔科夫链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#邻接矩阵A→概率转移矩阵P"><span class="nav-number">1.5.2.5.6.</span> <span class="nav-text">邻接矩阵A→概率转移矩阵P</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#概率向量的变化"><span class="nav-number">1.5.2.5.7.</span> <span class="nav-text">概率向量的变化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接分析：HITS"><span class="nav-number">1.5.3.</span> <span class="nav-text">链接分析：HITS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-向量模型"><span class="nav-number">1.6.</span> <span class="nav-text">6.向量模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序式检索"><span class="nav-number">1.6.1.</span> <span class="nav-text">排序式检索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序检索模型"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">排序检索模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过多、过少不再是问题"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">过多、过少不再是问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序检索的基本—-评分"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">排序检索的基本—-评分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#评分方案一—-Jaccard系数"><span class="nav-number">1.6.1.3.1.</span> <span class="nav-text">评分方案一—-Jaccard系数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词项频率"><span class="nav-number">1.6.2.</span> <span class="nav-text">词项频率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#词项–文档二值关联矩阵"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">词项–文档二值关联矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词项—文档词频关联矩阵"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">词项—文档词频关联矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词袋模型（Bag-of-words）"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">词袋模型（Bag of words）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#词项频率tf（Term-frequency）"><span class="nav-number">1.6.2.3.1.</span> <span class="nav-text">词项频率tf（Term frequency）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tf-idf权重计算"><span class="nav-number">1.6.3.</span> <span class="nav-text">tf-idf权重计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#罕见词所期望的权重"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">罕见词所期望的权重</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见词项所期望的权重"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">常见词项所期望的权重</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文档频率（Document-frequency，df）"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">文档频率（Document frequency，df）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idf（inverse-document-frequency）逆文档频率"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">idf（inverse document frequency）逆文档频率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idf对排序的影响"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">idf对排序的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文档集频率和文档频率"><span class="nav-number">1.6.3.6.</span> <span class="nav-text">文档集频率和文档频率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tf–idf文档-逆文档频率（单个词）"><span class="nav-number">1.6.3.7.</span> <span class="nav-text">tf–idf文档-逆文档频率（单个词）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Query-最终文档排序"><span class="nav-number">1.6.3.8.</span> <span class="nav-text">Query 最终文档排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向量空间模型"><span class="nav-number">1.6.4.</span> <span class="nav-text">向量空间模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文档表示成向量"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">文档表示成向量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queries表示成向量"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">Queries表示成向量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用夹角代替距离"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">利用夹角代替距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文档长度归一化"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">文档长度归一化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-检索系统"><span class="nav-number">1.7.</span> <span class="nav-text">6.检索系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序的重要性"><span class="nav-number">1.7.1.</span> <span class="nav-text">排序的重要性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#摘要阅读"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">摘要阅读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点击"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">点击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果排序的实现"><span class="nav-number">1.7.2.</span> <span class="nav-text">结果排序的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tf和idf的存储"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">tf和idf的存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精确top-K检索机器加速办法"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">精确top K检索机器加速办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速计算余弦相似度"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">快速计算余弦相似度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序法N中选K"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">堆排序法N中选K</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提前终止计算"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">提前终止计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非精确top-K检索的可行性"><span class="nav-number">1.7.2.6.</span> <span class="nav-text">非精确top K检索的可行性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评价"><span class="nav-number">1.8.</span> <span class="nav-text">评价</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#评价方式"><span class="nav-number">1.8.1.</span> <span class="nav-text">评价方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#效率（Efficiency）"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">效率（Efficiency）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#效果（Effectiveness）"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">效果（Effectiveness）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他指标"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">其他指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#评价效果"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">评价效果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无序检索结果的评价"><span class="nav-number">1.8.2.</span> <span class="nav-text">无序检索结果的评价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对单个查询进行评估的指标"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">对单个查询进行评估的指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对整个文档集合的划分"><span class="nav-number">1.8.2.1.1.</span> <span class="nav-text">对整个文档集合的划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#评价指标"><span class="nav-number">1.8.2.1.2.</span> <span class="nav-text">评价指标</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正确率和召回率的问题"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">正确率和召回率的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#召回率的计算"><span class="nav-number">1.8.2.2.1.</span> <span class="nav-text">召回率的计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用查准率-查全率的问题"><span class="nav-number">1.8.2.2.2.</span> <span class="nav-text">使用查准率/查全率的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#综合评价准则-F-P和R融合"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">综合评价准则 F=P和R融合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精确率不适合IR的原因"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">精确率不适合IR的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序检索结果的评价"><span class="nav-number">1.8.3.</span> <span class="nav-text">有序检索结果的评价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#评价排序后的结果"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">评价排序后的结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P-R的优缺点"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">P-R的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于P-R曲线的单一指标"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">基于P-R曲线的单一指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更多的评价准则：AP"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">更多的评价准则：AP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不考虑召回率"><span class="nav-number">1.8.3.5.</span> <span class="nav-text">不考虑召回率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#宏平均vs微平均"><span class="nav-number">1.8.3.6.</span> <span class="nav-text">宏平均vs微平均</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平均查准率均值-Mean-Average-Precision-MAP"><span class="nav-number">1.8.3.7.</span> <span class="nav-text">平均查准率均值 Mean Average Precision(MAP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向用户的评价指标"><span class="nav-number">1.8.3.8.</span> <span class="nav-text">面向用户的评价指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GMAP"><span class="nav-number">1.8.3.9.</span> <span class="nav-text">GMAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NDCG"><span class="nav-number">1.8.3.10.</span> <span class="nav-text">NDCG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#摘要"><span class="nav-number">1.8.3.11.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本讲小结"><span class="nav-number">1.8.3.12.</span> <span class="nav-text">本讲小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关反馈及查询扩展"><span class="nav-number">1.9.</span> <span class="nav-text">相关反馈及查询扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动机"><span class="nav-number">1.9.1.</span> <span class="nav-text">动机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#搜索中提高召回率的方法"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">搜索中提高召回率的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于召回率Recall"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">关于召回率Recall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提高召回率的方法"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">提高召回率的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关反馈基础"><span class="nav-number">1.9.2.</span> <span class="nav-text">相关反馈基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关反馈的基本思想"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">相关反馈的基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关反馈分类"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">相关反馈分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关反馈详细介绍"><span class="nav-number">1.9.3.</span> <span class="nav-text">相关反馈详细介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关反馈中的核心概念：质心"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">相关反馈中的核心概念：质心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关反馈基本理论"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">相关反馈基本理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocchio算法"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">Rocchio算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关反馈策略的评价"><span class="nav-number">1.9.3.4.</span> <span class="nav-text">相关反馈策略的评价</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#评价的误区"><span class="nav-number">1.9.3.5.</span> <span class="nav-text">评价的误区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询扩展"><span class="nav-number">1.9.3.6.</span> <span class="nav-text">查询扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概率检索模型"><span class="nav-number">1.10.</span> <span class="nav-text">概率检索模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向量空间模型回顾"><span class="nav-number">1.10.1.</span> <span class="nav-text">向量空间模型回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#向量空间模型-1"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">向量空间模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向量空间模型优缺点"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">向量空间模型优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-1"><span class="nav-number">1.10.1.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-1"><span class="nav-number">1.10.1.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概率统计知识"><span class="nav-number">1.10.2.</span> <span class="nav-text">基本概率统计知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#随机试验和随机事件"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">随机试验和随机事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#概率和条件概率"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">概率和条件概率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乘法公式、全概率公式和贝叶斯公式"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">乘法公式、全概率公式和贝叶斯公式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件独立性"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">事件独立性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#概率检索模型-1"><span class="nav-number">1.10.2.5.</span> <span class="nav-text">概率检索模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#概率排序原理PRP"><span class="nav-number">1.10.2.6.</span> <span class="nav-text">概率排序原理PRP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于检索代价的概率排序原理"><span class="nav-number">1.10.2.7.</span> <span class="nav-text">基于检索代价的概率排序原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二值独立概率模型BIM"><span class="nav-number">1.10.2.8.</span> <span class="nav-text">二值独立概率模型BIM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平滑"><span class="nav-number">1.10.2.9.</span> <span class="nav-text">平滑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIM模型的优缺点"><span class="nav-number">1.10.2.10.</span> <span class="nav-text">BIM模型的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-2"><span class="nav-number">1.10.2.10.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-2"><span class="nav-number">1.10.2.10.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理论上的概率估计方法"><span class="nav-number">1.10.2.11.</span> <span class="nav-text">理论上的概率估计方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于语言建模的检索模型"><span class="nav-number">1.11.</span> <span class="nav-text">基于语言建模的检索模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语言模型"><span class="nav-number">1.11.1.</span> <span class="nav-text">语言模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最简单的语言生成器模型"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">最简单的语言生成器模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有穷自动机-rightarrow-语言模型"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">有穷自动机$\rightarrow$语言模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语言模型的比较"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">语言模型的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语言模型的种类"><span class="nav-number">1.11.2.</span> <span class="nav-text">语言模型的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对于词项序列如何求解其生成的概率值"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">对于词项序列如何求解其生成的概率值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语言模型的种类n-gram"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">语言模型的种类n-gram</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词的多项式分布"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">词的多项式分布</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语言模型应用到IR"><span class="nav-number">1.11.3.</span> <span class="nav-text">语言模型应用到IR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总体分布-amp-抽样"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">总体分布&抽样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询似然模型"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">查询似然模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询生成的概率估计"><span class="nav-number">1.11.3.3.</span> <span class="nav-text">查询生成的概率估计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性插值LM示例"><span class="nav-number">1.11.3.4.</span> <span class="nav-text">线性插值LM示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平滑的方法：线性插值LM"><span class="nav-number">1.11.3.5.</span> <span class="nav-text">平滑的方法：线性插值LM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展的LM方法"><span class="nav-number">1.11.3.6.</span> <span class="nav-text">扩展的LM方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本分类及朴素贝叶斯分类器"><span class="nav-number">1.12.</span> <span class="nav-text">文本分类及朴素贝叶斯分类器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本讲要点"><span class="nav-number">1.12.1.</span> <span class="nav-text">本讲要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文本分类"><span class="nav-number">1.12.2.</span> <span class="nav-text">文本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分类方法1：-手工方法"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">分类方法1： 手工方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类方法2：规则方法"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">分类方法2：规则方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类方法3：机器学习方法"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">分类方法3：机器学习方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于学习的文本分类"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">基于学习的文本分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无监督-有监督的学习"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">无监督/有监督的学习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#搜索引擎中的文本分类应用"><span class="nav-number">1.12.2.6.</span> <span class="nav-text">搜索引擎中的文本分类应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#朴素贝叶斯分类器"><span class="nav-number">1.12.2.7.</span> <span class="nav-text">朴素贝叶斯分类器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#朴素贝叶斯理论"><span class="nav-number">1.12.3.</span> <span class="nav-text">朴素贝叶斯理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两种模型文本生成过程"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">两种模型文本生成过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具有最大后验概率的类别"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">具有最大后验概率的类别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特征选择"><span class="nav-number">1.12.4.</span> <span class="nav-text">特征选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特征选择算法"><span class="nav-number">1.12.4.1.</span> <span class="nav-text">特征选择算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同的特征选择方法"><span class="nav-number">1.12.4.2.</span> <span class="nav-text">不同的特征选择方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类评价"><span class="nav-number">1.12.5.</span> <span class="nav-text">分类评价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#宏平均"><span class="nav-number">1.12.5.1.</span> <span class="nav-text">宏平均</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微平均"><span class="nav-number">1.12.5.2.</span> <span class="nav-text">微平均</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#宏平均和微平均的适用范围"><span class="nav-number">1.12.5.3.</span> <span class="nav-text">宏平均和微平均的适用范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于向量空间模型的文本分类"><span class="nav-number">1.13.</span> <span class="nav-text">基于向量空间模型的文本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于向量空间的分类方法"><span class="nav-number">1.13.1.</span> <span class="nav-text">基于向量空间的分类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#向量空间表示"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">向量空间表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向量空间模型-2"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">向量空间模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rocchio方法"><span class="nav-number">1.13.2.</span> <span class="nav-text">Rocchio方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocchio方法进行向量空间分类的思路"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">Rocchio方法进行向量空间分类的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocchio算法-1"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">Rocchio算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocchio算法中的决策边界"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">Rocchio算法中的决策边界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rocchio分类方法的缺陷"><span class="nav-number">1.13.2.4.</span> <span class="nav-text">Rocchio分类方法的缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KNN邻近方法"><span class="nav-number">1.13.3.</span> <span class="nav-text">KNN邻近方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kNN（k邻近）方法"><span class="nav-number">1.13.3.1.</span> <span class="nav-text">kNN（k邻近）方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1NN分类器"><span class="nav-number">1.13.3.2.</span> <span class="nav-text">1NN分类器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结：KNN方法"><span class="nav-number">1.13.3.3.</span> <span class="nav-text">小结：KNN方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性分类器"><span class="nav-number">1.13.3.4.</span> <span class="nav-text">线性分类器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于向量空间模型的文本分类-1"><span class="nav-number">1.14.</span> <span class="nav-text">基于向量空间模型的文本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二元线性SVM"><span class="nav-number">1.14.1.</span> <span class="nav-text">二元线性SVM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结：SVM要点"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">小结：SVM要点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本聚类"><span class="nav-number">1.15.</span> <span class="nav-text">文本聚类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#聚类介绍"><span class="nav-number">1.15.1.</span> <span class="nav-text">聚类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#聚类的定义"><span class="nav-number">1.15.1.1.</span> <span class="nav-text">聚类的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类VS聚类"><span class="nav-number">1.15.1.2.</span> <span class="nav-text">分类VS聚类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚类在IR中的应用"><span class="nav-number">1.15.2.</span> <span class="nav-text">聚类在IR中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#聚类假设"><span class="nav-number">1.15.2.1.</span> <span class="nav-text">聚类假设</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚类在IR中的应用-1"><span class="nav-number">1.15.2.2.</span> <span class="nav-text">聚类在IR中的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文档聚类用于提高召回率"><span class="nav-number">1.15.2.3.</span> <span class="nav-text">文档聚类用于提高召回率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚类的要求"><span class="nav-number">1.15.2.4.</span> <span class="nav-text">聚类的要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扁平聚类vs层次聚类"><span class="nav-number">1.15.2.5.</span> <span class="nav-text">扁平聚类vs层次聚类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬聚类vs软聚类"><span class="nav-number">1.15.2.6.</span> <span class="nav-text">硬聚类vs软聚类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扁平算法"><span class="nav-number">1.15.2.7.</span> <span class="nav-text">扁平算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K-均值聚类算法"><span class="nav-number">1.15.3.</span> <span class="nav-text">K-均值聚类算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#聚类中的文档表示"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">聚类中的文档表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#K-均值聚类算法-1"><span class="nav-number">1.15.3.2.</span> <span class="nav-text">K-均值聚类算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#K-均值聚类算法一定会收敛"><span class="nav-number">1.15.3.3.</span> <span class="nav-text">K-均值聚类算法一定会收敛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#K-均值聚类算法的最优性"><span class="nav-number">1.15.3.4.</span> <span class="nav-text">K-均值聚类算法的最优性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#K-均值聚类算法的初始化"><span class="nav-number">1.15.3.5.</span> <span class="nav-text">K-均值聚类算法的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#K-均值聚类算法的时间复杂度"><span class="nav-number">1.15.3.6.</span> <span class="nav-text">K-均值聚类算法的时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚类评价"><span class="nav-number">1.15.4.</span> <span class="nav-text">聚类评价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部准则"><span class="nav-number">1.15.4.1.</span> <span class="nav-text">内部准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外部准则"><span class="nav-number">1.15.4.2.</span> <span class="nav-text">外部准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#纯度"><span class="nav-number">1.15.4.3.</span> <span class="nav-text">纯度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#簇个数确定"><span class="nav-number">1.15.5.</span> <span class="nav-text">簇个数确定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本讲小结-1"><span class="nav-number">1.15.5.1.</span> <span class="nav-text">本讲小结</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("KzDP5NgGACc0bKLgfEtJ8Xrk-gzGzoHsz", "nGixqUVUQJjtTFuvDaoKrMo0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

  

  

  

</body>
</html>
