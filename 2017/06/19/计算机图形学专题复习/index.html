<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="复习,计算机图形学," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="计算机图形学复习要点第一章 计算机图形学概述计算机图形的概念与研究的内容 图形的概念  广义的图形概念  凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：  自然景物 照片和图片 工程图、设计图和方框图 人工美术绘画、雕塑品 用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形   计算机图形学中的图形概念 是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色">
<meta name="keywords" content="复习,计算机图形学">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机图形学复习要点">
<meta property="og:url" content="http://yoursite.com/2017/06/19/计算机图形学专题复习/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="计算机图形学复习要点第一章 计算机图形学概述计算机图形的概念与研究的内容 图形的概念  广义的图形概念  凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：  自然景物 照片和图片 工程图、设计图和方框图 人工美术绘画、雕塑品 用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形   计算机图形学中的图形概念 是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色">
<meta property="og:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%A4%9A%E8%BE%B9%E5%BD%A2y%E7%AD%92.png">
<meta property="og:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E8%BE%B9y%E7%AD%92.png">
<meta property="og:updated_time" content="2017-06-24T12:39:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机图形学复习要点">
<meta name="twitter:description" content="计算机图形学复习要点第一章 计算机图形学概述计算机图形的概念与研究的内容 图形的概念  广义的图形概念  凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：  自然景物 照片和图片 工程图、设计图和方框图 人工美术绘画、雕塑品 用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形   计算机图形学中的图形概念 是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色">
<meta name="twitter:image" content="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%A4%9A%E8%BE%B9%E5%BD%A2y%E7%AD%92.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/19/计算机图形学专题复习/"/>





  <title> 计算机图形学复习要点 | Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/计算机图形学专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                计算机图形学复习要点
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T21:10:20+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/19/计算机图形学专题复习/" class="leancloud_visitors" data-flag-title="计算机图形学复习要点">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机图形学复习要点"><a href="#计算机图形学复习要点" class="headerlink" title="计算机图形学复习要点"></a>计算机图形学复习要点</h1><h2 id="第一章-计算机图形学概述"><a href="#第一章-计算机图形学概述" class="headerlink" title="第一章 计算机图形学概述"></a>第一章 计算机图形学概述</h2><h4 id="计算机图形的概念与研究的内容"><a href="#计算机图形的概念与研究的内容" class="headerlink" title="计算机图形的概念与研究的内容"></a>计算机图形的概念与研究的内容</h4><ol>
<li><p>图形的概念</p>
<ul>
<li><p>广义的图形概念 </p>
<p>凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：</p>
<ul>
<li>自然景物</li>
<li>照片和图片</li>
<li>工程图、设计图和方框图</li>
<li>人工美术绘画、雕塑品</li>
<li>用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形</li>
</ul>
</li>
<li><p>计算机图形学中的图形概念</p>
<p>是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色彩等非几何要素构成的，从现实世界中抽象出来的带有灰度、色彩及形状的图或形。</p>
</li>
</ul>
</li>
<li><p>计算机图形学的研究内容</p>
<p>用计算机生成景物的数字模型，并将它显示在计算机屏幕上，或者绘制在纸张或胶片上。它是研究如何在计算机环境下生成、处理和显示图形的一门学科。</p>
<p>主要研究对象：</p>
<ul>
<li>景物的几何建模方法(modeling)对模型的处理方法</li>
<li>几何模型的绘制技术(rendering)</li>
<li>图形输入和控制的人机交互界面(userinterface)。</li>
</ul>
</li>
</ol>
<h4 id="图形学发展史"><a href="#图形学发展史" class="headerlink" title="图形学发展史"></a>图形学发展史</h4><h4 id="计算机图形的应用"><a href="#计算机图形的应用" class="headerlink" title="计算机图形的应用"></a>计算机图形的应用</h4><ol>
<li>计算机辅助设计与制造</li>
<li>地理信息系统</li>
<li>科学计算可视化</li>
<li>计算机动画和艺术</li>
<li>计算机模拟和仿真</li>
<li>虚拟现实</li>
</ol>
<h2 id="第二章-计算机绘图初步认识"><a href="#第二章-计算机绘图初步认识" class="headerlink" title="第二章 计算机绘图初步认识"></a>第二章 计算机绘图初步认识</h2><h4 id="如何在计算机上绘图"><a href="#如何在计算机上绘图" class="headerlink" title="如何在计算机上绘图"></a>如何在计算机上绘图</h4><ol>
<li>计算机绘图的一般方法</li>
</ol>
<ol>
<li>一般图形的显示流程</li>
</ol>
<p>OpenGL图形软件包简介</p>
<h2 id="第三章-计算机图形系统及硬件"><a href="#第三章-计算机图形系统及硬件" class="headerlink" title="第三章 计算机图形系统及硬件"></a>第三章 计算机图形系统及硬件</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>计算机系统中的图形设备</li>
<li>图形的输入输出处理流程</li>
<li>图形工作站与PC机</li>
</ol>
<h4 id="图形显示原理"><a href="#图形显示原理" class="headerlink" title="图形显示原理"></a>图形显示原理</h4><ol>
<li>CRT显示器<ul>
<li>CRT显示原理</li>
<li>彩色CRT的显示原理</li>
<li>光栅扫描式的图形显示器</li>
<li>随机扫描的图形显示器</li>
</ul>
</li>
<li>液晶显示器</li>
<li>等离子显示器</li>
<li>显卡</li>
</ol>
<h2 id="第四章-基本光栅图形算法"><a href="#第四章-基本光栅图形算法" class="headerlink" title="第四章 基本光栅图形算法"></a>第四章 基本光栅图形算法</h2><h4 id="直线生成算法"><a href="#直线生成算法" class="headerlink" title="直线生成算法"></a>直线生成算法</h4><ol>
<li><p>DDA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dda</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> k,i;</div><div class="line">  <span class="comment">//k 即起点和中的横纵坐标距离较大者的距离</span></div><div class="line">  <span class="comment">//即 将距离大者分为k段</span></div><div class="line">  <span class="keyword">float</span> x,y,dx,dy;</div><div class="line">  k=<span class="built_in">abs</span>(x2-x1);</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">abs</span>(y2-y1)&gt;k) k=<span class="built_in">abs</span>(y2-y1);</div><div class="line">  dx=<span class="keyword">float</span>(x2-x1)/k;  <span class="comment">//增量，每次横坐标增量</span></div><div class="line">  dy=<span class="keyword">float</span>(y2-y1)/k;  <span class="comment">//每次纵坐标增量 </span></div><div class="line">  <span class="comment">//有一个的增量&lt;1，另一个增量=1</span></div><div class="line">  x=<span class="keyword">float</span>(x1);</div><div class="line">  y=<span class="keyword">float</span>(y1);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">    gl_Point(<span class="keyword">int</span>(x+<span class="number">0.5</span>),<span class="keyword">int</span>(y+<span class="number">0.5</span>));	<span class="comment">//取整</span></div><div class="line">    x=x+dx;</div><div class="line">    y=y+dy;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该算法计算量大，产生一个象素需要两次加法，两次取整。还需要除法，增加硬件难度。</p>
</li>
<li><p>正负法</p>
</li>
<li><p>Bresenham算法</p>
</li>
</ol>
<h4 id="圆弧生成算法"><a href="#圆弧生成算法" class="headerlink" title="圆弧生成算法"></a>圆弧生成算法</h4><ol>
<li>正负法</li>
<li>Bresenham算法</li>
<li>圆弧的离散生成</li>
</ol>
<h4 id="多边形填充（P51）"><a href="#多边形填充（P51）" class="headerlink" title="多边形填充（P51）"></a>多边形填充（P51）</h4><ol>
<li><p>多边形表示方法</p>
<ul>
<li>顶点表示</li>
<li>点阵表示</li>
</ul>
<p>多边形填充就是把多边形的顶点表示转换为点阵表示。</p>
</li>
<li><p>多边形填充的扫描线算法</p>
<p>扫描线算法是效率较高的多边形填充算法，充分利用了相邻象素之间的连续性，避免反复求交。</p>
<ul>
<li><p>区域的连续性</p>
</li>
<li><p>扫描线的连续性</p>
<p>交点个数是偶数，扫描线上的一些点位于多边形P内，其余区间都在P外。</p>
</li>
<li><p>边的连续性</p>
</li>
<li><p>奇点处理</p>
</li>
<li><p>扫描线算法的数据结构域实现步骤</p>
<ul>
<li><p>边 y. 筒ET</p>
<p>按边下端点的纵坐标$y$对非水平边进行分类的指针数组。下端点的纵坐标$y$等于$i$的边归入第$i$类。同一类中按$x$值进行排序。</p>
<p>生成方式：从低端向上扫描</p>
</li>
<li><p>边的活化链表AEL</p>
<p>由与当前扫描线相交的所有多边形组成，记录多边形边沿扫描线的交点序列</p>
</li>
<li><p>四个域组成</p>
<p>| $y_{max}$ | $x$                          | $\Delta x$ | $next$    |<br>| ——— | —————————- | ———- | ——— |<br>| 边的上端点y坐标  | 边y筒中表示下端点x坐标；AEL中边与扫描线的交点x坐标 | 边斜率的倒数     | 指向下一条边的指针 |</p>
</li>
<li><p>算法步骤</p>
<ul>
<li>（AEL初始化）将边的活化链表AEL置空</li>
<li>（y初始化）取扫描线纵坐标y的初始值为ET中非空元素的最小序号</li>
<li>按从下到上的顺序对纵坐标值为y的扫描线（当前扫描线）执行下列步骤直到边的活化链表为空<ul>
<li>如边ET中的第y类元素非空，则从ET中将第y类的所有边取出，按照x值（x值相等时，按$\Delta x$值）递增方向插入到活化链表AEL中</li>
<li>若AEL非空，将AEL中的边亮亮依次配对，填充所有线段对$（x_1,y）$和$（x_2,y）$，$（x_3,y）$和$（x_4,y）$，……</li>
<li>将AEL中满足y=y_max的边删去</li>
<li>将AEL剩下的每条边的X域累加$\Delta x$ ，即 $x = x + \Delta x$</li>
<li>将当前扫描线的纵坐标值y累加1，即$y=y+1$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>边缘填充算法</p>
<p>多边形填充的扫描线算法中，建立ET筒和AEL活化链表时需要对多边形的边进行排序，该算法采用对图像进行逐位求反的方法可以免去对边排序的工作量。</p>
<ul>
<li>算法实现：对多边形P的每一非水平边$P_iP_i+1$上的各象素做向右求反运算即可。</li>
</ul>
</li>
</ol>
<ul>
<li>优势：数据结构和程序简单，对单值图像比较有用</li>
<li>劣势：需要对帧缓冲器中的大批元素反复赋值，速度不比扫描线快。</li>
</ul>
<ol>
<li><p>边界标志</p>
<p>首先用特殊颜色在帧缓冲器中将多边形边界（水平边的部分边界除外）勾画出来，然后再把位于多边形内的各个象素着色。</p>
<p>避免了对帧缓冲器中的大量元素的多次赋值，但需要逐条扫描线对帧缓冲器中的元素进行搜索和比较。</p>
</li>
</ol>
<h4 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h4><ol>
<li><p>区域概念</p>
<ul>
<li>内点表示</li>
<li>边界表示法</li>
<li>区域的连通性<ul>
<li>四连通区域</li>
<li>八连通区域</li>
</ul>
</li>
</ul>
</li>
<li><p>简单的种子填充算法</p>
<p>给定区域G一种子点（x,y），首先判断该点是否是区域内的一点，是则将该点填充为新的颜色，然后将该点周围的四个点（四连通）或八个点（八连通）作为新的种子点进行相同处理，通过这种扩散完成对整个区域填充。</p>
</li>
<li><p>扫描线种子填充算法</p>
<p>区域填充的递归算法程序简单、表达清楚。但是由于多层递归，需要反复进行费时、费内存的堆栈操作，一般用于细小的区域进行填充。</p>
<p>扫描线种子算法，从给定的种子点开始，填充当前扫描线上种子点所在的区间，然后确定与这一区间相邻的上下两条扫面线上需要填充的区间，从这些区间上各取一个种子点并以此把它们保存起来，作为下次填充的种子点，反复进行直到所保存的各区间都填充完毕</p>
<p>算法步骤：</p>
<ol>
<li>将算法设置的堆栈置为空，将给定种子点（x,y）压入堆栈</li>
<li>如果堆栈为空，算法结束；否则取栈顶元素（x,y）作为种子点</li>
<li>从种子点开始，沿纵坐标为y的当前扫描线向左右两个方向逐个用新的颜色值进行填充，直到边界为止。设区间的横纵坐标分别为$x<em>{left}$和$x</em>{right}$。</li>
<li>在与当前扫描线相邻的上下两条扫描线上，以区间$[x<em>{left},x</em>{right}]$为搜索范围，求出需要填充的各小区间，把各小区间中最右边的点作为种子点压入堆栈，移向2</li>
</ol>
</li>
</ol>
<h2 id="第五章-变换和裁剪"><a href="#第五章-变换和裁剪" class="headerlink" title="第五章 变换和裁剪"></a>第五章 变换和裁剪</h2><h4 id="变换的数学基础"><a href="#变换的数学基础" class="headerlink" title="变换的数学基础"></a>变换的数学基础</h4><h4 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h4><p>每一图形的模型都有自己的坐标系，此坐标系为模型坐标系或局部坐标系。图形场景由多个图形组成，它们被放置在一个统一的坐标系中，称为世界坐标系</p>
<ol>
<li>基本变换<ul>
<li>平移变换</li>
<li>缩放变换<ul>
<li>原点为相似中心</li>
<li>定义其他点为相似中心</li>
<li>为使缩放后的图形仍在原来位置附近，定义相似中心</li>
</ul>
</li>
<li>旋转变换<ul>
<li>x、y、z点左边经旋转后的坐标。（y有差别）</li>
<li>绕过原点的任意轴旋转（不懂）</li>
<li>void glRotate(Type angle, x , y , z) ，以angle为旋转角度，以从原点到指定（x,y,z）向量为旋转中心轴，逆时针旋转。</li>
</ul>
</li>
<li>错切变换</li>
</ul>
</li>
<li>齐次坐标与变换的矩阵表示<ul>
<li>为了将平移变换合并，使用齐次坐标系</li>
<li>用n+1维向量表示n维向量</li>
</ul>
</li>
<li>变换模式<ul>
<li>图形软件包提供两种图形变换模式—— 图形模式和空间模式，从而可以方便地控制变换的次序</li>
<li>图形模式<ul>
<li>每一次变换均可看成相对于原始坐标系中执行的，先调用的变换矩阵放在右边，后调用的矩阵放在左边。 固定坐标系模式</li>
<li>个人理解：都是相对于初始坐标系进行变换</li>
</ul>
</li>
<li>空间模式<ul>
<li>又称活动坐标系模式。连续执行几个变换时，变换矩阵的合并方式和图形模式相反，即后调用的变换矩阵要乘在右边</li>
<li>空间模式的特点是在连续执行几次变换时，每一次变换均可看成是上一次变换所形成的新坐标系中进行的。</li>
<li>对变换后的坐标系进行变换</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ol>
<li>Sutherland-Cohen算法<ul>
<li>判断直线是否完全在窗口内或窗口外</li>
<li>计算出直线段和窗口边界直线的一个交掉，此交点把原线段分成两段，去掉显然在窗口外的一段，对另一段进行重新判断。</li>
<li>用窗口的四条边巴整个平面分成九个区域，对于窗口某一边界外侧的三个区域的四位编码中有一位全是1。</li>
<li>如果两段编码都是0000，则完全在窗口内；如果逻辑与不为0000，即某一位为1，表明两端点位于窗口同一条边界外侧，显然在窗口外·</li>
</ul>
</li>
<li>Cyrus-Beck算法和梁友东-Barsky算法</li>
<li>多边形剪裁</li>
<li>字符剪裁</li>
</ol>
<h4 id="OpenGL中简单变换实例"><a href="#OpenGL中简单变换实例" class="headerlink" title="OpenGL中简单变换实例"></a>OpenGL中简单变换实例</h4><h2 id="第六章-三维空间的观察"><a href="#第六章-三维空间的观察" class="headerlink" title="第六章 三维空间的观察"></a>第六章 三维空间的观察</h2><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>把n维坐标系中的电变换成小于n维坐标系中的点。只讨论三维到二维的投影。</p>
<p>在三维空间中选择一个点作为视点，定义一个不经过视点的平面（投影平面），从视点向投影平面引出任意条射线（投影线）。穿过物体的投影线将与投影平面相交，在投影平面上形成物体的像，此像即为三维物体在二维投影平面上的投影。</p>
<p>投影变换分为透视投影和平行投影，区别是透视投影的投影中心和投影面之间的距离有限，而平行投影的投影中心和投影平面之间的距离是无限的</p>
<ol>
<li>透视投影<ul>
<li>透视投影的计算公式</li>
</ul>
</li>
<li>平行投影<ul>
<li>正投影</li>
<li>斜投影</li>
<li>平行投影的计算公式</li>
</ul>
</li>
<li>任意坐标系到观察坐标系中的变换<ul>
<li>灭点：一组不平行与投影平面的平行线，经过透视投影后相交于一点。灭点可以看作是三维空间的无穷远点在投影平面上的投影点。如果这组平行线平行与坐标轴，这时的灭点称为<strong>主灭点</strong>。</li>
</ul>
</li>
<li>射影变换</li>
</ol>
<h4 id="视见体到规范视见体的变换"><a href="#视见体到规范视见体的变换" class="headerlink" title="视见体到规范视见体的变换"></a>视见体到规范视见体的变换</h4><ol>
<li>平行投影视见体的规范化</li>
<li>透视投影视见体的规范化</li>
</ol>
<h4 id="用三维规范体裁剪"><a href="#用三维规范体裁剪" class="headerlink" title="用三维规范体裁剪"></a>用三维规范体裁剪</h4><h4 id="窗口到视口的变换"><a href="#窗口到视口的变换" class="headerlink" title="窗口到视口的变换"></a>窗口到视口的变换</h4><h2 id="第七章-人机交互绘图技术"><a href="#第七章-人机交互绘图技术" class="headerlink" title="第七章 人机交互绘图技术"></a>第七章 人机交互绘图技术</h2><p>人机交互：用户与计算机系统之间的通信，它是人与计算机之间各种符号和动作的双向信息交换</p>
<h4 id="基本的图形输入设备和基本交互任务"><a href="#基本的图形输入设备和基本交互任务" class="headerlink" title="基本的图形输入设备和基本交互任务"></a>基本的图形输入设备和基本交互任务</h4><ol>
<li>基本的图形输入设备<ul>
<li>定位设备</li>
<li>笔画设备</li>
<li>定值设备</li>
<li>选择设备</li>
<li>拾取设备</li>
<li>字符串设备</li>
</ul>
</li>
<li>基本交互任务<ul>
<li>定位</li>
<li>笔画</li>
<li>定值</li>
<li>选择</li>
<li>拾取</li>
<li>字符串</li>
</ul>
</li>
</ol>
<h4 id="人机交互输入模式"><a href="#人机交互输入模式" class="headerlink" title="人机交互输入模式"></a>人机交互输入模式</h4><ol>
<li>请求模式</li>
<li>样本模式</li>
<li>事件模式</li>
</ol>
<h4 id="常见辅助交互技术"><a href="#常见辅助交互技术" class="headerlink" title="常见辅助交互技术"></a>常见辅助交互技术</h4><ol>
<li>几何约束</li>
<li>拖拽</li>
<li>在三维视图上做三维输入</li>
</ol>
<h2 id="第八章-隐藏先和隐藏面的消除"><a href="#第八章-隐藏先和隐藏面的消除" class="headerlink" title="第八章 隐藏先和隐藏面的消除"></a>第八章 隐藏先和隐藏面的消除</h2><p>计算机生成三维图形，首先确定三维场景中的物体哪些部分是可见的，生成三维图形时只绘制可见的部分。</p>
<p>三维场景中物体的可见性对透视投影是相对于投影中心，平行投影是相对于投影方向。</p>
<p>场景可见部分的判断过程称为可见线判断或可见面判定，也称为隐藏线消除或隐藏面消除。</p>
<p>两种基本算法：</p>
<ol>
<li>以构成图像的每一个象素为处理单元，对场景中所有表面，确定对于观察点是可见的表面，用该表面颜色填充该象素。<strong>多用于面消隐</strong></li>
<li>以三维场景中的物体对象为处理单元，在所有对象之间进行比较，除去完全不可见的物体和物体上不可见的部分。<strong>多用于线消隐，也可用于面消隐</strong></li>
</ol>
<h4 id="可见面判断的有效技术"><a href="#可见面判断的有效技术" class="headerlink" title="可见面判断的有效技术"></a>可见面判断的有效技术</h4><p>可见面或可见线的判定是一个计算量很大的工作，如何减少可见面的判定非常重要。</p>
<ol>
<li><p>边界盒</p>
<p>在裁剪和消隐处理中，采用边界盒可避免不必要的裁剪运算，避免在物体或它们的投影之间进行不必要的计算。所谓物体的边界盒是指一个能够包含该物体的一个几何形状，该形状有较简单的边界</p>
</li>
<li><p>后向面消除</p>
<p>把显然不可见的面去掉，从而减少消隐过程中的直线求交数目</p>
</li>
<li><p>非垂直投影转换成垂直投影</p>
</li>
</ol>
<h4 id="多面体隐藏线消除算法"><a href="#多面体隐藏线消除算法" class="headerlink" title="多面体隐藏线消除算法"></a>多面体隐藏线消除算法</h4><ol>
<li>算法基本思想<ul>
<li>使用后向面消除技术把多面体后向面去掉</li>
<li>使用边界盒技术排除不相交的线段的求交运算</li>
</ul>
</li>
<li>确定边L和多边形E关系的技术</li>
</ol>
<h4 id="基于多边形的子分算法"><a href="#基于多边形的子分算法" class="headerlink" title="基于多边形的子分算法"></a>基于多边形的子分算法</h4><p>用多边形的边界对区域进行划分，目的是尽量减少对区域划分的次数</p>
<h4 id="Z缓冲器算法和扫描线算法"><a href="#Z缓冲器算法和扫描线算法" class="headerlink" title="Z缓冲器算法和扫描线算法"></a>Z缓冲器算法和扫描线算法</h4><ol>
<li><p>Z缓冲器算法</p>
<p>z缓冲器算法是最简单的隐藏面消除算法之一。对屏幕上每一个像素点，找到此像素投影线与所有多边形交点中离观察者最近的点，此点的属性（颜色或灰度）值即为这一屏幕像素点的属性值。</p>
<p>实现此算法需要两个缓冲器数组，即z缓冲器数组和帧缓冲器数组，Zdepth[][]与Frame[][]，算法如下</p>
<ol>
<li>对屏幕上的每个点$(x,y)$，令Zdepth[x][y]为z的极小值，Frame[x][y]为背景颜色</li>
<li>对所有多边形做如下工作：对多边形每一点(x,y)，计算其z值。若z&gt;Zdepth[x][y]，则Zdepth[x][y]=z，并将此属性值赋给Frame[x][y]，否则说明此点离观察者较远，两个数组的值都可以不用改变</li>
</ol>
<p>优点：简单、可靠，不需要对显示物体的面预先进行排序，有利于硬件实现</p>
<p>缺点：需要额外的z缓冲器，将全屏幕的像素保存</p>
</li>
<li><p>扫描线z缓冲器算法</p>
<p>为了克服缺点，将整个屏幕平面划分为若干个区域。如果把整个区域取成屏幕上的一行，就得到了扫面线z缓冲器算法。z缓冲器的单元数和一条扫描线上的像素数目相同。从最上面的扫描线开始，向下对每一条扫面线进行处理。</p>
<p>处理工作</p>
<ol>
<li>把相应的帧缓冲器单元设置成底色，在z缓冲器中存放z的极小值。</li>
<li>对每个多边形检查它在oxy平面上的投影和当前的扫描线是否相交<ul>
<li>若不相交，则不考虑该多边形</li>
<li>若相交，则扫描线和多边形边界的交点是成对出现的。</li>
</ul>
</li>
<li>对每对交点中间的像素计算多边形所在平面对应点的深度（z值），并和z缓冲器中相对应单元存放间的深度值做比较。<ul>
<li>若前者大于后者，则z缓冲器的相应单元内容要被求得的平面深度代替，帧缓冲器相应单元的内容也要换成该平面的属性。</li>
</ul>
</li>
<li>对所有的多边形都做上述处理后，帧缓冲器中这一行的值边反映了消隐后的图形。对帧缓冲器每一行都处理完后，就得到了整个消隐后的图形</li>
</ol>
<p>实现方式</p>
<p>采用数据结构：一个多边形Y筒，一个边Y筒，一个多边形活化表盒一个边活化表。</p>
<ul>
<li>多边形Y筒和边Y筒各是一个记录，记录的个数和扫描线的行数相同。</li>
<li>根据多边形顶点y坐标最大值来决定放入<strong><em>多边形y筒</em></strong>的行数</li>
<li>根据边两端点的较大y坐标值来决定放入<strong>边y筒</strong>的相应行数</li>
<li>多边形Y筒：<ul>
<li>多边形所在平面方程： $ax+by+cz+d=0$的系数     <strong>a,b,c和d</strong></li>
<li>和该多边形在$oxy$平面上的投影相交的扫描线的条数      $\Delta y =8$</li>
<li>多边形的属性   <strong>color</strong></li>
<li>编号 <strong>IP</strong></li>
</ul>
</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%A4%9A%E8%BE%B9%E5%BD%A2y%E7%AD%92.png" alt="多边形Y筒"></li>
<li>边Y筒<ul>
<li>边上端点x坐标的值</li>
<li>在$oxy$平面上的投影和相邻两条扫面线的交点的x坐标的差$\Delta x$</li>
<li>边在oxy平面上的投影所覆盖的扫面线条数 $\Delta y$</li>
<li>边所属多边形的编号  <strong>IP</strong></li>
</ul>
</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E8%BE%B9y%E7%AD%92.png" alt="边y筒"></li>
<li>多边形活化表，记录在$oxy$平面投影和当前考虑的扫描线相交的多边形</li>
<li>边活化表，存放多边形的边和当前扫描线相交的边对。边对保存如下信息：<ul>
<li>$x_l$      左边的x坐标值</li>
<li>$\Delta x_l$   左边和两相邻扫描线交点的x坐标差</li>
<li>$\Delta y_l$   以左边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1</li>
<li>$x_r$      右边交点的x坐标值</li>
<li>$\Delta x_r$  右边和两相邻扫描线交点的x坐标差  </li>
<li>$\Delta y_r$   以右边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1</li>
<li>$z_l $       多边形平面在左交点处的深度值</li>
<li>$\Delta z_x$  沿扫描线向右走过一个像素时，多边形所在平面深度的增量</li>
<li>$ \Delta z_y $  沿y方向向下移过一根扫描线时，多边形所在平面深度的增量</li>
<li>IP      边所在多边形编号</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="优先级排序表算法"><a href="#优先级排序表算法" class="headerlink" title="优先级排序表算法"></a>优先级排序表算法</h4><p>按多边形离观察者的远近来建立一个多边形排序表，距离观察着远的优先级低，近的优先级高。多边形排序表建立后，从优先级低的多边形开始，依次把多边形的颜色填入帧缓冲存储器重，表中距观察者近的元素覆盖帧缓冲存储器中原有内容，当优先级最高的多边形送入缓冲器后，整幅图形就形成了。</p>
<p>算法：</p>
<ol>
<li>根据每个多边形顶点z坐标的极小值 $z_{min}$的大小，按由小到大对它们做初步排序，并把它们组成一个链表</li>
<li>若链表中只有一个多边形，则结束算法，否则取表头多边形为P</li>
<li>设Q为链表中P之外的任一多边形。若对所有Q都有$Qz<em>{min}&gt;Pz</em>{min}$，则P不会遮挡其他多边形，为优先级最低的多边形，去除P，转2；否则，若所有Q都满足下面四项条件中的一项，则在链表中去除P，转2。若不满足此四项条件中任何一个的Q，交换P和Q转3。<ol>
<li>P 和Q在oxy平面上投影的边界盒在x或y方向上不相交</li>
<li>P的各顶点均在Q的远离视点一侧</li>
<li>Q的各顶点均在P的靠近视点一侧</li>
<li>P和Q在oxy平面是的投影不相交</li>
</ol>
</li>
</ol>
<h4 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h4><p>光学投射建立在几何光学的基础上，沿光线的路径追踪可见面，是一种有效的可见性判别技术。</p>
<p>具体做法：由视点出发穿过观察平面上一像素想场景发射一条射线，求出射线与场景中各物体表面的交点，离视点最近的交点的颜色即为像素要填的颜色。光线投射算法对于包含曲面，特别式包含球面的场景有很高的效率。</p>
<h2 id="第九章-简单光照明模型"><a href="#第九章-简单光照明模型" class="headerlink" title="第九章 简单光照明模型"></a>第九章 简单光照明模型</h2><h4 id="简单光照明模型"><a href="#简单光照明模型" class="headerlink" title="简单光照明模型"></a>简单光照明模型</h4><p>光照模型是生成真实感图形的基础。用计算机在图形设备上生成连续色调的真实感图形必须完成四个基本的任务。第一，用数学方法建立所构造三维场景的几何描述，并将其输入计算机。第二，将三维几何转换为二维透视图。通过对场景的透视变换来完成。第三，确定场景中所有可见面。第四，计算场景中可见面的颜色。</p>
<ol>
<li><p>光源</p>
<p>将光源称为发光体，反射表明称为反射光源</p>
<p>光源可分为四类：点光源、线光源、面光源和体光源</p>
</li>
<li><p>材质</p>
<p>材质本身有自己的颜色。材质的颜色是由它所反射的广的波长决定的</p>
</li>
<li><p>简单光照明模型</p>
<p>简单光照明模型只考虑被照明物体的几何形状对反射和透射光的影响，在简单光照模型中，环境假设为由白色照明，且反射光和透射光由用户选定</p>
<ol>
<li><p>环境反射光</p>
<p>环境反射光是由环境光在邻近物体上经过多次反射所产生的。</p>
<p>亮度表示为： $I_a=k<em>aI</em>{pa}$，其中 $I<em>a$是物体的环境反射亮度，$I</em>{pa}$为环境光亮度，$k_a$为物体表面光反射系数</p>
</li>
<li><p>漫反射光</p>
<p>一个比较粗糙的，无光照的物体表面对光的反射表现为漫反射。</p>
<p>郎伯定律指出：对于一个漫反射体，表面的反射光亮度和光源入射角的余弦成正比：$I_d =k<em>dI</em>{pd}\cos i$，其中$I<em>d$为物体表面漫反射光的光亮度，$I</em>{pd}$为光源垂直入射时反射光的光亮度，$i$为光源入射角，$k_d$为漫反射系数</p>
<p>当观察漫反射物体时，人眼接受到光亮度和观察者的位置无关</p>
<p>对漫反射物体，它的表面除受特定光源照射之外，还受到从环境来的反射光的照射</p>
</li>
<li><p>镜面反射光</p>
<p>镜面反射光为朝一定方向的反射光。根据光的反射定律，反射光和入射光对称地分布于表面法向的两侧。</p>
</li>
<li><p>综和</p>
<p>物体表面上任意一点射向视点的光亮度I应该为环境光、漫反射光和镜面反射光的总和。$k_a, k_d , k_s$分别表示环境反射，漫反射和镜面反射分量的比例系数，简单光照明模型为：</p>
<p> $$I=k<em>aI</em>{pa}+k<em>dI</em>{pd}\cos i+k<em>sI</em>{ps}\cos ^n \theta$$</p>
<p>当光源有多个时，则上式可写为$$I=k<em>aI</em>{pa}+\sum( k<em>dI</em>{pd}\cos i+k<em>sI</em>{ps}\cos ^n \theta)  $$</p>
<p>其中$k_d+k_s=1$，该模型也称为Phong模型</p>
</li>
</ol>
</li>
</ol>
<h4 id="光滑明暗处理技术"><a href="#光滑明暗处理技术" class="headerlink" title="光滑明暗处理技术"></a>光滑明暗处理技术</h4><p>通常的多边形扫描线算法来绘制这种近似表示的物体，生成的图形将失去原有曲面的光滑性，呈现多面体形状。由于不同平面片之间不存在不连续的法向量，导致多个平面篇表示的物体表面光亮度呈现不连续跃变。</p>
<ol>
<li><p>Gouraud明暗处理技术</p>
<p>将曲面表面某一点的光亮度做近似表示，近似值为该曲面的各多边形顶点光亮度的双线性插值。</p>
<p>Gouraud明暗处理不能正确地模拟高光，因为采用光亮度插值后将使多边形内的高光丢失</p>
<p>所绘制画面会诱发马赫带效应，光亮度双线性插值保证了由多边形近似表示的曲面上各处光亮度的连续变化，但在相邻多边形的公共边界上光亮度的一阶导数并不连续，由于人眼光学错觉，光亮度变化一阶不连续的边界处会呈现亮带或黑带</p>
</li>
<li><p>Phong明暗处理技术</p>
</li>
</ol>
<h2 id="第十章-Bezier曲线曲面"><a href="#第十章-Bezier曲线曲面" class="headerlink" title="第十章 Bezier曲线曲面"></a>第十章 Bezier曲线曲面</h2><p>在计算机图形学中，常用的曲线曲面的类型有Bezier曲线曲面、B样条曲线曲面、孔斯曲面，这些曲线曲面采用分段和分片参数多项式的形式。曲线曲面的形状不依赖于坐标系的选择，<strong>人机交互直观，易于计算，易于拼接，造型灵活等</strong></p>
<h4 id="曲线曲面的基础知识"><a href="#曲线曲面的基础知识" class="headerlink" title="曲线曲面的基础知识"></a>曲线曲面的基础知识</h4><ol>
<li><p>曲线的表示</p>
<ol>
<li><p>显示表示</p>
<p>对于一条曲线，一个坐标变量显示地表示为另一个变量的函数。在平面曲线的显示表示中，每一个x只对应一个y值，所以显示方程不能表示封闭或多值曲线，例如圆。</p>
</li>
<li><p>隐式表示</p>
<p>平面曲线隐式表示的一半形式为$f(x,y)=0$。</p>
<p>存在问题：1. 与坐标系相关 2.会出现斜率为无穷大的情况 3.非平面曲线难用常系数的非参数化函数表示 4.不利于计算和编程</p>
</li>
<li><p>参数表示</p>
<p>将曲线上各点的坐标显示地表示成参数的函数形式，若去参数为t，曲线的参数表示为</p>
<p>$$P(t) = (x(t),y(t),z(t)) , t \in [0,1]$$</p>
<p>其中，$x(t),y(t)$和$z(t)$分别为t的显示函数，即每一个t对应空间一个点$(x(t),y(t),z(t))$</p>
<p>在曲线曲面的表示上，参数表示比非参数表示具有更大的优越：</p>
<ul>
<li>参数方程形式不依赖于坐标系的选取，具有形状不变性</li>
<li>在参数表示中，变化率以切实量来表示，不会出现无穷大的情况</li>
<li>对参数表示的曲线、曲面进行平移、书房和旋转等几何变换比较容易</li>
<li>用参数表示的曲线曲面的交能力强，参数表示式中系数的几何意义明确，并提高了自由度，以便控制形状</li>
</ul>
</li>
</ol>
</li>
<li><p>参数曲线的切矢量、弧长、法矢量和曲率</p>
<ol>
<li><p>位置矢量</p>
<p>曲线上任一点的位置矢量可表示为  $P(t) = (x(t),y(t),z(t)) , t \in [0,1]$</p>
</li>
<li><p>切矢量</p>
</li>
<li><p>弧长</p>
</li>
<li><p>曲率</p>
</li>
<li><p>主法矢量和副法矢量</p>
</li>
</ol>
</li>
</ol>
<h4 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h4><p>Bezier曲线是一段n次多项式曲线，是构造自由曲线曲面的重要和基本方法之一。它有许多优点，如果保凸性，凸包性，曲线形状不依赖于坐标系选择，人机交互灵活</p>
<ol>
<li><p>曲线的定义</p>
<p>在空间给定n+1个点$P_0,P_1,…,P_n$，称下列参数多项式曲线为n次Bezier曲线</p>
<p>$$P(t)=\sum ^n_{i=0} P<em>iJ</em>{i,n}$$</p>
<p>其中 J_{i,n}是Bernstein基函数</p>
<p>$$J_{i,n}(t)=\frac{n!}{i!(n-1)!}t^i(1-t)^{n-1}$$</p>
<p>折现$P_0,P_1,…,P_n$称为P(t)的控制多边形，$P_0,P_1,…,P_n$个各点成为P(t)的控制顶点。控制多边形是对Bezier曲线P(t)的大致勾画，P(t)是对控制多边形的逼近。</p>
</li>
<li><p>曲线的性质</p>
<ol>
<li>非负性    $ J_{i,n}(t) \ge 0$</li>
<li>权性    $\sum ^n<em>{i=0} J</em>{i,n}(t) \equiv 1$</li>
<li>对称性   $J<em>{i,n}(t) = J</em>{n-i,n}(1-t) ,i=0,1,…,n$</li>
<li>导函数   </li>
<li>最大值</li>
<li>地推公式</li>
<li>升阶</li>
</ol>
<p>例子</p>
</li>
<li><p>Bezier曲线的性质</p>
<ol>
<li><p>端点的位置</p>
<p>Bezier曲线的起点为$P_0$，终点为$P_n$，即 $P(0) = P_0 , P(1)=P_n$</p>
</li>
<li><p>端点的切线</p>
<p>Bezier曲线$P(t)$在起点$P_0$处与边 $\overline {P_0P_1}$相切，在终点P<em>n点处与边$\overline {P</em>{n-1}P_n}$相切，即 $P’(0) = n(P_1-P_0)，P’(1)=n(P<em>n-P</em>{n-1})$</p>
</li>
<li><p>端点的曲率</p>
</li>
<li><p>仿射不变形</p>
</li>
<li><p>凸包性</p>
</li>
<li><p>交互能力</p>
</li>
<li><p>变差缩减性</p>
</li>
<li><p>保凸性</p>
</li>
</ol>
</li>
<li><p>Bezier曲线性质进一步讨论</p>
</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/复习/" rel="tag"># 复习</a>
          
            <a href="/tags/计算机图形学/" rel="tag"># 计算机图形学</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/20/计算机体系结构专题复习/" rel="next" title="计算机体系结构专题复习">
                <i class="fa fa-chevron-left"></i> 计算机体系结构专题复习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/05/信息检索专题复习/" rel="prev" title="信息检索专题复习">
                信息检索专题复习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a industrious programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机图形学复习要点"><span class="nav-number">1.</span> <span class="nav-text">计算机图形学复习要点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-计算机图形学概述"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 计算机图形学概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机图形的概念与研究的内容"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">计算机图形的概念与研究的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图形学发展史"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">图形学发展史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算机图形的应用"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">计算机图形的应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-计算机绘图初步认识"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 计算机绘图初步认识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在计算机上绘图"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">如何在计算机上绘图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-计算机图形系统及硬件"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 计算机图形系统及硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图形显示原理"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">图形显示原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-基本光栅图形算法"><span class="nav-number">1.4.</span> <span class="nav-text">第四章 基本光栅图形算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#直线生成算法"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">直线生成算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#圆弧生成算法"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">圆弧生成算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多边形填充（P51）"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">多边形填充（P51）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区域填充"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">区域填充</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-变换和裁剪"><span class="nav-number">1.5.</span> <span class="nav-text">第五章 变换和裁剪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变换的数学基础"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">变换的数学基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#几何变换"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">几何变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#裁剪"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">裁剪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenGL中简单变换实例"><span class="nav-number">1.5.0.4.</span> <span class="nav-text">OpenGL中简单变换实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-三维空间的观察"><span class="nav-number">1.6.</span> <span class="nav-text">第六章 三维空间的观察</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#投影"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">投影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视见体到规范视见体的变换"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">视见体到规范视见体的变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用三维规范体裁剪"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">用三维规范体裁剪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#窗口到视口的变换"><span class="nav-number">1.6.0.4.</span> <span class="nav-text">窗口到视口的变换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-人机交互绘图技术"><span class="nav-number">1.7.</span> <span class="nav-text">第七章 人机交互绘图技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的图形输入设备和基本交互任务"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">基本的图形输入设备和基本交互任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#人机交互输入模式"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">人机交互输入模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见辅助交互技术"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">常见辅助交互技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八章-隐藏先和隐藏面的消除"><span class="nav-number">1.8.</span> <span class="nav-text">第八章 隐藏先和隐藏面的消除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可见面判断的有效技术"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">可见面判断的有效技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多面体隐藏线消除算法"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">多面体隐藏线消除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于多边形的子分算法"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">基于多边形的子分算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Z缓冲器算法和扫描线算法"><span class="nav-number">1.8.0.4.</span> <span class="nav-text">Z缓冲器算法和扫描线算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级排序表算法"><span class="nav-number">1.8.0.5.</span> <span class="nav-text">优先级排序表算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#光线投射算法"><span class="nav-number">1.8.0.6.</span> <span class="nav-text">光线投射算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-简单光照明模型"><span class="nav-number">1.9.</span> <span class="nav-text">第九章 简单光照明模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单光照明模型"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">简单光照明模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#光滑明暗处理技术"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">光滑明暗处理技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十章-Bezier曲线曲面"><span class="nav-number">1.10.</span> <span class="nav-text">第十章 Bezier曲线曲面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#曲线曲面的基础知识"><span class="nav-number">1.10.0.1.</span> <span class="nav-text">曲线曲面的基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bezier曲线"><span class="nav-number">1.10.0.2.</span> <span class="nav-text">Bezier曲线</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("KzDP5NgGACc0bKLgfEtJ8Xrk-gzGzoHsz", "nGixqUVUQJjtTFuvDaoKrMo0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

  

  

  

</body>
</html>
