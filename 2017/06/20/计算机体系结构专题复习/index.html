<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="计算机体系结构,review," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="计算机体系结构专题复习第一章 计算机系统结构基础及并行性的开发计算机系统的层次结构 机器：能存储和执行相应语言程序的算法和数据结构的执行体。  计算机语言：  用以 述控制流程的、有一定规则的字符集合 语言不是专属软件范畴，可以分属于计算机系统的各个层次，具有不同作用                 多层次结构：从使用语言的角度，一台由软、硬件组成的通用计算机系统可以被看成是按功能划分的多层机器">
<meta name="keywords" content="计算机体系结构,review">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机体系结构专题复习">
<meta property="og:url" content="http://yoursite.com/2017/06/20/计算机体系结构专题复习/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="计算机体系结构专题复习第一章 计算机系统结构基础及并行性的开发计算机系统的层次结构 机器：能存储和执行相应语言程序的算法和数据结构的执行体。  计算机语言：  用以 述控制流程的、有一定规则的字符集合 语言不是专属软件范畴，可以分属于计算机系统的各个层次，具有不同作用                 多层次结构：从使用语言的角度，一台由软、硬件组成的通用计算机系统可以被看成是按功能划分的多层机器">
<meta property="og:updated_time" content="2017-06-30T13:19:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机体系结构专题复习">
<meta name="twitter:description" content="计算机体系结构专题复习第一章 计算机系统结构基础及并行性的开发计算机系统的层次结构 机器：能存储和执行相应语言程序的算法和数据结构的执行体。  计算机语言：  用以 述控制流程的、有一定规则的字符集合 语言不是专属软件范畴，可以分属于计算机系统的各个层次，具有不同作用                 多层次结构：从使用语言的角度，一台由软、硬件组成的通用计算机系统可以被看成是按功能划分的多层机器">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/20/计算机体系结构专题复习/"/>





  <title> 计算机体系结构专题复习 | Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/20/计算机体系结构专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                计算机体系结构专题复习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T21:57:47+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/复习/" itemprop="url" rel="index">
                    <span itemprop="name">复习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/20/计算机体系结构专题复习/" class="leancloud_visitors" data-flag-title="计算机体系结构专题复习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机体系结构专题复习"><a href="#计算机体系结构专题复习" class="headerlink" title="计算机体系结构专题复习"></a>计算机体系结构专题复习</h1><h2 id="第一章-计算机系统结构基础及并行性的开发"><a href="#第一章-计算机系统结构基础及并行性的开发" class="headerlink" title="第一章 计算机系统结构基础及并行性的开发"></a>第一章 计算机系统结构基础及并行性的开发</h2><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><ul>
<li><p>机器：能存储和执行相应语言程序的算法和数据结构的执行体。</p>
</li>
<li><p>计算机语言：</p>
<ul>
<li>用以 述控制流程的、有一定规则的字符集合<ul>
<li>语言不是专属软件范畴，可以分属于计算机系统的各个层次，具有不同作用            </li>
</ul>
</li>
</ul>
</li>
<li><p>多层次结构：从使用语言的角度，一台由软、硬件组成的通用计算机系统可以被看成是按功能划分的多层机器组成的层次结构</p>
</li>
<li><p>多级层次结构(机器—语言)</p>
<ul>
<li>M5:应用语言机器——–应用语言</li>
<li>M4:高级语言机器——–高级语言</li>
<li>M3:汇编语言机器——–汇编语言</li>
<li>M2:操作系统机器——-作业控制语言</li>
<li>M1:传统机器————-机器指令系统</li>
<li>M0:微程序机器———-微指令系统</li>
</ul>
</li>
<li><p>编译：用转换程序将高一级机器上的程序变换成低一级机器上的等效程序。</p>
</li>
<li><p>解释：在低级机器上使用一串程序或指令来仿真高级机器上的一条语句或指令的功能。</p>
</li>
</ul>
<h3 id="计算机系统结构、计算机组成和计算机实现"><a href="#计算机系统结构、计算机组成和计算机实现" class="headerlink" title="计算机系统结构、计算机组成和计算机实现"></a>计算机系统结构、计算机组成和计算机实现</h3><ul>
<li>系统结构：计算机系统中各级界面的定义及其上下功能的分配</li>
<li>透明：各个层级的程序员所看到的计算机属性不同，系统结构的研究内容之一就是要确定属性的透明性。</li>
<li>计算机组成：计算机系统结构的逻辑实现，包括机器级内部的数据流和控制流的组成以及逻辑设计等</li>
<li>透明性：客观存在的事物或属性从某个角度看不到。 在一个计算机系统中，低层机器的属性往往对高层程序员是透明的</li>
</ul>
<h3 id="计算机系统的软、硬件取舍和性能评测及定量设计原理"><a href="#计算机系统的软、硬件取舍和性能评测及定量设计原理" class="headerlink" title="计算机系统的软、硬件取舍和性能评测及定量设计原理"></a>计算机系统的软、硬件取舍和性能评测及定量设计原理</h3><ul>
<li><p>原则1：考虑现有硬件、器件条件下，系统要有高的性价比，主要从实现费用、速度和其他性能要求来综合考虑</p>
</li>
<li><p>原则2：考虑准备采用和可能采用的组成技术，使之尽可能不要过多或者不合理地限制各种组成、实现技术的采用</p>
</li>
<li><p>原则3：不能仅从硬件的角度考虑如何便于应用组成技术的成果和便于发挥器件技术的进程，还应从软件的角度把如何为编译和操作系统的实现以及如何为高级程序的设计提供更多、更好的硬件支持放在首位</p>
</li>
<li><p>CPU性能公式：</p>
<ul>
<li><p>程序执行的总指令条数$IC$</p>
</li>
<li><p>平均每条指令的时钟周期数$CPI$</p>
</li>
<li><p>时钟主频$f_c$</p>
<p>$T_{CPU} =IC\times CPI \times \frac{1}{f_c}$</p>
</li>
<li><p>n种指令，每种指令的时钟周期数CPI_i，出现次数I_i</p>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-数据表示、寻址方式与指令系统"><a href="#第二章-数据表示、寻址方式与指令系统" class="headerlink" title="第二章 数据表示、寻址方式与指令系统"></a>第二章 数据表示、寻址方式与指令系统</h2><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><h4 id="数据表示和数据结构"><a href="#数据表示和数据结构" class="headerlink" title="数据表示和数据结构"></a>数据表示和数据结构</h4><p>数据表示：能由机器硬件识别和引用的数据类型，即它又有对这种类型的数据进行操作的指令和运算部件。</p>
<p>数据结构：通过软件映像，变换成机器中所具有的数据来表示实现。</p>
<p>不同的数据表示可为数据结构的实现提供不同的支持，表现为实现效率和方便性的不同。数据结构和数据表示是软件和硬件的交界面。</p>
<h4 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h4><ol>
<li><p>自定义数据表示</p>
<p>标志符和数据描述符</p>
<ul>
<li><p>标志符</p>
<p>让每个数据带上类型标志位以说明数据值究竟是二进制整数、十进制整数……将数据类型与数据本身连载一起</p>
<p>优点（6条）：简化指令系统和程序设计、简化了编译程序、便于实现一致性校验、硬件自动变换类型、数据库系统实现和数据类型无关的要求、支持软件调试和应用软件开发</p>
<p>缺点（2条）：每个数据字增设标志符增加程序所占主存空间；采用标志符降低指令执行速度。</p>
</li>
<li><p>数据描述符</p>
<p>描述符与数据分开存放，用于描述所要访问的数据是整块的还是单个的，访问该数据块或数据元素所要的地址及其它信息</p>
<p>优点：描述符实现阵列数据的索引要比用变址方法实现更方便，且便于检查程序中的阵列越界错误；为向量、数组数据结构的实现提供了一定的支持。</p>
</li>
</ul>
</li>
<li><p>向量、数组数据表示</p>
<p>增设向量、数组数据表示提供对向量、数组数据结构提供支持</p>
<p>优点：加快形成元素地址；用一条向量、数组指令流水可同时对整个向量、数组进行高速处理；硬件判断下标是否越界，并让越界判断和元素运算并行；节省存储空间和处理时间</p>
</li>
<li><p>浮点数不考</p>
</li>
</ol>
<h3 id="寻址方式（重点）"><a href="#寻址方式（重点）" class="headerlink" title="寻址方式（重点）"></a>寻址方式（重点）</h3><h4 id="寻址方式的三个面向"><a href="#寻址方式的三个面向" class="headerlink" title="寻址方式的三个面向"></a>寻址方式的三个面向</h4><p>面向主存：主要访问主存，少量访问寄存器</p>
<p>面向寄存器：主要访问寄存器，少量访问主存和堆栈</p>
<p>面向堆栈：主要访问堆栈，少量访问主存和寄存器</p>
<h4 id="寻址方式在指令中的指明"><a href="#寻址方式在指令中的指明" class="headerlink" title="寻址方式在指令中的指明"></a>寻址方式在指令中的指明</h4><p>占用操作码的某些位来指明</p>
<p>在地址码部分专门设置寻址方式位字段指明</p>
<h4 id="程序在主存中的定位技术"><a href="#程序在主存中的定位技术" class="headerlink" title="程序在主存中的定位技术"></a>程序在主存中的定位技术</h4><p>逻辑地址：程序员编写程序时使用的地址</p>
<p>物理地址：程序在主存中的实际地址</p>
<ul>
<li>静态再定位：在目的程序装入主存的时候，由装入程序用软件方法把目的程序的逻辑地址变换为物理地址，程序执行时，物理地址不再改变。 不利于多道程序执行</li>
<li>动态再定位：基址寻址。<ul>
<li>增加相应的基址寄存器和地址加法器硬件，程序不做变换直接装入主存的同时，将装入主存的起始地址装入对应该道程序使用的基址寄存器中。</li>
<li>程序执行时，只要通过地址加法器将逻辑地址加上基址寄存器的程序基址形成有效地址后进行访存操作即可。</li>
<li>需要通过上、下界寄存器进行判断</li>
</ul>
</li>
<li>虚实地址映像表<ul>
<li>采用虚拟存储器，增加映像表硬件，使得程序空间可以超过主存空间</li>
<li>基址寻址。B为基址寄存器号，存放24位的基地址。(B)~(8-13)~+D形成24位宽的访存物理地址</li>
</ul>
</li>
<li>物理主存中的信息分布</li>
</ul>
<h3 id="指令系统的设计和优化"><a href="#指令系统的设计和优化" class="headerlink" title="指令系统的设计和优化"></a>指令系统的设计和优化</h3><h4 id="指令系统设计基本原则"><a href="#指令系统设计基本原则" class="headerlink" title="指令系统设计基本原则"></a>指令系统设计基本原则</h4><p>指令系统是程序设计者看到的机器的主要属性，是软、硬件的主要界面，在很大程度上决定了计算机具有的基本功能</p>
<p>指令系统的设计主要包括指令的功能（操作类型、寻址方式和具体内容）和指令格式的设计</p>
<h4 id="指令设计的步骤"><a href="#指令设计的步骤" class="headerlink" title="指令设计的步骤"></a>指令设计的步骤</h4><ul>
<li>根据应用，初拟指令的分类和具体指令</li>
<li>试编出用该指令系统设计的各种高级语言的编译程序</li>
<li>用大量测试程序进行模拟测试，看指令系统的操作码和寻址方式效能是否都比较高</li>
<li>将程序中高频出现的指令串复合改成一条强功能新指令，即改用硬件方式实现；而将频度很低的指令操作改成基本的指令组成的指令串来实现，即用软件的方式实现</li>
</ul>
<h5 id="编译程序设计"><a href="#编译程序设计" class="headerlink" title="编译程序设计"></a>编译程序设计</h5><ul>
<li>设计原则：如何支持编译系统能高效、简易地将源程序翻译成目标代码<ul>
<li>规整性、对称性、独立性和全能性、正交性、可组合性、可扩充性</li>
</ul>
</li>
</ul>
<h5 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h5><p>指令码密度适中、兼容性、适应性</p>
<h4 id="指令格式的优化"><a href="#指令格式的优化" class="headerlink" title="指令格式的优化"></a>指令格式的优化</h4><p>指令由操作码和地址码两部分组成。</p>
<p>指令格式的优化：用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。（哈弗曼压缩）</p>
<p>操作码的优化：缩短指令字长，减少程序总位数及增加指令字能表示的操作信息和地址信息。</p>
<h5 id="操作码优化"><a href="#操作码优化" class="headerlink" title="操作码优化"></a>操作码优化</h5><p>操作码$I_i$的使用频度$p_i$</p>
<p>操作码的信息源熵  (信息源所含的平均信息量)   $H= \sum _i p_i \log p_i$</p>
<p>信息冗余度    $\frac {实际平均码长-H}{实际平均码长}$  </p>
<h5 id="哈夫曼压缩（计算：哈夫曼树构成）"><a href="#哈夫曼压缩（计算：哈夫曼树构成）" class="headerlink" title="哈夫曼压缩（计算：哈夫曼树构成）"></a>哈夫曼压缩（计算：哈夫曼树构成）</h5><p>当各种事件发生概率不均等时，采用优化技术，对发生概率高的事件用短的位数来表示，而对出现概率较低的事件允许使用较长的位数来表示，以缩短表示的平均位数。</p>
<p>用于代码压缩、程序压缩、空间压缩和时间压缩</p>
<p>编码长度不唯一，但是平均码长唯一</p>
<p>步骤：</p>
<ul>
<li>将所有指令的使用频度由小到大排序，每次选择其中最小的两个频度合并成一个频度，使它们二者之和称为一个新结点。再按该频度大小插入到余下未参与结合的频度中。直到全部形成根结点为止。</li>
<li>对每一个结点向下延伸，分出两个分支，分别用一位代码的”0“或”1“表示。</li>
</ul>
<p>由于短码不可能是长码的前缀，从而保证了解码的唯一性和事实性</p>
<h5 id="基于哈夫曼编码的扩展操作码（计算：指令设计）"><a href="#基于哈夫曼编码的扩展操作码（计算：指令设计）" class="headerlink" title="基于哈夫曼编码的扩展操作码（计算：指令设计）"></a>基于哈夫曼编码的扩展操作码（计算：指令设计）</h5><ul>
<li><p>完全哈夫曼编码码长种类太多，不利于译码和实现</p>
</li>
<li><p>界定于定长二进制编码和完全哈夫曼编码之间的一种编码方式</p>
</li>
<li><p>操作码长度不固定，但只有有限种选择</p>
</li>
<li><p><strong>高概率使用短码，低概率使用长码</strong>；短码不能是长码的前缀（11为扩展码）</p>
</li>
<li><p>缩短操作码的平均长度，以减低信息冗余度</p>
<p>等长15/15/15…  扩展法    等长 8/64/523扩展法</p>
</li>
<li><p>指令设计：基于编码给机器操作码编码</p>
</li>
</ul>
<h5 id="指令字格式的优化"><a href="#指令字格式的优化" class="headerlink" title="指令字格式的优化"></a>指令字格式的优化</h5><ul>
<li>主存按位编址，指令字不按整数边界存储，而是逐条紧挨存储。会直接带来程序的总位数减少，然而访存指令速度下降。</li>
<li>指令字按整数边界存储</li>
<li>此处有图</li>
<li>扩大操作数地址的寻址范围<ul>
<li>采用基址寄存器寻址、相对寻址或寄存器寻址</li>
<li>基于分段的编址（段号+段内地址）</li>
</ul>
</li>
<li>操作数的地址码长度可以有很宽的变化范围，可以与可变长操作码配合，可以显著减少存储空间的浪费。</li>
<li>多种地址制，同一种地址制还可以采用多种地址形式和长度，也可以直接用空白来存放直接操作数或常数。<ul>
<li>多种地址制图</li>
<li>同种地址制下的多种地址形式和长度</li>
</ul>
</li>
<li>优化措施<ul>
<li>采用<strong>扩展操作码</strong>，根据指令的频度的分布选择合适的编码方式，以缩短操作码平均码长。</li>
<li>采用<strong>多种寻址方式</strong>，以缩短地址码长，并在有限地址长度内提供更多信息</li>
<li>采用<strong>多种地址制</strong>，增强指令功能，从宏观上缩短程序长度，加快程序执行速度</li>
<li>在<strong>同种地址制内再采用多种地址形式</strong>，让每种地址字段可以有多种长度，且让长操作码与短操作码进行组配</li>
<li>在维持指令字的存储器中按整数边界存储的前提下，使用多种不同的指令字长计算</li>
</ul>
</li>
</ul>
<h5 id="指令编排（P63"><a href="#指令编排（P63" class="headerlink" title="指令编排（P63)"></a>指令编排（P63)</h5><h3 id="指令系统的发展和改进"><a href="#指令系统的发展和改进" class="headerlink" title="指令系统的发展和改进"></a>指令系统的发展和改进</h3><h2 id="第三章-存储、中断、总线与输入-输出系统"><a href="#第三章-存储、中断、总线与输入-输出系统" class="headerlink" title="第三章 存储、中断、总线与输入/输出系统"></a>第三章 存储、中断、总线与输入/输出系统</h2><h3 id="存储系统的基本要求和并行主存系统"><a href="#存储系统的基本要求和并行主存系统" class="headerlink" title="存储系统的基本要求和并行主存系统"></a>存储系统的基本要求和并行主存系统</h3><h4 id="存储系统的基本要求"><a href="#存储系统的基本要求" class="headerlink" title="存储系统的基本要求"></a>存储系统的基本要求</h4><ul>
<li><p>大容量、高速度、低价格</p>
</li>
<li><p>存储器<strong>容量</strong> $S_M=W \times l \times m$ </p>
<p>W 为存储器字长，l为存储器字数，m为并行存储器体数</p>
</li>
<li><p>存储器速度</p>
<ul>
<li>访问时间$T_A$：存储器从接收访存读申请至信息被读到数据总线上的时间</li>
<li>存储周期$T_M$：连续启动一个存储器所需要的间隔时间（$T_M&gt;T_A$)</li>
<li>频宽（带宽）B_M：存储器可提供的数据传送速率<ul>
<li>最大频宽：单体$B_M = W /T_M $，m个存储体并行的最大频宽 $B_M = W\times m/T_M$</li>
<li>实际频宽</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h4><h5 id="单体单字存储器"><a href="#单体单字存储器" class="headerlink" title="单体单字存储器"></a>单体单字存储器</h5><p>当并行的存储器公用一套地址寄存器和地址译码电路时称为单体方式</p>
<p>每次访问一个存储器的一个字</p>
<p>最大的频宽$B_M = W /T_M$ </p>
<h5 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h5><p>把存储器字长增加n倍，为保持总容量不变，把存储器字数（地址数）相应减少n倍</p>
<p>在一个周期内访问n个数据</p>
<p>最大频宽 $B_M = W \times n / T_M$ </p>
<p>取指令冲突：在遇到程序转移而且转移成功时，一个存储周期读出的n条指令中，后面的指令将无用</p>
<p>读操作数冲突：一次同时读出的n个操作数，不一定都没用</p>
<p>写数据冲突：必须凑齐n个数之后才能一起写入存储器</p>
<p>读写冲突：当要读出的一个字和要写入存储器的字处在同一个存储字内时，无法在一个存储周期内完成</p>
<h5 id="多体单字"><a href="#多体单字" class="headerlink" title="多体单字"></a>多体单字</h5><p>由多组容量小、字长短的存储器片子组成，每个存储片子都有自己的地址译码、读/写驱动等外围电路</p>
<p>每个存储片子都有独立的地址译码、读/写驱动等外围电路</p>
<h5 id="定量分析-P85"><a href="#定量分析-P85" class="headerlink" title="定量分析(P85)"></a>定量分析(P85)</h5><p>转移概率$\lambda$，每个周期能访问的平均字数 $B = \frac {1-(1-\lambda)^m}{\lambda}$</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li>从最坏情况考虑，设所有申请(包括指令和数据)都是全随机的，用单来单服务、先来先服务的排队论模型进行模拟，可得出随 𝑚 的 高，主存频宽只是以近似 𝑚的关系改善</li>
<li>当然，指令流和数据流也不会是全随机的，因此，𝐵的值总是会比 𝑚的值要大</li>
<li>正是因为程序的转移概率不会很低，数据分布的离散性较大，所以单靠增大𝑚来 高并行主存系统的频宽是有限的，而且性能价格比还会随𝑚的增大而下降，就必须从系统结构上进行改进，采用存储体系</li>
</ul>
<h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>CPU终止正在执行的程序，转去处理随机提出的请求，待处理完毕后，再回到原先被中断的程序继续恢复执行的过程称为“中断”</p>
<p>相应和处理各种中断的软硬件系统总称为<strong>中断系统</strong></p>
<ul>
<li>内部中断：由CPU异常引起</li>
<li>外部中断：由中断信号引起<ul>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ul>
</li>
<li>软件中断：由自陷指令引起，用于操作系统服务</li>
</ul>
<h4 id="中断的分类和分级"><a href="#中断的分类和分级" class="headerlink" title="中断的分类和分级"></a>中断的分类和分级</h4><p>中断源：引起中断的各种事件</p>
<p>中断请求：中断源向中断系统发出中断的申请</p>
<p>中断响应：允许其中断CPU现行程序的运行，转去对该请求进行预处理，包括保存好端点现场，调出有关该中断的中断服务程序</p>
<h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><p>对中断进行分类，对每一类中断给定一个硬件的中断服务入口，再由软件分支转入相应的中断处理程序</p>
<h5 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h5><p>异常：由执行现行指令引起的临时停止事件，如运算结果溢出、页面失效等，一般不能屏蔽，应予立即相应和处理</p>
<p>中断：指那些与当前进程运行无关的请求临时停止的事件，如机器故障中断请求、外设中断请求、定时中断请求等，可以屏蔽，未被响应的中断源保留在中断字寄存器中，直至屏蔽解除后得到响应和处理</p>
<h5 id="中断的分级"><a href="#中断的分级" class="headerlink" title="中断的分级"></a>中断的分级</h5><p>同一类中各个中断请求的响应和处理的优先次序，一般由软件或通道来管理；而不同类的中断要根据其性质、紧迫性、重要性以及软件处理的方便性分成不同级别</p>
<h4 id="中断的响应和处理次序-P89"><a href="#中断的响应和处理次序-P89" class="headerlink" title="中断的响应和处理次序(P89)"></a>中断的响应和处理次序(P89)</h4><p>中断响应次序（处理中断流程）</p>
<ul>
<li>同时发生多个不同中断类的中断请求时，中断响应硬件中的排队器所决定的响应次序</li>
<li>一般在处理某级中某个中断请求时，是不能被与它同级的或比它低一级的中断请求所中断，只有比它高一级的中断请求才能中断其处理，等响应和处理完毕后再继续处理原先那个中断请求</li>
</ul>
<p>中断处理次序</p>
<ul>
<li>中断处理完的次序</li>
<li>由于中断处理程序也可能被中断，中断处理次序可能不同于中断响应次序</li>
</ul>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><ul>
<li>只要操作系统根据需要软的方法，改变各级中断处理程序的中断级屏蔽位状态，就可以改变实际的中断处理。这就是中断系统采用软、硬件结合的好处</li>
<li>中断响应用排队器硬件实现可以加快响应和断点现场保护，中断处理采用软的技术可以 供很大的灵活性，因此，中断系统的软、硬件功能的实质是中断处理程序软件和中断响应硬件的功能分配</li>
<li>为了改善性能，用软件实现的功能，可以部分改用硬件来实现</li>
</ul>
<h4 id="中断系统的软、硬件分配"><a href="#中断系统的软、硬件分配" class="headerlink" title="中断系统的软、硬件分配"></a>中断系统的软、硬件分配</h4><h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><p>总线：用于互连计算机、CPU、存储器、I/O端口及外部设备、远程通信设备间信息传送通路的集合</p>
<p>总线系统：总线与其相配合的<strong>附属控制电路</strong></p>
<p>按照信息传送功能、性能的不同，总线系统包括<strong>数据线</strong>、<strong>地址线</strong>、<strong>时序</strong>和<strong>中断信号</strong>等控制/状态线、<strong>电源线</strong>、地线以及<strong>备用线</strong>等</p>
<ul>
<li>数据线的根数决定同时传送的数据位数，即数据通路宽度</li>
<li>地址线的根数决定直接寻址的范围</li>
<li>控制/状态线决定总线的功能和使用能力</li>
<li>备用线用于系统功能的扩充</li>
</ul>
<h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><h5 id="按系统中的位置"><a href="#按系统中的位置" class="headerlink" title="按系统中的位置"></a>按系统中的位置</h5><ul>
<li>芯片级：CPU芯片内的总线;</li>
<li>板级：连接插件版内的各组件，局部总线、内部总线;</li>
<li>系统级：系统间或主机与I/O接口或设备之间的总线</li>
</ul>
<h5 id="按信息传送方向"><a href="#按信息传送方向" class="headerlink" title="按信息传送方向"></a>按信息传送方向</h5><ul>
<li>单向传输</li>
<li>双向传输<ul>
<li>半双向可沿相反方向传送，但同时只能向一个方向传送</li>
<li>全双向:可以同时向两个方向传送，速度快、造价高、结构复杂</li>
</ul>
</li>
</ul>
<h5 id="按使用方法"><a href="#按使用方法" class="headerlink" title="按使用方法"></a>按使用方法</h5><ul>
<li><p>专用总线：只连接一对物理部件的总线</p>
<ul>
<li>优点：<ul>
<li>多个部件可以同时收发信息，不争用总线，系统流量高</li>
<li>通信时不用指明源和目的，控制简单;</li>
<li>任何总线的失效只会使连接该总线的两个部件不能直接通信，但它们仍可以通过其他部件间接通信，因而系统可靠</li>
</ul>
</li>
<li>缺点：<ul>
<li>总线数多，总线数与部件数成平方倍关系增加</li>
<li>难以小型化、集成电路化</li>
<li>总线较长时，成本相当高</li>
<li>利用率低</li>
<li>不利于系统模块化</li>
</ul>
</li>
</ul>
</li>
<li><p>非专用总线：可以被多种功能或多个部件分时共享，同一时间只有一对部件可使用总线进行通信</p>
<ul>
<li><p>优点：</p>
<ul>
<li>总线数少、造价低</li>
<li>总线接口标准化，模块性强</li>
<li>可扩充能力强</li>
<li>部件的增加不会使电缆、接口和驱动电路激增</li>
<li>易用多重总线提高总线的带宽和可靠性，使故障弱化</li>
</ul>
</li>
<li>缺点：<ul>
<li>系统流量小，经常会出现争用总线的情况，降低效率，共享总线失效会导致系统瘫痪</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总线的控制方式"><a href="#总线的控制方式" class="headerlink" title="总线的控制方式"></a>总线的控制方式</h4><p>非专用总线上的多个设备或者部件同时请求使用总线，使得由总线控制机构按某种优先次序裁决，保证只有一个高优先级的申请者首先取得对总线的使用权</p>
<p>集中式控制：总线控制机构基本集中在一起，不论是在连接到总线的一个部件中，还是在单独的硬件中</p>
<p>分布式控制：总线控制逻辑分散在连到总线的各个部件间</p>
<h5 id="集中式控制"><a href="#集中式控制" class="headerlink" title="集中式控制"></a>集中式控制</h5><p>优先次序的确定可以有串行连接、定时查询和独立请求3种不同的方式，也可以是它们的结合。采用何种方式取决于控制线数目、总线分配速度、灵活性、可靠性等因素的综合考虑</p>
<ol>
<li><p>集中式的串行连接</p>
<ul>
<li>所有部件都经公共的“总线请求”线向总线控制器发出请求，</li>
<li>当“总线忙”信号未建立，总线空闲，请求响应，送出“总线可用”信号，串行通过每个部件。</li>
<li>如某个部件接收到“总线可用”信号但未发送请求，则送往下一个部件，如该部件发出过请求，则停止信号</li>
<li>建立“总线忙”，清除请求信号，准备数据传送</li>
<li>数据传送期间，“总线忙”维持“总线可用”的建立</li>
<li>传送完，去除“总线忙”和“总线可用”信号</li>
</ul>
<p>优先次序是由“总线可用”线所接部件的物理位置决定的</p>
<p>优点：</p>
<ul>
<li>选择算法简单，控制总线少(3根)</li>
<li>部件增减容易，可扩充性好</li>
<li>逻辑简单容易通过重复设置 高可靠性</li>
</ul>
<p>缺点：</p>
<ul>
<li>对“总线可用”线及其有关电路的失效很敏感</li>
<li>优先级是线连固定，不能由程序改变，灵活性差增加</li>
<li>“总线可用”信号顺序脉动地通过各个部件，限制总线的分配速度</li>
<li>受总线长度的限制，增减或移动设备受到限制</li>
</ul>
</li>
<li><p>集中式定时查询</p>
<ul>
<li>总线上的每个部件通过“总线请求”线发出请求</li>
<li>若总线处于空闲，“总线忙”未建立，总线控制器收到请求后，让计数器开始计数，定时查询各部件以确定是哪个部件发出请求</li>
<li>查询到请求发出部件，该部件建立“总线忙”，计数器停止计数，控制器停止查询</li>
<li>去除该部件的“总线请求”，让该部件获得总线使用权，传送完成后去除“总线忙”</li>
<li>如果总线分配前计数器清0，同串行链接；如果总线分配前不清0，则是循环优先级；如果总线分配前计数器设置某个初值，则指定这个部件为最高优先级;如果总线分配前将部件号重新设置一下，则可以指定各部件为任意所希望的优先级</li>
</ul>
<p>优点：</p>
<ul>
<li>因计数器初值，部件号均可由程序设定，优先次序可由程序控制，灵活性强</li>
<li>可靠性高</li>
</ul>
<p>缺点：</p>
<ul>
<li>控制线数较多，需2+log2N,扩展性稍差</li>
<li>控制较为复杂</li>
<li>速度取决与计数信号的频率和部件数，不能很高</li>
</ul>
</li>
<li><p>集中式独立请求</p>
<ul>
<li>共享总线的每个部件各自都有一对“总线请求”和“总线准许”线</li>
<li>总线控制器根据某种算法对同时送来的多个请求进行仲裁</li>
</ul>
<p>优点：</p>
<ul>
<li>总线分配速度快，不用查询</li>
<li>可以使用程序可控的预订方式、自适应方式、循环方式或它们的混和方式灵活确定下一个使用总线的部件</li>
<li>能方便地隔离失效部件的请求</li>
</ul>
<p>缺点：</p>
<ul>
<li>控制线数量多，N个设备必须有2N+1根控制线</li>
<li>总线控制器复杂</li>
</ul>
</li>
</ol>
<h4 id="总线的通讯方式"><a href="#总线的通讯方式" class="headerlink" title="总线的通讯方式"></a>总线的通讯方式</h4><h5 id="同步通讯"><a href="#同步通讯" class="headerlink" title="同步通讯"></a>同步通讯</h5><p>两个部件的信息是通过定宽、定距的系统时标进行同步的</p>
<ul>
<li>传送率高，受总线长度影响小</li>
<li>时钟在总线上的时滞可能会造成同步误差，时钟线上的干扰信号容易引起误同步</li>
<li>为 高可靠性，目的部件需要对数据是否正确接受予以回答:正常时不回答，出错时在同步时间片过去后向源部件发送出错信号，使之重发数据</li>
</ul>
<h5 id="异步通讯（图什么意思）"><a href="#异步通讯（图什么意思）" class="headerlink" title="异步通讯（图什么意思）"></a>异步通讯（图什么意思）</h5><ul>
<li>单向源(目)控制：通讯过程只由目的或源部件中的一个控制。<ul>
<li>优点：简单、高速</li>
<li>缺点：没有来自目的部件的信息指明数据传送是否有效;不同速度之间的部件之间通信比较复杂;部件内需设置缓冲器以缓冲来不及处理的数据;效率低，高速部件难以发挥效能;要求“数据准备”信号干扰要小，否则易误认成有效信号</li>
</ul>
</li>
<li>双向控制：由源和目的双方控制<ul>
<li>单向控制的缺点是不能保证下一数据传送之前让所有数据线和控制线的电平信号恢复成初始状态，从而可能造成错误状态</li>
<li>异步双向互锁方式虽然增加了信号沿总线来回传送的次数，使控制硬件变得更加复杂<ul>
<li>适应各种不同速度的I/O设备，保证数据传送的正确性，且有较高的数据传送速率(其速率为源部件和目的部件中相对较低的速率来通信，比同步方式总是以所有部件中最低的速率来通信的效率要高)            </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据宽度与总线线数"><a href="#数据宽度与总线线数" class="headerlink" title="数据宽度与总线线数"></a>数据宽度与总线线数</h4><h5 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h5><p>数据宽度：I/O设备取得I/O总线后所传送数据的总量，</p>
<p>数据通路宽度：数据总线的物理宽度(即一个时钟周期所传送的数据量)</p>
<p>一个数据宽度可能需要多个数据周期才能完成</p>
<p>数据宽度类型</p>
<ul>
<li>单字(单字节)宽度适合输入机、打印机等低速设备</li>
<li>定长块宽度适合于磁盘等高速设备</li>
<li>可变长块宽度适合于高优先级的中高速磁带、磁盘等设备</li>
</ul>
<h5 id="总线的线数"><a href="#总线的线数" class="headerlink" title="总线的线数"></a>总线的线数</h5><ul>
<li>总线线数越多，成本越高，干扰越大，可靠性越低，占用空间也越大，当然，传送速度和流量也越高</li>
<li>总线长度越长，成本越高，干扰越大，波形畸变越严重，可靠性越低</li>
<li>因此，总线增长，线数就应该越少</li>
<li>总线线数可以通过用线的组合、编码，以及并/串—串/并转换来实现，但一般会降低总线的流量</li>
</ul>
<h3 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h3><h4 id="输入输出系统概述"><a href="#输入输出系统概述" class="headerlink" title="输入输出系统概述"></a>输入输出系统概述</h4><p>输入输出系统：包括输入输出设备、设备控制器及与输入输出操作有关的硬件</p>
<p>输入输出系统：计算机系统中处理机与主存储器之外的部分</p>
<p><strong>输入输出系统</strong>是处理机与外界进行数据交换的通道。</p>
<p>输入输出设备：与处理机有关的、除人以外的各种设备</p>
<h5 id="输入输出系统的特点"><a href="#输入输出系统的特点" class="headerlink" title="输入输出系统的特点"></a>输入输出系统的特点</h5><ul>
<li>异步性：<ul>
<li>输入输出设备通常不使用统一的中央时钟，各个设备按照自己的时钟工作，但又要在某些时刻接受处理机的控制</li>
<li>处理机与外围设备之间，外围设备与外围设备之间能够并行工作</li>
</ul>
</li>
<li>实时性：<ul>
<li>对于一般外部设备：可能丢失数据，或造成外围设备工作的错误</li>
<li>对于实时控制计算机系统，如果处理机提供的服务不及时，可能造成巨大的损失</li>
<li>对于处理机本身的硬件或软件错误：如电源故障、数据校验错、页面失效、非法指令、地址越界等，处理机须及时处理</li>
<li>对不同类型的设备，必须具有与设备相配合的多种工作方式</li>
</ul>
</li>
<li>与设备无关性：<ul>
<li>独立于具体设备的标准接口。例如，串行接口、并行接口、SCSI(SmallComputer System Interface)接口等</li>
<li>计算机系统的使用者，在需要更换外围设备时，各种不同型号，不同生产厂家的设备都可以直接通过标准接口与计算机系统连接</li>
<li>处理机采用统一的硬件和软件对品种繁多的设备进行管理</li>
<li>某些计算机系统已经实现了即插即用技术</li>
</ul>
</li>
</ul>
<h4 id="通道处理机的工作原理和流量设计"><a href="#通道处理机的工作原理和流量设计" class="headerlink" title="通道处理机的工作原理和流量设计"></a>通道处理机的工作原理和流量设计</h4><h5 id="通道处理机工作原理"><a href="#通道处理机工作原理" class="headerlink" title="通道处理机工作原理"></a>通道处理机工作原理</h5><ul>
<li>用户一般不能直接安排输入/输出操作，而通过程序状态的切换来实现输入输出，以保证系统的可靠性</li>
<li>中央处理机用来控制外部设备操作用的输入/输出指令称为管态指令</li>
<li>用户在目态程序中不能直接使用管态指令，只能使用要求输入/输出的广义指令，然后进入相应的管理程序执行输入/输出的管态指令。</li>
</ul>
<h5 id="启动I-O指令"><a href="#启动I-O指令" class="headerlink" title="启动I/O指令"></a>启动I/O指令</h5><p>选择通道；选择子通道；选取通道指令；选取控制器、设备；向设备发送启动命令；启动成功，则结束通道开始选择设备期，进入通道程序，并退出管态程序，返回目态程序</p>
<h5 id="通道数据传送方式"><a href="#通道数据传送方式" class="headerlink" title="通道数据传送方式"></a>通道数据传送方式</h5><ul>
<li><p>字节多路：适合于连接像光电机的字符类低速设备</p>
<ul>
<li>送一个字符(字节)的时间很短，但字符(字节)间的等待时间很长</li>
<li>以字节交叉方式轮流为多台低速设备服务<ul>
<li>可有多个子通道，独立执行通道命令，并行操作</li>
</ul>
</li>
</ul>
</li>
<li><p>数组多路：适合于连接多台像磁盘的高速设备</p>
<ul>
<li>传送速率很高，但传送开始前的寻址辅助操作时间很长</li>
<li>成组交叉方式，传送完K个字节数据后重新选择下一个设备</li>
</ul>
</li>
<li><p>选择通道：适合于连接优先级高的磁盘等高速设备</p>
<ul>
<li><p>独占通道</p>
</li>
<li><p>在数据传送期内只选择一次设备</p>
<p>​    </p>
</li>
</ul>
</li>
</ul>
<h5 id="通道流量的设计"><a href="#通道流量的设计" class="headerlink" title="通道流量的设计"></a>通道流量的设计</h5><p>通道流量是通道在数据传送期间内，单位时间传送的字节数。它能达到的最大流量称为通道极限流量</p>
<p>通道的极限流量与其工作方式、数据传送期内<strong>选择一次设备的时间</strong> $T_S$ 和<strong>传送一个字节的时间</strong> $T_D$长短相关</p>
<ol>
<li><p>字节多路的通道极限流量</p>
<p>每选择一台设备只传送一个字节   </p>
<p> $f_{max \cdot byte} = \frac {1}{T_S+T_D}$</p>
</li>
<li><p>数组多路的通道极限流量</p>
<p>每选择一台设备就能传送完K个字节，如果要传N个字节，就要分N/K次传送，每次传送选择一次设备</p>
<p>$f_{max\cdot block} = \frac {K}{T_S+KT_D} = \frac{1}{\frac {T_S}{K} + T_D}$ </p>
</li>
<li><p>选择通道的通道极限流量</p>
<p>每选择一台设备就把N个字节全部传送完</p>
<p>$f_{max \cdot select} = \frac {N}{T_S+NT_D} = \frac{1}{\frac{T_S}{N}+T_D}$ </p>
</li>
</ol>
<p>如果通道的T_S 、T_D 确定一定时，且N&gt;K时，有 </p>
<p>$f<em>{max\cdot select} \ge f</em>{max\cdot block} \ge f_{max\cdot byte}$</p>
<p>设备要求通道的实际最大流量与三种通道的工作方式有关</p>
<ul>
<li><p>字节多路是该通道连接各设备的字节传送速率之和</p>
<ul>
<li>$f_{byte\cdot j} = \sum ^{p<em>j}</em>{i=1} f_{i\cdot j}$</li>
</ul>
</li>
<li><p>数组多路和选择通道是所连接各设备的字节传送速率中之最大者</p>
<ul>
<li>$f<em>{block\cdot j} = max f</em>{i\cdot j} , f<em>{select\cdot j} = max f</em>{i\cdot j}   i = 1,…,p_j$ </li>
</ul>
<p>$j$：通道编号  $f_{i,j}$ ：为第$j$号通道上所挂的第$i$台设备的字节传送速率</p>
<p>$p_j$：为第$j$号通道上所连接的设备的台数</p>
</li>
<li><p>为了保证第j号通道上所挂设备在满负荷的最坏情况下都不丢失信息，必须使设备要求通道的实际最大流量不超过通道的极限流量</p>
<p>$f<em>{byte\cdot j}\le f</em>{max\cdot byte\cdot j}$</p>
<p>…</p>
</li>
<li><p>上述流量设计的基本条件只保证了宏观上设备不丢失数据，并不能保证每一个局部时刻都不丢失信息</p>
</li>
<li><p>通常高速设备请求的响应优先级比较高，高速设备频繁发出请求并总是优先得到响应和处理，使得速率较低的设备长期得不到通道而丢失信息。</p>
</li>
<li><p>在设备或设备控制器中设置一定容量的缓冲器来缓冲得不到及时处理的数据，或是通过动态 高低速设备的响应优先级</p>
</li>
</ul>
<h2 id="第四章-存储体系"><a href="#第四章-存储体系" class="headerlink" title="第四章 存储体系"></a>第四章 存储体系</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="存储体系及其分支"><a href="#存储体系及其分支" class="headerlink" title="存储体系及其分支"></a>存储体系及其分支</h4><p>存储体系：在构成存储系统的几种不同的存储器（M~1~-M~n~）之间，配上辅助软件或硬件，使之从应用程序员的角度看，在逻辑上是一个整体（对应用程序员透明）</p>
<p>等效访问速度接近M~1~，容量接近于M~n~，每位价格接近于M~n~。</p>
<h5 id="主存—辅存存储层次（容量）"><a href="#主存—辅存存储层次（容量）" class="headerlink" title="主存—辅存存储层次（容量）"></a>主存—辅存存储层次（容量）</h5><p>由于主存容量无法满足需求，因此在主存和辅存之间，增设辅助的软、硬件设备，使它们形成统一整体</p>
<h5 id="Cache—主存存储层次（速度）"><a href="#Cache—主存存储层次（速度）" class="headerlink" title="Cache—主存存储层次（速度）"></a>Cache—主存存储层次（速度）</h5><p>由于主存速度满足不了要求，因而在CPU和主存之间增设高速、<br>小容量、每位价格较高的Cache，用辅助硬件将其和主存构成整<br>体，称为“Cache-主存存储层次”</p>
<h5 id="多级存储层次"><a href="#多级存储层次" class="headerlink" title="多级存储层次"></a>多级存储层次</h5><p>从CPU角度看，整个存储体系是一个整体，其速度接近于M~1~，容量接近于M~n~，每位价格接近于M~n~</p>
<h4 id="存储体系构成依据"><a href="#存储体系构成依据" class="headerlink" title="存储体系构成依据"></a>存储体系构成依据</h4><p>当CPU需要某个地址的内容的时候，总是希望该内容在速度最快，很多的M~1~当中</p>
<p>未来被访问信息的可预知性：</p>
<ul>
<li>时间局部性：在最近的未来所要用到的信息很可能是现在正在使用的信息</li>
<li>空间局部性：在最近的未来所要用到的细心很可能是何现在正在使用的信息在程序空间上是邻近的</li>
</ul>
<p>不比将整个程序整体存入M~1~，只需要将近期访问过的块（或页）调入M~1~</p>
<p>预知的准确性是存储层次设计好坏的主要标志，很大程度取决于所用的算法和地址映像变换方式</p>
<h4 id="存储体系的性能参数（老师PDF中无）"><a href="#存储体系的性能参数（老师PDF中无）" class="headerlink" title="存储体系的性能参数（老师PDF中无）"></a>存储体系的性能参数（老师PDF中无）</h4><h4 id="存储器层次结构设计的问题"><a href="#存储器层次结构设计的问题" class="headerlink" title="存储器层次结构设计的问题"></a>存储器层次结构设计的问题</h4><ul>
<li>映像方式：低层存储器的块按什么规则装入高层存储器</li>
<li>映像机构：映像方式的实现，如何识别和查找高层存储器的信息块</li>
<li>替换策略：访问失效后，如何淘汰信息块，而换新块</li>
<li>写策略：写操作发生时采用何种策略以保持相邻两级存储器中数据的一致性，发生写操作失效时是否将背写的块从低层存储器取入高层存储器</li>
</ul>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h4 id="虚拟存储器的管理方式"><a href="#虚拟存储器的管理方式" class="headerlink" title="虚拟存储器的管理方式"></a>虚拟存储器的管理方式</h4><p>虚拟存储器通过地址映像表机构来实现在主存中的定位。将程序分割成段或者页，用相应的映像表指明该程序某个段或页是否已装入主存；</p>
<ul>
<li>若已装入，指明在主存中的起始地址</li>
<li>若未装入，去辅存中调入段或者页，装入主存后再在映像表中建立号程序空间与实存空间的地址映像关系</li>
</ul>
<p>程序执行时先查映像表，将程序虚地址变成实地址后再访问主存</p>
<p>根据存储映像算法的不同，有多种不同的存储管理方式的虚拟存储器，其中主要由段式、页式、段页式</p>
<h5 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h5><p>段是程序逻辑独立的模块，每个段从0开始编址。当某个段调入主存时，只要系统赋予该段一个基址，就可以有该基址和单元的段内地址形成主存内的实际地址。将主存按段分配的存储管理方式称为段式管理</p>
<p>优点：</p>
<ul>
<li>使大程序分模块编址，使得多个程序员并行编程，缩短编程时间，在执行或者编译过程中对不断变化的变长短也便于处理</li>
<li>便于多道程序共用已在主存内的程序和数据</li>
<li>由于各段是按其逻辑特点组合的，因而容易以段为单位实现存储保护</li>
</ul>
<p>缺点：</p>
<ul>
<li>段长度完全取决于自身，主存中起点随意，给调入段分配主存带来了困难</li>
<li>需要构造复杂的段映像表，还需要为主存系统建立一个实主存管理表</li>
</ul>
<h5 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h5><p>页式虚拟存储器把虚拟空间机械地划分成一个个<strong>固定大小的块</strong>，每块称为一页，把主存储器的地址空间也按虚拟地址空间同样的大小划分为页。页是一种逻辑上的划分，可以由系统任意指定</p>
<p><strong>虚拟地址空间</strong>中的也称为<strong>虚页</strong>，主存地址空间中的页称为<strong>实页</strong></p>
<p>每个用户使用基址寄存器（CPU内），通过用户号U可以直接找到与该用户程序相对应的基址寄存器，从这个基址寄存器中读出页表起始地址。访问这个页表地址，把得到的主存页号P与虚地址中的业内偏移直接拼接起来得到主存实地址。</p>
<p>页表项简单，查找速度快；页面大小固定不利于系统的效率；页式管理在存储空间较大时，由于页表过大，效率降低；存储空间的保护困难</p>
<p>优点：</p>
<ul>
<li>主存储器的利用率比较高</li>
<li>页表相对比较简单</li>
<li>地址变换的速度比较快</li>
<li>对磁盘的管理比较容易</li>
</ul>
<p>缺点：</p>
<ul>
<li>程序的模块化性能不好</li>
<li>页表很长，需要占用很大的存储空间</li>
</ul>
<h5 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h5><ul>
<li><p>页式：对应用程序员完全透明，由系统划分。</p>
<p>• 硬件较少，地址变换速度快，<br>• 调入操作简单，静态连接程序;</p>
</li>
<li><p>段式：段独立，有利于程序员灵活实现段的连接、段的扩大/缩小和修改，而不影响其他段，易于针对其特定类型实现保护，把共享的程序或数据单独构成一个段，从而易于实现多个用户、进程对共用段的管理，动态连接程序;</p>
</li>
<li><p>段页式：把<strong>实存</strong>机械地等分成固定大小的<strong>页</strong>，<strong>程序</strong>按模块<strong>分段</strong>，每个段又分成与主存页面大小相同的页。</p>
</li>
</ul>
<h4 id="页式虚拟存储器的构成"><a href="#页式虚拟存储器的构成" class="headerlink" title="页式虚拟存储器的构成"></a>页式虚拟存储器的构成</h4><h5 id="地址映像和变换"><a href="#地址映像和变换" class="headerlink" title="地址映像和变换"></a>地址映像和变换</h5><ul>
<li>地址映像：将每个虚拟存储单元按某种规则（算法）装入（定位于）实存，即建立多用户虚地址$N_s$与实存地址$n_p$之间的对应关系。</li>
<li>地址变换：程序按照这种映像关系装入实存后，在执行时，多用户虚拟地址$N_s$如何变换成对应的实地址$n_p$</li>
<li>页面冲突：发生两个以上的虚页想要进入主存横纵同一个页面位置的现象。</li>
</ul>
<p>地址变化规则：减少实页冲突概率，硬件少、成本低，实现方便、变化速度快</p>
<p>由于虚拟空间远远大于实存空间，因此页式虚拟存储器常采用全相联映像</p>
<p><strong>全相联映像</strong>（页表法）：任何虚页可以映像装入到任何实页位置。<strong>冲突概率最低</strong></p>
<p><strong>相联目录表法</strong>：把页表压缩成只存放已装入主存的那些虚页号与实页位置$n_v$的对应关系</p>
<h5 id="页面替换算法-P125"><a href="#页面替换算法-P125" class="headerlink" title="页面替换算法(P125)"></a>页面替换算法(P125)</h5><ul>
<li><p>页面替换发生时间：</p>
<p>当发生页面失效时，要从磁盘中调入一页到主存。如果主存所有页面都已经被占用，必须从主存储器中淘汰一个不常使用的页面，以便腾出主存空间来存放新调入的页面</p>
</li>
<li><p>替换算法的确定：</p>
<ul>
<li>主存命中率</li>
<li>是否便于实现，软、硬件成本</li>
</ul>
</li>
<li><p>随机算法（Random，RAND）：用软的或硬的随机数产生器来形成主存中被替换的页号</p>
<ul>
<li>简单，易于实现</li>
<li>没有利用历史信息</li>
<li>命中率低，很少使用</li>
</ul>
</li>
<li><p>先进先出算法（First-In-First-Out，FIFO）：选择最早装入主存的页作为被替换的页</p>
<ul>
<li>操作系统为主存页面表中给每个实页配置一个计算器字段，每当一页装入时，让该页的计数器清零，其他已装入页的计数器都加“1”</li>
<li>需要替换时，计数器值最大的页号即最先进入主存而且现在准备被替换掉的页号</li>
<li>虽然使用历史信息，但是不一定反映程序的局部性</li>
</ul>
</li>
<li><p>近期最少使用算法（Least Recently Used，LRU）：选择近期最少访问的页被作为替换的页</p>
<ul>
<li>配备计数器</li>
<li>比较正确反映程序的局部性</li>
</ul>
</li>
<li><p>优化替换算法（Optimal Replacement Algorithm，OPT）：在时刻t找出主存中每个页将要用到时刻$t_i$，然后选择其中$t_i-t$最大页作为替换页。</p>
<ul>
<li>理想的算法</li>
</ul>
</li>
</ul>
<h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><h4 id="工作原理和基本结构"><a href="#工作原理和基本结构" class="headerlink" title="工作原理和基本结构"></a>工作原理和基本结构</h4><p>用以弥补主存速度的不足，在处理机和主存之间设置一个高速、小容量的Cache，构成Cache—主存存储层次。CPU来看，速度接近于Cache，容量却是主存的</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>图</p>
<h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><ul>
<li>把主存和Cache机械等分成相同大小的块（行），块比页小得多</li>
<li>访问Cache时间是访问主存时间的1/4到1/10；</li>
<li>Cache在物理位置上靠近CPU，不在主存，减少传输延迟</li>
<li>Cache— 主存间的地址映像和变换，以及替换、调用算法用硬件实现</li>
</ul>
<h4 id="地址映像与变换"><a href="#地址映像与变换" class="headerlink" title="地址映像与变换"></a>地址映像与变换</h4><h5 id="地址映像"><a href="#地址映像" class="headerlink" title="地址映像"></a>地址映像</h5><p>将每个主存块按某种规则（算法）装入Cache，并建立主存地址与Cache地址之间的对应关系</p>
<h5 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h5><p>主存块按照映像关系转入Cache后，每次访问Cache如何将主存地址变换成Cache地址</p>
<h5 id="选取地址映像方法考虑的主要因素"><a href="#选取地址映像方法考虑的主要因素" class="headerlink" title="选取地址映像方法考虑的主要因素"></a>选取地址映像方法考虑的主要因素</h5><ul>
<li>地址变换的硬件容易实现</li>
<li>地址变换的速度要快</li>
<li>主存空间利用率要高</li>
<li>发生块冲突的概率要小</li>
</ul>
<h5 id="全相联映像和变换"><a href="#全相联映像和变换" class="headerlink" title="全相联映像和变换"></a>全相联映像和变换</h5><p>主存中的任意一块都可以映像到Cache中任意一块。</p>
<p>目录表硬件方式实现</p>
<p><strong>相联目录表法</strong>（主存地址到Cache地址映射）</p>
<p>特点：冲突概率低、空间利用率高、地址变换快</p>
<p>缺点：目录表代价大；查表速度难提高</p>
<h5 id="直接映像与变换"><a href="#直接映像与变换" class="headerlink" title="直接映像与变换"></a>直接映像与变换</h5><ul>
<li><p>映像规则</p>
<p>主存中一块只能映像到Cache的一个特定的块中</p>
<p>主存第i块只能映像到  $i\mod 2^{n_{cb}}$块位置上</p>
<p>整个Cache地址与主存地址地位部分完全相同</p>
</li>
<li><p>区号存储器</p>
<p>存放Cache中每一块位置目前被主存中的哪个区的块所占用的区号</p>
</li>
<li><p>优点</p>
<p>硬件实现简单，不需要相联访问存储器</p>
<p>访问速度较快，实际上不做地址变换</p>
</li>
<li><p>缺点</p>
<p>块的冲突率较高</p>
<p>出现大量空闲块</p>
</li>
<li><p>很少使用</p>
</li>
</ul>
<h5 id="组相联映像与变换"><a href="#组相联映像与变换" class="headerlink" title="组相联映像与变换"></a>组相联映像与变换</h5><p>映像规则：各组之间直接映像，组内各块全相联映像</p>
<p>将Cache空间和主存空间都分成组，每组S块（$S = 2^s$）；将Cache分成Q组（$Q=2^q$），整个Cache作为一个区。主存分成和Cache同样大小的$2^{n_d}$个区，每个区包含Q组</p>
<p>变换 ： 图</p>
<p>优点：</p>
<ul>
<li>块冲突概率低</li>
<li>块的利用率大幅度提高</li>
<li>块失效率明显降低</li>
</ul>
<p>缺点：实现难度和造价要比直接映像方式高</p>
<p>地址变换过程：用主存地址的组号G按地址访问块表存储器。把读出来的一组区号与主存地址中区号和块号进行相联比较，如果有相等的，表示Cache命中；如果没有相等的，表示Cache没有命中</p>
<h5 id="段相联映像"><a href="#段相联映像" class="headerlink" title="段相联映像"></a>段相联映像</h5><p>映像规则：组间全相联，组内直接映像</p>
<h4 id="Cache存储器的LRU替换算法的硬件实现（不在老师PDF）"><a href="#Cache存储器的LRU替换算法的硬件实现（不在老师PDF）" class="headerlink" title="Cache存储器的LRU替换算法的硬件实现（不在老师PDF）"></a>Cache存储器的LRU替换算法的硬件实现（不在老师PDF）</h4><h4 id="Cache存储器的透明性及性能分析"><a href="#Cache存储器的透明性及性能分析" class="headerlink" title="Cache存储器的透明性及性能分析"></a>Cache存储器的透明性及性能分析</h4><h5 id="Cache存储器的透明性分析及其解决方法"><a href="#Cache存储器的透明性分析及其解决方法" class="headerlink" title="Cache存储器的透明性分析及其解决方法"></a>Cache存储器的透明性分析及其解决方法</h5><p>由于Cache存储器的地址变换和块替换算法全由硬件实现，因此Cache— 主存存储器层次对应用程序员和系统程序员都是透明的</p>
<p>造成Cache与主存不一致的原因：多CPU和IO设备共享主存，不共享Cache</p>
<p>多处理机共享Cache的难度</p>
<ul>
<li>Cache的容量必须大大增加</li>
<li>共享Cache的物理位置河南同时靠近多个CPU，延时会增加</li>
<li>Cache的频宽难以支持两个以上的CPU同时访问</li>
</ul>
<p>Cache与主存不一致的两种情况</p>
<ul>
<li>由于CPU写Cache，没有立即写主存</li>
<li>由于IO处理机或IO设备写主存</li>
</ul>
<p>写回法（抵触修改法，WB）：在CPU执行写操作时，信息只写回Cache，仅当需要被替换时，才将已被写入过的Cache块送回主存再调入新块</p>
<p>写直达法（直达法，WT）：利用Cache—主存存储层次在处理机和主存之间的直接通路，每当处理机写入Cache同时，也通过此通路直接写入主存。</p>
<p>优缺点比较：</p>
<ul>
<li>可靠性：写直达法由于写回法</li>
<li>与主存通信量：写回法少于写直达法</li>
<li>控制复杂性：写直达法比写回法简单</li>
<li>硬件实现的代价：写回法要比写直达法好</li>
<li>采用何种算法与适用场合有关：单处理机（节省成本）写回法；共享多处理机（保证信息交换可靠）：写直达法</li>
</ul>
<p>共享主存多CPU系统存在的问题：仅靠直写法不能保证统一主存单元在各Cache中对应内容一致</p>
<h5 id="共享主存多CPU系统保持内容一致性解决方法"><a href="#共享主存多CPU系统保持内容一致性解决方法" class="headerlink" title="共享主存多CPU系统保持内容一致性解决方法"></a>共享主存多CPU系统保持内容一致性解决方法</h5><ul>
<li>播写法<ul>
<li>任何处理机要写入Cache时，写入自己Cache的目标块和主存中</li>
<li>播写所有Cache中有此单元的地方，或者让所有Cache中有此单元的块作废</li>
</ul>
</li>
<li>控制某些共享信息不得进入Cache<ul>
<li>如信号灯、作业队</li>
</ul>
</li>
<li>目录表法<ul>
<li>在CPU读、写Cache不命中时，先查主存中的目录表，以判定目标块是否在别的Cache内，以及是否正在被修改等</li>
</ul>
</li>
</ul>
<h4 id="P158-4-14"><a href="#P158-4-14" class="headerlink" title="P158 4-14"></a>P158 4-14</h4><h3 id="三级存储体系"><a href="#三级存储体系" class="headerlink" title="三级存储体系"></a>三级存储体系</h3><h2 id="第五章-标量处理机"><a href="#第五章-标量处理机" class="headerlink" title="第五章 标量处理机"></a>第五章 标量处理机</h2><p>加快机器语言解释的两种方式</p>
<ol>
<li><p>通过选用更高速的器件，采用更好的运算方法、提高指令内各微操作的并行程度，减少解释过程所需要的拍数，以加快每条指令的解释</p>
</li>
<li><p>指令流水线技术：通过控制机构采用同时解释两条、多条以至整段程序的控制方式，加快整个机器语言程序的解释</p>
<p>重叠、流水</p>
</li>
</ol>
<h3 id="重叠方式"><a href="#重叠方式" class="headerlink" title="重叠方式"></a>重叠方式</h3><h4 id="重叠原理与一次重叠"><a href="#重叠原理与一次重叠" class="headerlink" title="重叠原理与一次重叠"></a>重叠原理与一次重叠</h4><p>解释一条指令的微操作可归并成取指令、分析和执行三部分。</p>
<ul>
<li>取指令：按指令计数器的内容访主存，取出该指令送到指令寄存器。</li>
<li>指令的分析：对指令的操作码进行译码，按寻址方式和地址字段形成<strong>操作数真地址</strong>，并用此真地址去取操作数，为取下一条指令还要形成<strong>下条指令地址</strong></li>
<li>指令的执行：对操作数进行运算、处理，或存储运算结果</li>
</ul>
<h5 id="顺序解释"><a href="#顺序解释" class="headerlink" title="顺序解释"></a>顺序解释</h5><p>各指令之间顺序串行地进行，每条指令内部的各个微操作也顺序执行</p>
<ul>
<li>优点：控制简单，方便进行时序控制</li>
<li>缺点：利用率低，速度低</li>
</ul>
<h5 id="重叠解释"><a href="#重叠解释" class="headerlink" title="重叠解释"></a>重叠解释</h5><p>在解释第k条指令的操作完成之前，就可开始解释第k+1条指令。虽然不能加快一条指令的实现，却能加快相邻两条以至整段程序的解释</p>
<h5 id="重叠解释的要求"><a href="#重叠解释的要求" class="headerlink" title="重叠解释的要求"></a>重叠解释的要求</h5><ol>
<li><p>解决访主存的冲突</p>
<ul>
<li>操作数和指令分别存放于两个独立编址且可同时访问的存储器中。有利于实现指令的保护，但是增加了主存总线控制的复杂性和软件设计的麻烦</li>
<li>采用多提交叉主存结构，第k条的操作数和第k+1条指令不在同一个个体内。存在一定局限性</li>
<li>增设采用先进先出方式工作的指令缓冲寄存器（指缓）趁主存有空时，预取下一条或下几条指令于指缓中</li>
</ul>
</li>
<li><p>解决”分析“和”执行“操作的并行</p>
<p>硬件上应有独立的<strong>指令分析部件</strong>和<strong>指令执行部件</strong>。</p>
</li>
<li><p>解决”分析“和”执行“操作控制上的同步</p>
<p>”分析“和”执行“所需要的时间不同，需要在硬件中解决控制上的同步问题，保证任何时候都只是”执行“与”分析“重叠执行</p>
<p>一次重叠：指令分析部件和执行部件任何时候都只有相邻两条指令在重叠解释</p>
<p>节省硬件，简化控制</p>
</li>
<li><p>解决指令间各种相关问题</p>
<ul>
<li>数据相关：在执行本条指令过程中，如果用到的指令、操作数、变址位移量等正是前面指令执行的结果，则必须等待前面的指令完成，并把结果写到主存或通用寄存器之后，本条指令才开始执行。<ul>
<li>指令相关</li>
<li>主存操作数相关 （延迟）</li>
<li>通用寄存器相关</li>
</ul>
</li>
<li>控制相关：由条件分支指令、转子程序指令、中断等引起的相关</li>
</ul>
</li>
</ol>
<h4 id="相关处理"><a href="#相关处理" class="headerlink" title="相关处理"></a>相关处理</h4><ol>
<li>转移指令的处理</li>
<li>指令相关的处理</li>
<li>主存空间数相关的处理</li>
<li>通用寄存器组相关的处理</li>
</ol>
<h3 id="流水方式"><a href="#流水方式" class="headerlink" title="流水方式"></a>流水方式</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>采用指缓的处理机中，一条指令的解释可以分解为“分析”和“执行”两个子过程。在指令分析器和指令执行部件的输出端各有一个锁存器，可以分别保存指令“分析”和指令“执行”的结果</p>
<p>指令串行—&gt;一次重叠，机器的最大吞吐率提供了一倍</p>
<p>流水将一条指令的解释分解为更多的子过程</p>
<h5 id="流水线特点"><a href="#流水线特点" class="headerlink" title="流水线特点"></a>流水线特点</h5><ul>
<li>流水线中处理的必须是连续任务，只有连续不断地提供任务才能充分发挥流水线的效率</li>
<li>把一个任务分解为几个有联系的子任务，每个子任务由一个专门的功能部件来实现</li>
<li>流水线中各段的时间应尽量相等，否则将引起“堵塞”、“断流”等</li>
<li>流水线需要有“装入时间”和“排空时间”</li>
</ul>
<h5 id="流水线分析"><a href="#流水线分析" class="headerlink" title="流水线分析"></a>流水线分析</h5><ul>
<li>如果把一条指令的解释分解成时间相等的m各子过程，则每隔 $\Delta t = T/m$就可以处理一条指令</li>
<li>流水的最大吞吐率取决于子过程的经过时间$\Delta t $，$\Delta t$ 越小，流水的最大吞吐率就越高</li>
<li>部件之间设有锁存器，受同一时钟信号控制，以实现各子部件信息的同步推进</li>
<li>时钟信号不得低于速度最慢部件的经过时间与锁存器的存取时间之和，还要考虑时钟信号到各锁存器可能存在的延时</li>
<li>子过程的细分会因锁存器数增多而增大任务或指令流水流过流水线的时间，这在一定程度上会抵消子过程细分使吞吐率提高的好处</li>
<li>由于流水线从开始启动到流出第一个结果，需要经过一段流水线建立时间，因此实际吞吐率总是低于其最大吞吐率</li>
</ul>
<h5 id="流水线的分类—多功能的链接方式"><a href="#流水线的分类—多功能的链接方式" class="headerlink" title="流水线的分类—多功能的链接方式"></a>流水线的分类—多功能的链接方式</h5><p>静态流水线：在同一段时间内，多功能流水线中的各个功能只能按照一种固定的方式连接，实现一种固定的功能，只有当按照这种连接方式工作的所有任务都流出流水线之后，多功能流水线才能重新连接，以实现其他功能</p>
<p>动态流水线：在同一段时间内，多功能流水线中的各段可以按照不同的方式连接，在各个功能部件之间不发生冲突的前提下，同时执行多种功能</p>
<h5 id="流水线的分类—是否有反馈信号"><a href="#流水线的分类—是否有反馈信号" class="headerlink" title="流水线的分类—是否有反馈信号"></a>流水线的分类—是否有反馈信号</h5><p>按照流水线的各个功能段之间是否有反馈信号，可以把流水线分为线性流水线和非线性流水线</p>
<ul>
<li>线性：每个流水段都流过一次，且仅流过一次，通常只完成一种固定的功能</li>
<li>非线性：在流水线的某些流水段之间有反馈回路或前馈回路 </li>
</ul>
<h4 id="标量流水线的主要性能"><a href="#标量流水线的主要性能" class="headerlink" title="标量流水线的主要性能"></a>标量流水线的主要性能</h4><h5 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h5><p>吞吐率：单位时间内流水线所完成的任务数量或输出的结果数量</p>
<p>若各个子过程经过的时间都是$\Delta t<em>2$，则最大吞吐率为： $T</em>{p_{max}} = 1/\Delta t_2$ </p>
<p>若各个子过程进行的工作不同，所经过的时间也不一定相同，所以在子过程之间设置接口锁存器，让各个锁存器都受同一时钟的同步 $T<em>{p</em>{max}} = \frac {1}{max{\Delta t_1,\Delta t_2 , \Delta t_3 ,\Delta t_4}}$ </p>
<p>受限于流水线中最慢子过程经过的时间按。流水线中经过最长时间的子过程称为瓶颈子过程</p>
<p>消除瓶颈的方法</p>
<ul>
<li>细分</li>
<li>瓶颈段并联</li>
</ul>
<h5 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h5><p>指流水线的速度与等效的非流水线的速度之比</p>
<p>$T_{非流水} = n <em> m </em> \Delta t_0$</p>
<p>$S<em>p = \frac {T</em>{非流水}}{T} = \frac{nm\Delta t_0}{m\Delta t_0 + (n-1)\Delta t_0} = \frac {m}{1+\frac{m-1}{n}}$ </p>
<h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>指流水线中的设备实际使用时间占整个运行时间之比，也称流水线设备的时间利用率</p>
<p>如果是线性流水线，且各段经过时间相等，则在T时间内，流水线的效率都相等，均为 $\eta _0$</p>
<p>即 $\eta _1 = \eta _2 = … = \frac {n\Delta t_0}{T}=\frac{n}{m+(n-1)}$ </p>
<p>整个流水线的效率$ \eta = \frac {\eta _0 + \eta _1 + … + \eta _m}{m} =  \frac{m\eta _0}{m}=\frac{mn\Delta t_0}{mT}$ </p>
<p>式中分母$mT$ 是时空图中m个段和流水总时间T所围成的面积，分子$mn\Delta t_0$是时空图中n个任务实际使用的面积。从时空图看，效率实际上就是n个任务占用的时空区面积和m个段总的时空区面积之比</p>
<h5 id="P117"><a href="#P117" class="headerlink" title="P117"></a>P117</h5><h4 id="标量流水机的相关处理和控制机构"><a href="#标量流水机的相关处理和控制机构" class="headerlink" title="标量流水机的相关处理和控制机构"></a>标量流水机的相关处理和控制机构</h4><p>流水线只有连续不断地流动，不出现断流，才能获得高效率。如果处理不恰当，就会使流水效率显著下降</p>
<p>造成断流的原因：</p>
<ul>
<li>编译形成的目标程序不能发挥流水结构作用</li>
<li>存储系统提供不上连续流动所需的指令/操作数</li>
<li>相关</li>
<li>中断</li>
<li>非线性流水线引起的冲突</li>
</ul>
<h5 id="局部相关的处理"><a href="#局部相关的处理" class="headerlink" title="局部相关的处理"></a>局部相关的处理</h5><ul>
<li>推后后续指令对相关单元的读，直至在先的指令写入完成</li>
<li>设置相关通路，将运算结果经过相关直接通路直接送入所需部件</li>
</ul>
<h5 id="全局相关的处理"><a href="#全局相关的处理" class="headerlink" title="全局相关的处理"></a>全局相关的处理</h5><ul>
<li>猜测法</li>
<li>加快和提前形成条件码</li>
<li>采取延迟转移</li>
<li>加快短循环程序的处理</li>
</ul>
<h5 id="流水机器的中断处理"><a href="#流水机器的中断处理" class="headerlink" title="流水机器的中断处理"></a>流水机器的中断处理</h5><p>中断会引起流水线断流，但是其出现概率比条件转移的概率要低得多，且又是随机发生的。所以，对流水机器的中断，主要应考虑如何处理好断点现场的保护和恢复，而不是如何缩短流水线的断流时间。</p>
<h5 id="非线性流水线调度"><a href="#非线性流水线调度" class="headerlink" title="非线性流水线调度"></a>非线性流水线调度</h5><ul>
<li><p>由于非线性流水线有反馈回路，在流入新任务时，可能会出现几个任务争用同一功能段的冲突现象。</p>
</li>
<li><p>流水线任务调度：相邻任务间隔多少拍进入流水线的调度问题</p>
<ul>
<li>不冲突</li>
<li>平均延迟最短</li>
<li>尽可能提高的吞吐率与效率</li>
</ul>
</li>
<li><p>对非线性流水线，采用二维预约表来实现任务优化调度与优化</p>
</li>
<li><p>K段单功能非线性流水线，每个任务通过流水线需要N拍</p>
</li>
<li><p>拍号：任务经过流水线的时钟节拍号</p>
</li>
<li><p>向一条非线性流水线的输入端连续输入两个任务之间间隔称为<strong>非线性流水线的启动距离</strong>或<strong>等待时间</strong>。</p>
</li>
<li><p>延迟禁止表：将流水线中所有各段对一个任务流过时会争用同一段的节拍间隔数汇集在一起。</p>
</li>
<li><p>冲突向量：用N-1位的位向量来表示后续新任务间隔各种不同拍数送入流水线时，是否会发生功能段使用的冲突</p>
<p>$（C_{n-1},…,C_i,…,C_2,C_1)$ 中第 $i$ 位的状态用以表示与当时相隔 $i$ 拍给流水线送入后继任务是否会发生功能段的使用冲突。发生1，不发生0</p>
</li>
</ul>
<h4 id="P185计算-冲突向量"><a href="#P185计算-冲突向量" class="headerlink" title="P185计算 冲突向量"></a>P185计算 冲突向量</h4><h3 id="指令级高度并行的超出处理机"><a href="#指令级高度并行的超出处理机" class="headerlink" title="指令级高度并行的超出处理机"></a>指令级高度并行的超出处理机</h3><h4 id="超标量处理机"><a href="#超标量处理机" class="headerlink" title="超标量处理机"></a>超标量处理机</h4><p>多条指令流水线，每个$\Delta t$同时流出m条指令（称为度m），考编译程序优化指令执行顺序。</p>
<p>组成：冗余设置，多套部件，多部件并发工作</p>
<h4 id="超流水线处理机"><a href="#超流水线处理机" class="headerlink" title="超流水线处理机"></a>超流水线处理机</h4><p>两种定义：</p>
<ul>
<li>一个周期内能够分时发射多条指令的处理机称为超流水线处理机</li>
<li>指令流水线有8个或更多功能段的流水线处理机称为超流水线处理机    </li>
</ul>
<p>提高处理机性能的不同方法：</p>
<ul>
<li>超标量处理机是通过增加硬件资源为代价来换取处理机性能的。</li>
<li>超流水线处理机则通过各硬件部件充分重叠工作来提高处理机性能。</li>
</ul>
<p>两种不同并行性：</p>
<ul>
<li>超标量处理机采用的是空间并行性</li>
<li>超流水线处理机采用的是时间并行性</li>
</ul>
<h4 id="超标量超流水线处理机"><a href="#超标量超流水线处理机" class="headerlink" title="超标量超流水线处理机"></a>超标量超流水线处理机</h4><ul>
<li><p>把超标量与超流水线技术结合在一起，就称为超标量超流水线处理机</p>
</li>
<li><p>指令执行时序</p>
<p>超标量超流水线处理机在一个Δ𝑡′ = Δ𝑡/𝑛时钟周期内分时发射𝑘条指令，相当于每个时钟周期Δ𝑡总共发射指令𝑛𝑘条。</p>
</li>
</ul>
<p>  ​<br>  ​<br>  ​<br>  ​    </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/计算机体系结构/" rel="tag"># 计算机体系结构</a>
          
            <a href="/tags/review/" rel="tag"># review</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/23/人工智能专题复习/" rel="next" title="人工智能复习">
                <i class="fa fa-chevron-left"></i> 人工智能复习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/19/计算机图形学专题复习/" rel="prev" title="计算机图形学复习要点">
                计算机图形学复习要点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a industrious programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机体系结构专题复习"><span class="nav-number">1.</span> <span class="nav-text">计算机体系结构专题复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-计算机系统结构基础及并行性的开发"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 计算机系统结构基础及并行性的开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机系统的层次结构"><span class="nav-number">1.1.1.</span> <span class="nav-text">计算机系统的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机系统结构、计算机组成和计算机实现"><span class="nav-number">1.1.2.</span> <span class="nav-text">计算机系统结构、计算机组成和计算机实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机系统的软、硬件取舍和性能评测及定量设计原理"><span class="nav-number">1.1.3.</span> <span class="nav-text">计算机系统的软、硬件取舍和性能评测及定量设计原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-数据表示、寻址方式与指令系统"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 数据表示、寻址方式与指令系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据表示"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据表示和数据结构"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">数据表示和数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级数据结构"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">高级数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻址方式（重点）"><span class="nav-number">1.2.2.</span> <span class="nav-text">寻址方式（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寻址方式的三个面向"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">寻址方式的三个面向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻址方式在指令中的指明"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">寻址方式在指令中的指明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#程序在主存中的定位技术"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">程序在主存中的定位技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令系统的设计和优化"><span class="nav-number">1.2.3.</span> <span class="nav-text">指令系统的设计和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令系统设计基本原则"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">指令系统设计基本原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令设计的步骤"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">指令设计的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#编译程序设计"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">编译程序设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#系统设计"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">系统设计</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令格式的优化"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">指令格式的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#操作码优化"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">操作码优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哈夫曼压缩（计算：哈夫曼树构成）"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">哈夫曼压缩（计算：哈夫曼树构成）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于哈夫曼编码的扩展操作码（计算：指令设计）"><span class="nav-number">1.2.3.3.3.</span> <span class="nav-text">基于哈夫曼编码的扩展操作码（计算：指令设计）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指令字格式的优化"><span class="nav-number">1.2.3.3.4.</span> <span class="nav-text">指令字格式的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指令编排（P63"><span class="nav-number">1.2.3.3.5.</span> <span class="nav-text">指令编排（P63)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令系统的发展和改进"><span class="nav-number">1.2.4.</span> <span class="nav-text">指令系统的发展和改进</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-存储、中断、总线与输入-输出系统"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 存储、中断、总线与输入/输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储系统的基本要求和并行主存系统"><span class="nav-number">1.3.1.</span> <span class="nav-text">存储系统的基本要求和并行主存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储系统的基本要求"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">存储系统的基本要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行主存系统"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">并行主存系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单体单字存储器"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">单体单字存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单体多字存储器"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">单体多字存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多体单字"><span class="nav-number">1.3.1.2.3.</span> <span class="nav-text">多体单字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定量分析-P85"><span class="nav-number">1.3.1.2.4.</span> <span class="nav-text">定量分析(P85)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结论"><span class="nav-number">1.3.1.2.5.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断系统"><span class="nav-number">1.3.2.</span> <span class="nav-text">中断系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断的分类和分级"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">中断的分类和分级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#中断的分类"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">中断的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中断和异常"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">中断和异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中断的分级"><span class="nav-number">1.3.2.1.3.</span> <span class="nav-text">中断的分级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断的响应和处理次序-P89"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">中断的响应和处理次序(P89)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#结论-1"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断系统的软、硬件分配"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">中断系统的软、硬件分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总线系统"><span class="nav-number">1.3.3.</span> <span class="nav-text">总线系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总线的分类"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">总线的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#按系统中的位置"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">按系统中的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按信息传送方向"><span class="nav-number">1.3.3.1.2.</span> <span class="nav-text">按信息传送方向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按使用方法"><span class="nav-number">1.3.3.1.3.</span> <span class="nav-text">按使用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线的控制方式"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">总线的控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#集中式控制"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">集中式控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总线的通讯方式"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">总线的通讯方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#同步通讯"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">同步通讯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步通讯（图什么意思）"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">异步通讯（图什么意思）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据宽度与总线线数"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">数据宽度与总线线数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据宽度"><span class="nav-number">1.3.3.4.1.</span> <span class="nav-text">数据宽度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总线的线数"><span class="nav-number">1.3.3.4.2.</span> <span class="nav-text">总线的线数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入-输出系统"><span class="nav-number">1.3.4.</span> <span class="nav-text">输入/输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入输出系统概述"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">输入输出系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#输入输出系统的特点"><span class="nav-number">1.3.4.1.1.</span> <span class="nav-text">输入输出系统的特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通道处理机的工作原理和流量设计"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">通道处理机的工作原理和流量设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通道处理机工作原理"><span class="nav-number">1.3.4.2.1.</span> <span class="nav-text">通道处理机工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#启动I-O指令"><span class="nav-number">1.3.4.2.2.</span> <span class="nav-text">启动I/O指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道数据传送方式"><span class="nav-number">1.3.4.2.3.</span> <span class="nav-text">通道数据传送方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道流量的设计"><span class="nav-number">1.3.4.2.4.</span> <span class="nav-text">通道流量的设计</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-存储体系"><span class="nav-number">1.4.</span> <span class="nav-text">第四章 存储体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.4.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储体系及其分支"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">存储体系及其分支</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主存—辅存存储层次（容量）"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">主存—辅存存储层次（容量）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache—主存存储层次（速度）"><span class="nav-number">1.4.1.1.2.</span> <span class="nav-text">Cache—主存存储层次（速度）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多级存储层次"><span class="nav-number">1.4.1.1.3.</span> <span class="nav-text">多级存储层次</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储体系构成依据"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">存储体系构成依据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储体系的性能参数（老师PDF中无）"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">存储体系的性能参数（老师PDF中无）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储器层次结构设计的问题"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">存储器层次结构设计的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器"><span class="nav-number">1.4.2.</span> <span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟存储器的管理方式"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">虚拟存储器的管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#段式管理"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">段式管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#页式管理"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">页式管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#段页式管理"><span class="nav-number">1.4.2.1.3.</span> <span class="nav-text">段页式管理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页式虚拟存储器的构成"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">页式虚拟存储器的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#地址映像和变换"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">地址映像和变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#页面替换算法-P125"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">页面替换算法(P125)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高速缓冲存储器"><span class="nav-number">1.4.3.</span> <span class="nav-text">高速缓冲存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工作原理和基本结构"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">工作原理和基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理"><span class="nav-number">1.4.3.1.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基本结构"><span class="nav-number">1.4.3.1.2.</span> <span class="nav-text">基本结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址映像与变换"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">地址映像与变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#地址映像"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">地址映像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#地址变换"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">地址变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选取地址映像方法考虑的主要因素"><span class="nav-number">1.4.3.2.3.</span> <span class="nav-text">选取地址映像方法考虑的主要因素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全相联映像和变换"><span class="nav-number">1.4.3.2.4.</span> <span class="nav-text">全相联映像和变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#直接映像与变换"><span class="nav-number">1.4.3.2.5.</span> <span class="nav-text">直接映像与变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组相联映像与变换"><span class="nav-number">1.4.3.2.6.</span> <span class="nav-text">组相联映像与变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#段相联映像"><span class="nav-number">1.4.3.2.7.</span> <span class="nav-text">段相联映像</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache存储器的LRU替换算法的硬件实现（不在老师PDF）"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Cache存储器的LRU替换算法的硬件实现（不在老师PDF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache存储器的透明性及性能分析"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Cache存储器的透明性及性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache存储器的透明性分析及其解决方法"><span class="nav-number">1.4.3.4.1.</span> <span class="nav-text">Cache存储器的透明性分析及其解决方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#共享主存多CPU系统保持内容一致性解决方法"><span class="nav-number">1.4.3.4.2.</span> <span class="nav-text">共享主存多CPU系统保持内容一致性解决方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P158-4-14"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">P158 4-14</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三级存储体系"><span class="nav-number">1.4.4.</span> <span class="nav-text">三级存储体系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-标量处理机"><span class="nav-number">1.5.</span> <span class="nav-text">第五章 标量处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重叠方式"><span class="nav-number">1.5.1.</span> <span class="nav-text">重叠方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重叠原理与一次重叠"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">重叠原理与一次重叠</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序解释"><span class="nav-number">1.5.1.1.1.</span> <span class="nav-text">顺序解释</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重叠解释"><span class="nav-number">1.5.1.1.2.</span> <span class="nav-text">重叠解释</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重叠解释的要求"><span class="nav-number">1.5.1.1.3.</span> <span class="nav-text">重叠解释的要求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关处理"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">相关处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流水方式"><span class="nav-number">1.5.2.</span> <span class="nav-text">流水方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念-1"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理-1"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流水线特点"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">流水线特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流水线分析"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">流水线分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流水线的分类—多功能的链接方式"><span class="nav-number">1.5.2.1.4.</span> <span class="nav-text">流水线的分类—多功能的链接方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流水线的分类—是否有反馈信号"><span class="nav-number">1.5.2.1.5.</span> <span class="nav-text">流水线的分类—是否有反馈信号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标量流水线的主要性能"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">标量流水线的主要性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#吞吐率"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">吞吐率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加速比"><span class="nav-number">1.5.2.2.2.</span> <span class="nav-text">加速比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#效率"><span class="nav-number">1.5.2.2.3.</span> <span class="nav-text">效率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P117"><span class="nav-number">1.5.2.2.4.</span> <span class="nav-text">P117</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标量流水机的相关处理和控制机构"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">标量流水机的相关处理和控制机构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#局部相关的处理"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">局部相关的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全局相关的处理"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">全局相关的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流水机器的中断处理"><span class="nav-number">1.5.2.3.3.</span> <span class="nav-text">流水机器的中断处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非线性流水线调度"><span class="nav-number">1.5.2.3.4.</span> <span class="nav-text">非线性流水线调度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P185计算-冲突向量"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">P185计算 冲突向量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令级高度并行的超出处理机"><span class="nav-number">1.5.3.</span> <span class="nav-text">指令级高度并行的超出处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#超标量处理机"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">超标量处理机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超流水线处理机"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">超流水线处理机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超标量超流水线处理机"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">超标量超流水线处理机</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("KzDP5NgGACc0bKLgfEtJ8Xrk-gzGzoHsz", "nGixqUVUQJjtTFuvDaoKrMo0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

  

  

  

</body>
</html>
