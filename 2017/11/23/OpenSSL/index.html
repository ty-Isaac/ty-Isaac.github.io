<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Openssl,Encrypt," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="OpenSSL实验在linux 中编译和安装 获得 OpenSSL  从OpenSSL的 官方网站 即可下载当前版本的 OpenSSL 源代码压缩包。当前版本为 openssl-1.0.2l。  在Linux中解压缩：  $tar zxf openssl-1.0.2l.tar.gz  编译和安装  $sudo ./config  $sudo make  $sudo make test  $sudo">
<meta name="keywords" content="Openssl,Encrypt">
<meta property="og:type" content="article">
<meta property="og:title" content="Openssl Encrypt">
<meta property="og:url" content="http://yoursite.com/2017/11/23/OpenSSL/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="OpenSSL实验在linux 中编译和安装 获得 OpenSSL  从OpenSSL的 官方网站 即可下载当前版本的 OpenSSL 源代码压缩包。当前版本为 openssl-1.0.2l。  在Linux中解压缩：  $tar zxf openssl-1.0.2l.tar.gz  编译和安装  $sudo ./config  $sudo make  $sudo make test  $sudo">
<meta property="og:image" content="http://img.hexun.com/2009-06-24/118958535.gif">
<meta property="og:image" content="http://img.hexun.com/2009-06-24/118958536.gif">
<meta property="og:image" content="http://img.hexun.com/2009-06-24/118958535.gif">
<meta property="og:image" content="http://img.hexun.com/2009-06-24/118958536.gif">
<meta property="og:updated_time" content="2017-12-12T00:02:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Openssl Encrypt">
<meta name="twitter:description" content="OpenSSL实验在linux 中编译和安装 获得 OpenSSL  从OpenSSL的 官方网站 即可下载当前版本的 OpenSSL 源代码压缩包。当前版本为 openssl-1.0.2l。  在Linux中解压缩：  $tar zxf openssl-1.0.2l.tar.gz  编译和安装  $sudo ./config  $sudo make  $sudo make test  $sudo">
<meta name="twitter:image" content="http://img.hexun.com/2009-06-24/118958535.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/23/OpenSSL/"/>





  <title> Openssl Encrypt | Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/23/OpenSSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Openssl Encrypt
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T11:23:38+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/23/OpenSSL/" class="leancloud_visitors" data-flag-title="Openssl Encrypt">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="OpenSSL实验"><a href="#OpenSSL实验" class="headerlink" title="OpenSSL实验"></a>OpenSSL实验</h1><h2 id="在linux-中编译和安装"><a href="#在linux-中编译和安装" class="headerlink" title="在linux 中编译和安装"></a>在linux 中编译和安装</h2><ol>
<li><p>获得 OpenSSL</p>
<p> 从OpenSSL的 <a href="http://www.openssl.org/source/" target="_blank" rel="external">官方网站</a> 即可下载当前版本的 OpenSSL 源代码压缩包。当前版本为 openssl-1.0.2l。</p>
<p> 在Linux中解压缩：</p>
<p> $tar zxf openssl-1.0.2l.tar.gz</p>
</li>
<li><p>编译和安装</p>
<p> $sudo ./config</p>
<p> $sudo make</p>
<p> $sudo make test</p>
<p> $sudo make install</p>
<p> 安装OpenSSL 开发包，这在所有的现代Linux发行版的标准软件仓库中都有。</p>
<p> $sudo apt-get install libssl-dev</p>
</li>
<li><p>编译代码文件</p>
<p> gcc 文件名.c -o 编译文件名 -lcrypto</p>
</li>
<li><p>我的代码使用方式</p>
<p> ECB模式，编译执行即可</p>
<p> CBC模式，分加密 和 解密 文件，需要先自己写data文件。 根据提示输入 文件名等信息</p>
<p> CFB模式、OFB模式，编译执行即可</p>
<p> AES模式，编译执行即可</p>
<p> RC4模式，编译执行即可</p>
<p> RSA加密，需要根据下文生成公钥和私钥，然后编译执行</p>
<p> RSA签名和认证，编译执行就可以</p>
</li>
</ol>
<h2 id="实验三-对称加密算法实验"><a href="#实验三-对称加密算法实验" class="headerlink" title="实验三 对称加密算法实验"></a>实验三 对称加密算法实验</h2><p>加密一般分为对称加密(Symmetric Key Encryption) 和非对称加密(Asymmetric Key Encryption)。对称加密又分为分组加密和序列密码。</p>
<p>分组密码，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。</p>
<p>序列密码，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥(制乱元素) 通过某种复杂的运算(密码算法) 产生大量的伪随机位流，用于对明文位流的加密。解密是指用同样的密钥和密码算法及与加密相同的伪随机位流，用于还原明文位流。</p>
<ol>
<li><p>DES 算法接口 </p>
<p> DES 加密算法是分组算法。 DES 的基本操作是把 64bit 明文在 56 bit 密钥指引下加密成64位密文</p>
<p> DES(IN,KEY) = OUT</p>
<p> 在openSSL中，DES算法的基本函数就是ECB 操作模式对应的函数  ==DES_ecb_encrypt()== 。该函数把一个8字节明文分组input加密成为一个 8 字节密文分组 output。</p>
<p> 参数中密钥结构 ks 是用函数 DES_set_key()准备好的， 而密钥 key 是用随机数算法产生的 64 个随机比特。</p>
<p> 参数enc 指示数 enc 指示是加密还是解密。</p>
<p> <strong>ECB操作模式</strong></p>
<p> 电子密码本模式，是最古老最简单的模式，将加密的数据分成若干组，每组的大小跟加密密钥长度相同，每组都使用相同的密钥加密，如果最后一个分组长度不够64位，要补齐64位。</p>
<p> 该函数每次只加密一个分组，因此用来加密很多数据时并不方便。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DES_ecb_encrypt</span><span class="params">(const_DES_cblock *input,DES_cblock *output, DES_key_schedule *ks,<span class="keyword">int</span> enc)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">DES_set_key</span><span class="params">(const_DES_cblock *key,DES_key_schedule *schedule)</span></span>;</div></pre></td></tr></table></figure>
<p> 特点：每次Key、明文、密文的长度都必须是64位 ；一个错误仅仅会对一个密文块产生影响；</p>
<p> ​</p>
<p> <strong>CBC操作模式</strong></p>
<p> 加密块链模式，与ECB模式最大的不同是加入了初始向量</p>
<p> DES 算法 CBC 操作模式加解密函数是 ==DES_ncbc_encrypt()==。参数length指示输入字节长度。如果长度不是8字节的倍数，则会被用0填充到8字节的倍数。因此，输出可能比length长，而且必然是8字节的倍数。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DES_ncbc_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input,<span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">long</span> length, DES_key_schedule *schedule, DES_cblock *ivec, <span class="keyword">int</span> enc)</span></span></div></pre></td></tr></table></figure>
<p> 特点：</p>
<ul>
<li>每次加密的密文长度为64位(8字节)；</li>
<li>当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文；</li>
<li>密文块要依赖以前的操作结果，所以密文块不能进行重新排列</li>
<li>可以使用不同的初始化向量来避免产生相同的密文，一定程度抵御字典共计</li>
<li><p>一个错误发生后，当前和以后的密文都将被影响</p>
<p>​</p>
<p><strong>CFB操作模式</strong></p>
<p>加密反馈模式，克服了需要等待8个字节才能加密的缺点，采用了分组密码作为流密码的密钥流生成器。</p>
<p>DES算法 CFB 操作模式加密函数是 DES_cfb_encrypt() 。参数length 指示输入字节长度。参数numbits 指示CFB 每次循环加密多少比特明文，也即密文反馈的比特数目。 ivec是初始向量，被看做第0个密文分组，是不用保密但应随机取值的8个字节。如果在一次会话中多次调用 DES_cfb_encrypt()，则应记忆ivec。<br>由于 CFB 模式中每次 DES 基本操作<br>只加密 numbits 比特明文，因此如果 numbits 太小则效率太低。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DES_cfb_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out, <span class="keyword">int</span> numbits, <span class="keyword">long</span> length, DES_key_schedule *schedule, DES_cblock *ivec, <span class="keyword">int</span> enc)</span></span>;</div></pre></td></tr></table></figure>
<p>​</p>
<p><strong>OFB操作模式</strong></p>
<p>与CFB模式不同之处在于，加密移位寄存器与密文无关了，仅与加密key和加密算法有关。</p>
<p>输出反馈模式，允许对不同字区大小编密码，但是它与密码反馈模式主要的区别在于编字区函数密码的输出是反馈（而不是密码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DES_ofb_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in,<span class="keyword">unsigned</span> <span class="keyword">char</span> *out,<span class="keyword">int</span> numbits,<span class="keyword">long</span> length,DES_key_schedule *schedule,DES_cblock *ivec)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DES_ofb64_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in,<span class="keyword">unsigned</span> <span class="keyword">char</span> *out,<span class="keyword">long</span> length,DES_key_schedule *schedule,DES_cblock *ivec,<span class="keyword">int</span>* num)</span></span>;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>AES 算法接口</p>
<p> 典型参数的 AES 的基本操作是把 128 比特明文在 128 比特密钥指引下加密成 128 比特密文。OpenSSL 中关于 AES 的函数名和参数接口和 DES 的雷同。相关函数名如下(参数略)。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">AES_set_encrypt_key</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">AES_set_decrypt_key</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AES_ecb_encrypt</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AES_cbc_encrypt</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AES_cfb128_encrypt</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AES_ofb128_encrypt</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>RC4</p>
<p> RC4 密码算法是流算法，也叫序列算法。流算法是从密钥作为种子产生密钥流，明文比特流和密钥流异或即加密。RC4 算法由于算法简洁，速度极快，密钥长度可变，而且也没有填充的麻烦，因此在很多场合值得大力推荐。</p>
<p> OpenSSL 中 RC4 算法有两个函数: RC4_set_key()设置密钥，RC4()加解密。可以把 RC4 看作异或，因此加密两次即解密。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC4set_key</span><span class="params">(RC4KEY key, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">unsigned</span> chardata)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC4</span><span class="params">(RC4_KEY key, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">const</span> <span class="keyword">unsigned</span> charindata, <span class="keyword">unsigned</span> <span class="keyword">char</span> *outdata)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="实验四-公钥算法实验"><a href="#实验四-公钥算法实验" class="headerlink" title="实验四 公钥算法实验"></a>实验四 公钥算法实验</h2><p>使用公钥密码算法可以克服协商对称密钥的困难，也可以用来认证和签名。为了避免公钥算法的速度缺陷，当前普遍使用混合密码体制，即使用公钥算法做鉴别和协商会话密钥，使用对称算法加密批量数据。</p>
<p>公钥密码算法当前仍是 RSA 算法占据统治地位。OpenSSL加密函数库中提供了对RSA等算法的支持。</p>
<p>不同于对称加密算法中加密和解密使用同样的密钥，公钥算法分为加密密钥 K1 和 解密密钥 K2 两部分，而且从 K1 很难计算和推导出 K2。 这样就可以保密 K2 而公布K1，从而大大简化了密钥管理。习惯上 K1 称为公钥 ，K2 称为私钥。</p>
<p>加密使用公钥，解密使用私钥</p>
<p>ENC (P , K1) = C</p>
<p>DEC (C , K2) = P</p>
<p>RSA 算法大致步骤</p>
<ol>
<li>寻找两个随机大素数 p 和 q ，保证p，q不相同</li>
<li>计算模 n = pq 和 Euler 函数  f(n) = (p-1)(q-1)</li>
<li>寻找一个与 f(n) 互质的数 e ，满足 1 &lt; e &lt; f(n)</li>
<li>选取 e 后用扩展 Euclid算法求数 d 满足 e * d ≡1 mod f(n)</li>
<li>保密私钥 KR = (d , n) ，发布公钥 KU = (e, n)</li>
<li>加密，先将明文变换成 0 至 n-1 的一个整数 M。若明文较长，可先分割成适当的组，然后再进行交换， 加密过程为 <img src="http://img.hexun.com/2009-06-24/118958535.gif" alt="img"></li>
<li>解密， <img src="http://img.hexun.com/2009-06-24/118958536.gif" alt="img"></li>
</ol>
<h3 id="RSA-密钥产生"><a href="#RSA-密钥产生" class="headerlink" title="RSA 密钥产生"></a>RSA 密钥产生</h3><p>RSA 密钥产生函数 RSA_generate_key()，需要指定模长比特数 bits 和公钥指数 e。另外两个参数为 NULL 即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RSA * RSA_generate_key(int bits, unsigned long e, void (*callback) (int,int,void *),void *cb_arg);</div></pre></td></tr></table></figure>
<p>目前对于长达663比特的 RSA 模数已经有成功分解的先例，因此当前典型的应用场合使用1024比特模长的 RSA 算法，此时一个分组是 128 字节。</p>
<p>如果从文件中读取密钥，可使用函数PEM_read_bio_PrivateKey()/ PEM_read_bio_PUBKEY()，其中 EVP_PKEY 中包含一个 RSA 结构，可以引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">EVP_PKEY *<span class="title">PEM_read_bio_PrivateKey</span><span class="params">(BIO *bp, EVP_PKEY **x,</span></span></div><div class="line">pem_password_cb *cb, <span class="keyword">void</span> *u);</div></pre></td></tr></table></figure>
<h3 id="RSA-加密和解密"><a href="#RSA-加密和解密" class="headerlink" title="RSA 加密和解密"></a>RSA 加密和解密</h3><p>RSA算法生成密钥</p>
<p><strong>1. 生成一个密钥</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out test.key 1024</div></pre></td></tr></table></figure>
<p>选项 -out 指定生成文件。该文件包含了公钥和私钥两部分，既可以用来加密也可以用来解密。 1024 表示生成密钥长度 </p>
<p><strong>2.将公钥提取出来</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl rsa -in test.key -pubout -out test_pub.key</div></pre></td></tr></table></figure>
<p>选项 -in 指定输入文件，-out 指定提取生成公钥的文件名。现在我们有一个公钥，一个私钥（包含公钥）</p>
<p>在以后的 RSA 代码中都会用到的公钥和私钥文件</p>
<p>RSA 加密函数 RSA_public_encrypt()使用公钥部分，解密函 RSA_private_decrypt() 使用私钥。填 充 方 式 常 用 的 有 两 种 RSA_PKCS1_PADDING 和 RSA_PKCS1_OAEP_PADDING。出错时返回-1&gt;输入必须比 RSA 钥模长短至少 11 字节(在 RSA_PKCS1_PADDING 时?)。输出长度等于 RSA 钥的模长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">RSA_public_encrypt</span><span class="params">(<span class="keyword">int</span> flen, <span class="keyword">const</span> *from,<span class="keyword">unsigned</span> <span class="keyword">char</span> *to, RSA *rsa,<span class="keyword">int</span> padding)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">RSA_private_decrypt</span><span class="params">(<span class="keyword">int</span> flen, <span class="keyword">const</span> *from,<span class="keyword">unsigned</span> <span class="keyword">char</span> *to, RSA *rsa,<span class="keyword">int</span> padding)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="RSA-签名和验证"><a href="#RSA-签名和验证" class="headerlink" title="RSA 签名和验证"></a>RSA 签名和验证</h3><p>签名使用私钥，验证使用公钥。RSA签名操作是把被签署消息的散列值编码后用私钥加密，因此函数中参数 type 用来指示散列函数的类型，一般是NID_MD5,NID_sha1 正确情况下返回 0 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">RSA_sign</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *m, <span class="keyword">unsigned</span> <span class="keyword">int</span> m_length, <span class="keyword">unsigned</span> <span class="keyword">char</span> *sigret, <span class="keyword">unsigned</span> <span class="keyword">int</span> *siglen, RSA *rsa)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">RSA_verify</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *m, <span class="keyword">unsigned</span> <span class="keyword">int</span> m_length, <span class="keyword">unsigned</span> <span class="keyword">char</span> *sigbuf, <span class="keyword">unsigned</span> <span class="keyword">int</span> siglen, RSA *rsa)</span></span>;</div></pre></td></tr></table></figure>
<h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><p>抗否认</p>
<p>抵赖性</p>
<p>完整性</p>
<p>认证问题</p>
<p>实验报告提交要求</p>
<p>danny0128@126.com</p>
<p>主题 ： 2014IS 一个doc 文档</p>
<p>doc 文档命名： 学号+姓名.doc</p>
<p>deadline : </p>
<p>周五那一天 半夜12点</p>
<p>实验结束后实验报告邮件</p>
<p>平时成绩 ： 网络登录 + 小测验 +  </p>
<p>基本概念</p>
<p>数字证书，ITEM 术语  ，穷举攻击，所有的基本概念</p>
<p>这是啥，为啥，原理性。 数字证书怎么保证认证， kerberos 协议如何认证，道理讲清楚</p>
<p>基本原理</p>
<p>基本理论，基本原理，基本应用 </p>
<p>重点搞清楚原理</p>
<p>第三章，第四章，第五章 </p>
<p>第六章三重des 和流</p>
<h1 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h1><h2 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h2><h3 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h3><p>网络空间</p>
<p>OSI安全框架：安全性攻击、安全机制、安全服务</p>
<p>安全攻击：</p>
<ul>
<li>任何危及信息系统安全的行为</li>
</ul>
<ul>
<li>分类：主动，对数据流进行修改或伪造数据(伪装、重播、消息修改、拒绝服务) 、 被动，对传输进行监听(内容泄露、流量分析)</li>
</ul>
<p>安全服务：</p>
<ul>
<li>加强数据处理系统和信息传输的安全性的一种处理过程或通信服务。</li>
<li>分类：<ul>
<li>认证：保证通信双方是它所声称的实体。（同等实体认证、数据源认证）</li>
<li>访问控制：阻止对资源的非授权使用</li>
<li>数据保密性：保护数据免于非授权泄露</li>
<li>数据完整性：保证收到的数据的确是授权实体所发出的数据（没有修改、插入、删除或重播）</li>
<li>不可否认性：防止通信过程中，任一通信实体进行否认的行为</li>
</ul>
</li>
</ul>
<p>安全机制：</p>
<ul>
<li>用来检测、阻止攻击或从攻击状态恢复到正常状态的过程</li>
</ul>
<ul>
<li>加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制</li>
</ul>
<h3 id="第二章-传统加密技术"><a href="#第二章-传统加密技术" class="headerlink" title="第二章 传统加密技术"></a>第二章 传统加密技术</h3><p>对称密码模型 ：明文、加密算法、密钥、密文、解密算法</p>
<p>传统密码安全使用两个要求：</p>
<ul>
<li>加密算法必须足够强的</li>
<li>发送者和接收者必须在某种安全的形式下活动密钥并且必须保证密钥安全</li>
</ul>
<p>密码编码学系统的独立特征：</p>
<ul>
<li>转换明文为密文的运算类型，所有的加密算法都基于两个原理，替代和置换</li>
<li>所用的密钥数，对称密码 和 非对称密码</li>
<li>处理明文的方法， 分组密码 和 流密码</li>
</ul>
<p><strong>密码分析学</strong>：利用算法的特征来推导特定的明文或使用的密钥。</p>
<p><strong>穷举攻击</strong>：对一条密文尝试所有可能的密钥，直到把它转化为可读的有意义的明文</p>
<p><strong>无条件安全</strong>：无论有多少可使用的密文，都不足以唯一地确定所对应的明文。</p>
<p><strong>计算安全</strong>：</p>
<ul>
<li>破译密码的代价超出密文信息的价值 </li>
<li>破译密码的时间超出密文信息的有效生命期</li>
</ul>
<p>代替技术：</p>
<ul>
<li>定义：将明文字母替换成其他字母、数字或符号。</li>
<li>凯撒密码：对字母表中的每个字母用它之后的第三个字母来替代。</li>
<li>单表代替密码：明文的单个字母用1个字母表加密</li>
<li>Playfair密码：明文的双字母音节作为单元转换成密文的双字母音节</li>
<li>Hill密码：m个连续明文字母替换成m个密文字母</li>
<li>多表代换密码：明文采用不同的单表代换</li>
<li>一次一密：随机密钥，密钥只对一条信息加密，无法实现</li>
</ul>
<p>置换技术：对明文进行置换（仅改变位置）</p>
<h3 id="第三章-分组密码"><a href="#第三章-分组密码" class="headerlink" title="第三章 分组密码"></a>第三章 分组密码</h3><p><strong>流密码</strong>：每次加密数据流的一位/一个字节，使用<strong>密钥作为种子</strong>产生伪随机序列并和明文异或产生密文，两次异或即解密。</p>
<p><strong>分组密码</strong>：将明文分成固定长度的块，对每个分组用相同算法和密钥加/解密（分组一般为64bit）输出密文与明文分组<u>一样长的密文分组</u>。许多分组密码采用Feistel结构（由许多相同轮函数组成，每一轮里，对输入数据的一半进行代替，接着用一个置换来交换数据的两个部分。每轮使用不同的子密钥。</p>
<p>Feistel密码建议使用乘积密码来逼近理想分组密码，建议交替使用代替和置换。   </p>
<ul>
<li><strong>混淆</strong>：尽可能使密文和加密密钥间统计关系更复杂，以阻止攻击者发现密钥</li>
<li><strong>扩散</strong>：使明文的统计特征消失在密文中</li>
</ul>
<p>Feistel密码设计元素：</p>
<ul>
<li>分组长度：分组越长意味着安全性越高，但是会降低加/解密速度</li>
<li>密钥长度：密钥较长意味着安全性较高，但会降低加/解密速度</li>
<li>迭代轮数：典型值 16</li>
</ul>
<p>数据加密标准(DES)：采用64位分组长度和56位密钥长度，输出密文64位。</p>
<p><strong>雪崩效应</strong>：明文或密钥的某一位发生变化会导致密文的很多位都发生变化。</p>
<p>链接第6章：</p>
<p><strong>ECB 电子密码本</strong>：用相同的密钥分别对明文分组<u>独立加密</u>，每次使用相同的密钥加密。适合于数据较少的情况，比如加密密钥。很长的消息ECB模式不安全</p>
<p><strong>CBC密文分组链接</strong>：加密算法的输入是<strong>下一个明文组和上一个密文组的异或</strong>，最后分组不完整就填充。面向分组的通用传输，认证</p>
<p><strong>CFB密文反馈模式</strong>：可以将分组密码当做流密码使用。不需要填充明文分组</p>
<p><strong>OFB输出反馈模式</strong>：和CFB类似，它用加密函数的输出填充移位寄存器。而CFB使用密文单元来填充。 优点：传输过程中在某位上发生的错误不会影响其他位。 缺点：抗消息流篡改攻击能力不如CFB</p>
<h3 id="第四章-数论和有限域"><a href="#第四章-数论和有限域" class="headerlink" title="第四章 数论和有限域"></a>第四章 数论和有限域</h3><p>群、环、域</p>
<p>Euclid算法求最大公因子（辗转相除法）。继续除法过程直到余数为0</p>
<p>模运算 </p>
<h3 id="第五章-高级加密标准"><a href="#第五章-高级加密标准" class="headerlink" title="第五章 高级加密标准"></a>第五章 高级加密标准</h3><p>AES 高级加密标准：对称分组密码算法，<strong>分组长度为128位</strong>，密钥长度为128位、192位或256位。 </p>
<p>四个不同阶段： </p>
<ul>
<li>字节替代：用一个S盒完成分组的字节到字节的替代</li>
<li>行位移：简单置换</li>
<li>列混淆、</li>
<li>轮密钥加：当前分组和扩展密钥的一部分进行按位异或</li>
</ul>
<p>AES vs DES ：</p>
<p>并行处理整个分组 vs 一次处理一半分组</p>
<p>各个部件必须可逆 vs F函数无须可逆</p>
<p>AES不是Feistel 结构（经典Feistel 结构中，数据分组中的一半被用来修改数据分组的另一半，然后交换这两个分组）</p>
<p>AES中是每一轮都是用代替和混淆将整个数据分组作为单一矩阵处理</p>
<h3 id="第六章-分组密码工作模式"><a href="#第六章-分组密码工作模式" class="headerlink" title="第六章 分组密码工作模式"></a>第六章 分组密码工作模式</h3><p><strong>多重加密</strong>：将一个加密算法使用多次的技术</p>
<p><strong>双重DES</strong> ：进行两次加密，每次使用不同的密钥，但易遭遇中间相遇攻击</p>
<p>中间相遇攻击：将 p 按所有可能的密钥 K~1~ 加密，得到结果放在表内。然后将 C 用所有可能的密钥 K~2~ 解密，每解密一次就将解密结果与表中的值比较，如果相等就用此密钥对对一个新的明密文进行验证。</p>
<p>流密码：每次加密一个字节的明文，随机密钥流与明文的每一个字节进行对位异或运算，得到一个字节</p>
<p>流密码设计因素：加密序列的周期要长、密钥流尽可能地接近于真正随机数流的特征。</p>
<p><strong>链路加密</strong> ：加密是在系统中每一段通信链路的两端独立发生，链路之间每次交换都必须被解密。</p>
<p><strong>端对端加密</strong>：加解密过程在系统两端进行，在两端需要加密装置，源主机与目的主机共享密钥</p>
<p>随机数的性质： P157</p>
<ol>
<li><p><strong>随机性</strong></p>
<ul>
<li>分布均匀：序列中的位分布应是均匀的</li>
<li>独立性：序列中任何子序列不能由其他子序列推导出</li>
</ul>
</li>
<li><p><strong>不可预测</strong></p>
<p>随机数序列不可预测</p>
</li>
</ol>
<p>伪随机数发生器两种算法：线性同余、BBS</p>
<p>对称加密如何实现密钥分发？</p>
<ol>
<li><p>密钥分配为需要传输和加密数据的通信双方提供传递密钥的功能。主密钥不经常使用但长期使用，会话密钥临时生成和分发给通信双方</p>
<hr>
</li>
<li><ul>
<li>密钥分配模式（5个步骤）P298</li>
<li>透明的密钥控制方案（4个步骤） P300</li>
<li>分布式密钥控制（3个步骤）P300</li>
</ul>
</li>
</ol>
<h3 id="第八章-数论入门"><a href="#第八章-数论入门" class="headerlink" title="第八章 数论入门"></a>第八章 数论入门</h3><p>费马定理：</p>
<p>欧拉函数：</p>
<p>欧拉定理：</p>
<h3 id="第九章-公钥密码学与RSA"><a href="#第九章-公钥密码学与RSA" class="headerlink" title="第九章 公钥密码学与RSA"></a>第九章 公钥密码学与RSA</h3><p>公钥算法用两个密钥中的一个及加密算法将明文转换位密文。用另一个密钥及解密算法从密文恢复出明文。</p>
<p>特点：</p>
<ul>
<li>仅根据密码算法和加密密钥来确定解密密钥在计算上不可行。</li>
<li>两个密钥任何一个都可以用来加密，另一个用来解密</li>
</ul>
<p>公钥—— 任何人都可获得，用于加密消息或验证签名</p>
<p>私钥—— 只有解密者或签名者知道</p>
<p>非对称性：实现加密密钥和解密密钥分离，加密者不能解密非自己发送的消息，验证者不能伪造他人的签名。</p>
<p>公钥密码体制的应用：</p>
<ul>
<li>加密/解密：发送方用接收方的公钥对消息加密</li>
<li>数字签名：发送方用其私钥对消息“签名”。签名可以通过对整条信息或者对信息的一个小的数据块加密来产生，其中该小数据块是整条消息的函数。</li>
<li>密钥交换：通信双方交换会话密钥。</li>
</ul>
<p>公钥密码要求（6个）P196</p>
<p>RSA算法：</p>
<ol>
<li>密钥生成：<ol>
<li>寻找两个随机大素数 p 和 q ，保证p，q不相同</li>
<li>计算模 n = pq 和 Euler 函数  f(n) = (p-1)(q-1)</li>
<li>寻找一个与 f(n) 互质的数 e ，满足 1 &lt; e &lt; f(n)</li>
<li>选取 e 后用扩展 Euclid算法求数 d 满足 e * d ≡1 mod f(n)</li>
<li>保密私钥 KR = (d , n) ，发布公钥 KU = (e, n)</li>
</ol>
</li>
<li>加解密过程<ol>
<li>加密，先将明文变换成 0 至 n-1 的一个整数 M。若明文较长，可先分割成适当的组，然后再进行交换， 加密过程为 <img src="http://img.hexun.com/2009-06-24/118958535.gif" alt="img"></li>
<li>解密， <img src="http://img.hexun.com/2009-06-24/118958536.gif" alt="img"></li>
</ol>
</li>
</ol>
<p>使用乘方运算，明文以分组为单位进行加密，每个分组的二进制值均小于n。</p>
<p>RSA的安全性：对RSA算法攻击4种方式</p>
<ul>
<li>穷举攻击：试图穷举所有可能的私钥</li>
<li>数学攻击：实质是试图分解两个素数的乘积</li>
<li>计时攻击：依赖于解密算法的运行时间</li>
<li>选择密文攻击：利用RSA性质</li>
</ul>
<h3 id="第十章-密钥管理和其他公约密码体制"><a href="#第十章-密钥管理和其他公约密码体制" class="headerlink" title="第十章 密钥管理和其他公约密码体制"></a>第十章 密钥管理和其他公约密码体制</h3><ol>
<li><p>Diffie-Hellman 密钥交换</p>
<p>协议可以让双方在完全没好友任何预先信息的条件下通过不安全信道建立起一个密钥，该密钥在后续通讯中作为对称密钥来加密通讯内容。</p>
<p>其有效性是建立在计算离散对数是很困难的基础上的。</p>
</li>
<li><p>密钥交换过程 P218 10.2</p>
</li>
<li><p>这种协议不能抵抗所谓的中间人攻击，因为没有对通信双方进行认证。这些缺陷可以通过数字签名和公钥证书来克服。 </p>
</li>
<li><p><strong>公钥分发</strong>：</p>
<ul>
<li>公开发布：任何人都可以伪装这种公钥的公开发布易造成中间人攻击</li>
<li>公开可访问目录：一旦攻击者获得目录管理员私钥，则可以假冒任何通信方窃取信息</li>
<li>公钥授权：用户要与其他用户通信就必须向目录管理员申请对方公钥，因此公钥管理员称为系统瓶颈，他所维护的目录容易被篡改</li>
<li>公钥证书：通信双方使用证书交换密钥而不是管理员（4个要求）。X.509标准用来规范公钥证书格式</li>
</ul>
</li>
<li><p>非对称加密的对称密钥分发，公钥加密系统的效率比较低，所以几乎不会用于加密大数据块。</p>
<ol>
<li>简单的密钥分发（4步骤）P302</li>
<li>确保保密性和身份认证的密钥分发方案（5步骤）P303</li>
<li>混合方案（基于KDC）    KDC和每个用户共享一个主密钥，用主密钥加密要分发的会话密钥。</li>
</ol>
</li>
</ol>
<h3 id="第十一章-消息认证和Hash函数"><a href="#第十一章-消息认证和Hash函数" class="headerlink" title="第十一章 消息认证和Hash函数"></a>第十一章 消息认证和Hash函数</h3><p><strong>消息认证</strong>：用来验证消息完整性的一种机制或服务，确保收到的数据和发送时一样，且发送方声称的身份真实有效</p>
<p>三种消息认证函数（用来生成认证符）</p>
<ul>
<li>Hash函数：将任意长的消息映射为定长的Hash值函数，以该Hash值作为认证符。</li>
<li>消息加密：把整个消息加密后作为认证符。</li>
<li>消息认证码Mac：消息和密钥的函数，它产生定长的值，以该值作为认证符。</li>
</ul>
<p>网络通信可能受到的攻击（8种）</p>
<ul>
<li>保密性：①泄露 ②传输分析</li>
<li>消息认证：③伪装 ④内容修改 ⑤顺序修改 ⑥计时修改</li>
<li>数字签名：⑦发送方否认 ⑧接收方否认</li>
</ul>
<p>消息加密</p>
<ul>
<li>对称加密：既可以提供认证又可提供保密性，但不绝对</li>
<li>公钥加密：可提供保密性，但不能提供认证，若还想认证需要先用私钥加密（数字签名），再用公钥对结果加密。</li>
</ul>
<p>消息认证码</p>
<p>利用消息和密钥来生成一个固定长度的短数据块，并将该数据块附加在消息之后。接收方通过计算Mac来认证消息</p>
<p>Hash函数</p>
<p>输入是可变大小的消息M，输出是固定大小的散列码，不使用密钥，是消息认证的一种变形，散列码是所有消息位的函数，具有错误检查功能，改变消息的一位或多位都会导致值改变。</p>
<h3 id="第十三章-数字签名"><a href="#第十三章-数字签名" class="headerlink" title="第十三章 数字签名"></a>第十三章 数字签名</h3><p><strong>数字签名</strong>：一种认证机制，使得消息的产生者可以添加一个起签名作用的码字。通过计算消息的hash值，并用产生者的私钥加密hash值来生成签名。签名保证了消息的<strong>来源</strong>和完整性。</p>
<p>数字签名标准是NIST标准，使用安全HASH算法(SHA)</p>
<p>消息认证可以保护信息交换双方不受第三方的攻击，但不能处理通信双方自身发送的攻击。（抵赖）</p>
<p>数字签名特征：</p>
<ul>
<li>能验证签名者、签名日期和时间</li>
<li>能认证被签的消息内容</li>
<li>签名能由第三方仲裁</li>
</ul>
<p>数字签名需求：</p>
<ol>
<li>签名必须是与消息相关的二进制位串。</li>
<li>签名必须使用发送方某些独有的信息，以防伪造和否认</li>
<li>产生数字签名比较容易。</li>
<li>识别和验证数字签名比较容易。</li>
<li>伪造数字签名在计算上是不可以行的</li>
</ol>
<h3 id="第十四章-认证应用"><a href="#第十四章-认证应用" class="headerlink" title="第十四章 认证应用"></a>第十四章 认证应用</h3><p>单向认证应用之一是电子邮件服务，不要求发送者和接收者同时在线。</p>
<p>双向认证协议能够使通信双方相互认证彼此身份并交换会话密钥（时效性、保密性）</p>
<p>认证方法包括：①鉴定（身份）指用户提供一个声明的身份给系统 ②认证（用户）使得该声明成为有效的一种方法</p>
<p>用户认证和消息认证是不一样的（消息认证允许通信双方验证受到的消息是否更改以及资源是否可信）</p>
<p>基于网络的用户认证，最重要的认证方法包括加密密钥和用户个人口令</p>
<p><strong>kerberos 解决问题</strong>：在开放的分布式网络环境中，用户通过网络对分布在网络中的各种服务提出请求，希望服务器能够只对授权用户提供服务，并能鉴别服务类别。</p>
<p>kerberos 通过提供一个集中的授权服务器来负责用户对服务器的认证和服务器对用户的认证。 </p>
<p>kerberos ：安全性、可靠性、透明性、可伸缩</p>
<p>三个概念： 认证服务器（AS）：将所有用户口令集中存在本地数据库，其与每个应用服务器共享一个唯一密钥 ； 客户端（C）：代替用户与服务器进行信息交换  ；票据 （Ticket）：身份或权利的证明</p>
<p>kerberos 简单认证会话过程：</p>
<p>简单认证的问题：1. 每一访问新服务需要新的票据，导致用户多次输入口令 2.用明文传递的用户口令会被窃听</p>
<p>CA生成的用户证书特点： ①任何可以访问CA公钥的用户均可获得证书中的用户公钥</p>
<p>②只有CA可以修改证书 </p>
<p>PKI系统（公钥基础设施）是由硬件、软件、人、策略和程序构成的一整套体系，这些程序用来创建、管理、存储、分发和撤销建立在非对称密码算法之上的数字证书创建PKI的目的就是用来安全高效地获取公钥</p>
<h2 id="问答题考点"><a href="#问答题考点" class="headerlink" title="问答题考点"></a>问答题考点</h2><ol>
<li><p>对称加密算法</p>
<ol>
<li><p>五个基本要素：明文、密文、密钥、加密算法、解密算法</p>
</li>
<li><p>分组密码算法：</p>
<p>明文被分为固定长度的块（即分组），对每个分组用相同的算法和密钥加解密。分组一般为 n = 64 bit ，或更长（填充），密文分组和明文分组同样长</p>
</li>
<li><p>流密码算法</p>
<p>每次加密一个比特，适合比如远程终端输入等应用。流密码可用伪随机数发生器实现。密钥作为随机数种子，产生密钥流 keystream</p>
</li>
<li><p>比较</p>
<ul>
<li>粒度  8字节分组 vs 1比特 或 1字节</li>
<li>相同的明文分组，总是输出相同的密文分组；流密码输出不同的密文比特</li>
<li>流密码快很多</li>
</ul>
</li>
<li><p>工作模式</p>
<ul>
<li>电子密码本模式  ECB操作模式</li>
<li>密码分组链接模式  CBC 操作模式</li>
<li>密码反馈模式  CFB 操作模式</li>
<li>输出反馈模式  OFB操作模式</li>
<li>计数模式  RC4操作模式</li>
</ul>
</li>
</ol>
</li>
<li><p>非对称加密算法</p>
<ol>
<li><p>对称加密算法</p>
<p>加密：E ( P , K ) = C   解密 ： D ( C , K ) = P</p>
</li>
<li><p>非对称加密算法</p>
<ul>
<li><p>密钥：K = ( Kd , Ke ) </p>
</li>
<li><p>加密：E ( P , Ke ) = C</p>
</li>
<li><p>解密：D ( C , Kd) = P</p>
<p>Kd 称为私钥，Ke称为私钥</p>
</li>
</ul>
</li>
<li><p>参数建立</p>
<p>每个用户生成密钥对 ( Ke , Kd )</p>
<p>Ke 或 Kd 是一个或几个数(大素数)，而不是随机比特(对称算法)</p>
<p>Ke 需要公开，Kd 个人保留</p>
</li>
<li><p>RSA算法</p>
</li>
</ol>
</li>
<li><p>真随机数与伪随机数的区别</p>
<p>密码算法大多使用算法来生产随机数，算法是确定的，所以产生的序列并非统计随机。这样的数称为伪随机数</p>
</li>
<li><p>古典密码与现代密码本质区别</p>
<p>现代密码算法公开，古典密码算法不公开</p>
</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Openssl/" rel="tag"># Openssl</a>
          
            <a href="/tags/Encrypt/" rel="tag"># Encrypt</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/12/人机交互/" rel="next" title="人机交互">
                <i class="fa fa-chevron-left"></i> 人机交互
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/05/Android/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oo9y7ylu4.bkt.clouddn.com/image/blog/headIcon/IMG_7483.jpg"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a industrious programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OpenSSL实验"><span class="nav-number">1.</span> <span class="nav-text">OpenSSL实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在linux-中编译和安装"><span class="nav-number">1.1.</span> <span class="nav-text">在linux 中编译和安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验三-对称加密算法实验"><span class="nav-number">1.2.</span> <span class="nav-text">实验三 对称加密算法实验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验四-公钥算法实验"><span class="nav-number">1.3.</span> <span class="nav-text">实验四 公钥算法实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-密钥产生"><span class="nav-number">1.3.1.</span> <span class="nav-text">RSA 密钥产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-加密和解密"><span class="nav-number">1.3.2.</span> <span class="nav-text">RSA 加密和解密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSA-签名和验证"><span class="nav-number">1.3.3.</span> <span class="nav-text">RSA 签名和验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复习"><span class="nav-number">2.</span> <span class="nav-text">复习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考试"><span class="nav-number">3.</span> <span class="nav-text">考试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复习-1"><span class="nav-number">3.1.</span> <span class="nav-text">复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-概述"><span class="nav-number">3.1.1.</span> <span class="nav-text">第一章 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章-传统加密技术"><span class="nav-number">3.1.2.</span> <span class="nav-text">第二章 传统加密技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章-分组密码"><span class="nav-number">3.1.3.</span> <span class="nav-text">第三章 分组密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章-数论和有限域"><span class="nav-number">3.1.4.</span> <span class="nav-text">第四章 数论和有限域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五章-高级加密标准"><span class="nav-number">3.1.5.</span> <span class="nav-text">第五章 高级加密标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章-分组密码工作模式"><span class="nav-number">3.1.6.</span> <span class="nav-text">第六章 分组密码工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第八章-数论入门"><span class="nav-number">3.1.7.</span> <span class="nav-text">第八章 数论入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第九章-公钥密码学与RSA"><span class="nav-number">3.1.8.</span> <span class="nav-text">第九章 公钥密码学与RSA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十章-密钥管理和其他公约密码体制"><span class="nav-number">3.1.9.</span> <span class="nav-text">第十章 密钥管理和其他公约密码体制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十一章-消息认证和Hash函数"><span class="nav-number">3.1.10.</span> <span class="nav-text">第十一章 消息认证和Hash函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十三章-数字签名"><span class="nav-number">3.1.11.</span> <span class="nav-text">第十三章 数字签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十四章-认证应用"><span class="nav-number">3.1.12.</span> <span class="nav-text">第十四章 认证应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问答题考点"><span class="nav-number">3.2.</span> <span class="nav-text">问答题考点</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("KzDP5NgGACc0bKLgfEtJ8Xrk-gzGzoHsz", "nGixqUVUQJjtTFuvDaoKrMo0");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  

  

  

  

</body>
</html>
