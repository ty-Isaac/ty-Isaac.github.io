<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="It&apos;s a bolg that belongs to a industrious programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="Ty_Isaac">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="It&apos;s a bolg that belongs to a industrious programmer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ty_Isaac">
<meta name="twitter:description" content="It&apos;s a bolg that belongs to a industrious programmer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/25/Education/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/25/Education/" itemprop="url">
                  Education
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-25T09:58:46+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h3><ul>
<li>Some teachers flet hindered by a lack of resources. 有些教师因资源不足而感到困难重重</li>
<li>the school curriculum 学校课程  / English is on the curriculum. 英语已纳入课程内容</li>
<li>radiate confidence 流露自信</li>
<li>These tasks were repetitive, lengthy and lacking any intrinisc interest.这些作业重复冗没有什么意义。</li>
<li>the intrinsic value of education教育的固有价值</li>
<li>Children do not know by instinct the difference between right and wrong. 儿童并非生来就会分辨非</li>
</ul>
<h4 id="家庭对教育的作用"><a href="#家庭对教育的作用" class="headerlink" title="家庭对教育的作用"></a>家庭对教育的作用</h4><ol>
<li><p>good parenting 父母的良好培养</p>
</li>
<li><p>build strong family relationships 建设具有凝聚力的家庭关系</p>
<ul>
<li>build a sense of belonging 建立起一种归属感</li>
<li>have meals as a family 一起进餐</li>
<li><u>share family chores 一起做家务</u></li>
<li>share ideas and feelings 分享想法和感受</li>
<li>solve problems together 通过合作解决问题</li>
<li>participate in community activities together 一起参加社区活动</li>
<li>strengthen family bonds 增进亲情</li>
<li>achieve a reasonable work-family balance实现工作和家庭之间的合理平衡</li>
<li>help their children with homework 帮助孩子做好功课</li>
<li>monitor academic performance of their children监督他们孩子的学业表现</li>
<li>are more involved in the education of their children（家长）更积极地参与到孩子的教育当中</li>
<li>teach their children good manners 教给孩子良好的举止</li>
<li>provide positive role models for their children为孩子提供正面榜样</li>
</ul>
</li>
<li><p>working parents 工作的家长们</p>
<ul>
<li>have busy careers 事业很忙碌</li>
<li>spend their after school hours without adult supervision（孩子们）在放学之后的时间里缺少成年人的看护</li>
<li><u>Internet addiction 网瘾</u></li>
<li>spend too much time online 花费过多的时间上网</li>
<li>weaken family bonds 削弱亲情</li>
<li>feel disconnected from each other（家长们）感觉彼此之间缺少联系</li>
<li><u>cause family conflict 引起家庭纠纷</u></li>
<li><u>high divorce rates 很高的离婚率</u></li>
</ul>
</li>
<li><p>parenting style / children-rearing style 育儿方式</p>
<ol>
<li><p>两种家长 </p>
<ul>
<li>authoritarian parents 专制、强势的家长</li>
<li>expect their children to do exactly what they are told 期待孩子完全按照被要求地去做</li>
<li>stifle their creativity 压制孩子们的创造力</li>
<li>damage their self-confidence 打击他们的自信心</li>
</ul>
<hr>
<ul>
<li>permissive parents 过于放纵的家长</li>
<li>spoil their children 溺爱孩子</li>
<li>behave badly （孩子）表现不好</li>
<li>behave as they please (孩子) 随心所欲地行事</li>
</ul>
</li>
<li><p>正确的育儿方式</p>
<ul>
<li>are understanding and supportive 理解并支持孩子</li>
<li>respect their feelings 尊重他们的感受</li>
<li>support their choices 支持他们的选择</li>
<li>respect their individuality 尊重他们的个性</li>
<li>give them advice and support 为他们提供建议和支持</li>
<li>encourage them to think independently 鼓励他们去独立思考</li>
<li>help them build self-confidence 帮助他们树立自信</li>
<li>help them achieve their potential 帮助他们发挥出自己的潜力</li>
</ul>
</li>
</ol>
</li>
<li><p>Emotional health / emotional well-being 心理健康</p>
<ul>
<li>provide them with emotional support (家长)为孩子提供心理与情感上的支持</li>
<li>(孩子)向家长需求建议</li>
<li>对于他们的心理健康有害</li>
</ul>
</li>
<li><p>develop good moral values 形成良好的道德观念</p>
<ul>
<li>teach children about social responsibility (老师或家长)让孩子懂得自己的社会责任</li>
<li>教孩子明辨是非</li>
</ul>
</li>
<li><p>good behaviour 良好的行为 </p>
<ul>
<li>follow school rules 遵循学校的规定</li>
<li>develop self-control 发展自我约束力</li>
<li>develop self-discipline 发展自制力</li>
<li>well-behaved students 行为表现良好的学生</li>
<li>teach them good manners and etiquette 教给他们良好的举止和礼仪</li>
<li>break school rules 违反学校规定</li>
</ul>
</li>
<li><p>their peers 他们的同龄人</p>
<ul>
<li>peer pressure 来自同龄人的压力</li>
<li>are in their formative years 还处在性格的形成的阶段</li>
<li>often act on implus 时常会冲动地行事<ul>
<li>Teenagers often act on impulse and get into trouble with their parents. </li>
</ul>
</li>
<li>are influenced by peer pressure 受到同龄人的影响 <ul>
<li>positive peer pressure</li>
<li>negative peer pressure  - drug abuse , - school bullying , - youth crime</li>
</ul>
</li>
<li>feel lonely and isolated 感到孤独而且被孤立</li>
</ul>
</li>
<li><p>behaviour problems / behavioural problems 行为问题</p>
<ul>
<li><p>unruly students / disruptive students 不守纪律的学生</p>
</li>
<li><p>drop out of school 辍学</p>
<ul>
<li>Half of yound adults who dropped out of school regretted their decision later.</li>
</ul>
</li>
<li><p>are involved wih gangs and crime 参与帮派和犯罪活动</p>
</li>
</ul>
<hr>
<p>  are responsibility for their actions 对他们的行为负责</p>
<ul>
<li>have respect for their neighbours and communities 尊重他们的邻居和社区</li>
</ul>
</li>
<li><p>youth crime / juvenile delinquency 青少年犯罪</p>
<ul>
<li>lack self-control 缺乏自制力</li>
<li>do not think about the consequences of their actions (青少年)不考虑自己行为的结果</li>
<li>commit a crime / commit crimes 犯罪</li>
<li>reduce / prevent youth crime减少/预防青少年犯罪</li>
<li>become law-abiding citizens 成为守法公民</li>
<li>become useful members of society 成为有用的社会成员</li>
</ul>
</li>
<li><p>prepare them well for adult life 帮助他们成年之后的人生做好准备</p>
<ul>
<li>increase their independence 增强他们的独立性</li>
<li>develope a positive outlook on life 形成积极的人生态度</li>
<li>a responsible member of society 有责任感的社会成员</li>
<li>a productive / contributing member of society 能为社会创造有用价值/做出贡献的社会成员</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/JavaUtil/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/24/JavaUtil/" itemprop="url">
                  JavaUtil
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T09:04:16+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><h2 id="instruction"><a href="#instruction" class="headerlink" title="instruction"></a>instruction</h2><p>程序设计中一项常见的任务就是在文件集上执行操作，这些文件要么在本地目录中，要么遍布于整个目录树中。如果有一种工具能产生整个文件集，将会非常节省时间。下面的实用工具类就可以通过使用 $local()$ 方法由本地目录的文件构成的 File 对象组，或者通过 $walk()$ 方法产生给定目录下的由整个目录树中所有文件构成的 List\<file> ( File 对象比文件更有用，因为 File 包含更多的信息)。这些文件是基于你提供的正则表达式而被选中的</file></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> categoryUtil;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FilenameFilter;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.regex.Pattern;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by isaac on 2017/8/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(File dir,<span class="keyword">final</span> String regex)&#123;</div><div class="line">        <span class="keyword">return</span> dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</div><div class="line">            <span class="keyword">private</span> Pattern pattern = Pattern.compile(regex);</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> pattern.matcher(<span class="keyword">new</span> File(name).getName()).matches();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(String path,<span class="keyword">final</span> String regex)&#123;</div><div class="line">        <span class="comment">//Override</span></div><div class="line">        <span class="keyword">return</span> local(<span class="keyword">new</span> File(path),regex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//A two-tuple for returning a pair of objects:</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeInfo</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">File</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">public</span> List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;File&gt;();</div><div class="line">        <span class="keyword">public</span> List&lt;File&gt; dirs = <span class="keyword">new</span> ArrayList&lt;File&gt;();</div><div class="line"></div><div class="line">        <span class="comment">//The default iterable elements is the file list:</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;File&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> files.iterator();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(TreeInfo other)</span></span>&#123;</div><div class="line">            files.addAll(other.files);</div><div class="line">            dirs.addAll(other.dirs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"dirs : "</span> + PPrint.pformat(dirs) +</div><div class="line">                    <span class="string">"\n\n files : "</span> + PPrint.pformat(files);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String start,String regex)</span></span>&#123;</div><div class="line">        <span class="comment">//Begin recursion</span></div><div class="line">        <span class="keyword">return</span> recurseDirs(<span class="keyword">new</span> File(start),regex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start,String regex)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> recurseDirs(start,regex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start)</span></span>&#123;</div><div class="line">        <span class="comment">//Everything</span></div><div class="line">        <span class="keyword">return</span> recurseDirs(start,<span class="string">".*"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String start)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> recurseDirs(<span class="keyword">new</span> File(start),<span class="string">".*"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> TreeInfo <span class="title">recurseDirs</span><span class="params">(File startDir,String regex)</span></span>&#123;</div><div class="line">        TreeInfo result = <span class="keyword">new</span> TreeInfo();</div><div class="line">        <span class="keyword">for</span>(File item : startDir.listFiles())&#123;</div><div class="line">            <span class="keyword">if</span>(item.isDirectory())&#123;</div><div class="line">                result.dirs.add(item);</div><div class="line">                result.addAll(recurseDirs(item,regex));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(item.getName().matches(regex))&#123;</div><div class="line">                result.files.add(item);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Testify"><a href="#Testify" class="headerlink" title="Testify"></a>Testify</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(args.length==<span class="number">0</span>)</div><div class="line">    System.out.println(walk(<span class="string">"."</span>));</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">for</span>(String arg : agrs)</div><div class="line">      System.out.println(walk(arg));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Pretty-Print"><a href="#Pretty-Print" class="headerlink" title="Pretty Print"></a>Pretty Print</h1><h2 id="Instrcution"><a href="#Instrcution" class="headerlink" title="Instrcution"></a>Instrcution</h2><p>容器默认的toString方法会在单个行中打印容器中的所有元素，对于大型集合来说，这会变得难以阅读，本工具可替换其格式。添加新行并缩排所有的元素的工具</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> categoryUtil;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by isaac on 2017/8/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPrint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pformat</span><span class="params">(Collection&lt;?&gt; c)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(c.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"[]"</span>;</div><div class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer(<span class="string">" [ "</span>);</div><div class="line">        <span class="keyword">for</span>(Object elem : c)&#123;</div><div class="line">            <span class="keyword">if</span>(c.size() != <span class="number">1</span>)</div><div class="line">                result.append(<span class="string">"\n  "</span>);</div><div class="line">            result.append(elem);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(c.size()==<span class="number">1</span>)</div><div class="line">            result.append(<span class="string">"\n"</span>);</div><div class="line">        result.append(<span class="string">" ] "</span>);</div><div class="line">        <span class="keyword">return</span> result.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pprint</span><span class="params">(Collection&lt;?&gt; c)</span></span>&#123;</div><div class="line">        System.out.println(pformat(c));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pprint</span><span class="params">(Object[] c)</span></span>&#123;</div><div class="line">        System.out.println(Arrays.asList(c));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/23/HibernateStudy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/23/HibernateStudy/" itemprop="url">
                  Hibernate Study
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T15:55:58+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hibernate入门"><a href="#Hibernate入门" class="headerlink" title="Hibernate入门"></a>Hibernate入门</h1><h2 id="搭建hibernate环境"><a href="#搭建hibernate环境" class="headerlink" title="搭建hibernate环境"></a>搭建hibernate环境</h2><h4 id="第一步-导入hibernate的jar包"><a href="#第一步-导入hibernate的jar包" class="headerlink" title="第一步 导入hibernate的jar包"></a>第一步 导入hibernate的jar包</h4><ol>
<li>hibernate 文件中的required中的jar包要导入</li>
<li>jpa 中的 jar 包</li>
<li>因为使用 hibernate 时候，会有日志信息输出。hibernate 本身没有日志输出 jar 包，导入其他日志jar包</li>
<li>mysql驱动 jar 包</li>
</ol>
<h4 id="第二步-创建实体类"><a href="#第二步-创建实体类" class="headerlink" title="第二步 创建实体类"></a>第二步 创建实体类</h4><p>hibernate要求实体类中有一个属性是唯一的</p>
<h4 id="第三步-配置实体类和数据库表一一对应关系（映射关系）"><a href="#第三步-配置实体类和数据库表一一对应关系（映射关系）" class="headerlink" title="第三步  配置实体类和数据库表一一对应关系（映射关系）"></a>第三步  配置实体类和数据库表一一对应关系（映射关系）</h4><p>使用配置文件实现映射关系</p>
<ol>
<li>创建xml格式的配置文件<ul>
<li>映射配置文件和位置没有固定要求</li>
<li>建议：<strong>在实体类所在包里面创建，\<classname>.hbm.xml</classname></strong></li>
</ul>
</li>
<li>配置是xml格式，在配置文件中首先引入 xml 约束<ul>
<li>学过约束 dtd 、 schema 在hibernate 都是 dtd文件</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</div><div class="line">        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</div><div class="line">        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</div></pre></td></tr></table></figure>
<p>完整的配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></div><div class="line">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 1. 配置类和表对应</span></div><div class="line">            class 标签</div><div class="line">            name 属性： 实体类全路径</div><div class="line">            table 属性： 数据库表名称</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User.User"</span> <span class="attr">table</span>=<span class="string">"t_user"</span> &gt;</span></div><div class="line">        <span class="comment">&lt;!-- 2. 配置实体类 id 和 表 id 对应</span></div><div class="line">                hibernate 要求在实体类有一个属性唯一值</div><div class="line">                hibernate 要求表有字段作为唯一值</div><div class="line">        --&gt;</div><div class="line">        <span class="comment">&lt;!-- id 标签</span></div><div class="line">                name属性: 实体类里面id属性名称</div><div class="line">                column属性: 生成的表字段名称</div><div class="line">        --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 设置数据库表id增长策略</span></div><div class="line">                 native: 生成id值主键自动增长--&gt;</div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--配置其他的属性和表字段对应</span></div><div class="line">            name属性: 实体类属性名称</div><div class="line">            column属性: 生成表的字段名</div><div class="line">        --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>映射文件是一个以 \<hibernate-mapping> 为根元素的 XML 文件，里面包含所有 \<class> 标签</class></hibernate-mapping></li>
<li>\<class>标签是用来定义从一个 Java 类到数据库表的特定映射。Java 的类名使用 <strong>name</strong> 属性表示，数据库表名用<strong>table</strong>属性表示</class></li>
<li>\<meta> 标签是一个可选元素，被用来修饰类</li>
<li>\<id> 标签将类中的唯一属性与数据库表中主键关联。id 元素中的 <strong>name</strong> 属性引用类的性质， <strong>column</strong> 属性引用数据库表的列。 <strong>type</strong> 属性保存 hibernate 映射的类型，这个类型会将从 Java 转换成 SQL 数据类型</id></li>
<li>\<id> 标签下的\<generator> 标签用来自动生成主键值。设置 generator 标签中的 <strong>class</strong> 属性可以设置 <strong>native</strong></generator></id></li>
<li>\<property> 标签将Java 类的属性与数据库表的列匹配。标签中 <strong>name</strong> 属性引用的是类的元素，<strong>column</strong>属性引用的是数据库表的列。 <strong>type</strong> 属性保存Hibernate映射的类型，这个类型会将从Java转换为SQL数据类型</property></li>
</ul>
<h4 id="第四步-创建hibernate的核心配置文件"><a href="#第四步-创建hibernate的核心配置文件" class="headerlink" title="第四步  创建hibernate的核心配置文件"></a>第四步  创建hibernate的核心配置文件</h4><ol>
<li><p>核心配置文件格式 xml ，但是核心配置文件名称和位置式固定的</p>
<ul>
<li>位置：必须 src 下面</li>
<li>名称：必须hibernate.cfg.xml</li>
</ul>
</li>
<li><p>引入dtd约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class="line">        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</div><div class="line">        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>hibernate操作过程中，只会加载核心配置文件，其他配置文件不会进行加载</p>
</li>
</ol>
<h5 id="第一部分-配置数据库信息"><a href="#第一部分-配置数据库信息" class="headerlink" title="第一部分 配置数据库信息"></a>第一部分 配置数据库信息</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--第一部分：配置数据库信息--&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span> &gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate_day01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>YourPassword<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="第二部分-配置hibernate信息"><a href="#第二部分-配置hibernate信息" class="headerlink" title="第二部分 配置hibernate信息"></a>第二部分 配置hibernate信息</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--第二部分：配置hibernate信息 (可选的)--&gt;</span></div><div class="line">   <span class="comment">&lt;!--输出低层sql语句--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!--输出低层sql语句格式--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!--hibernate帮创建表，需要配置之后</span></div><div class="line">       update: 如果已经有表，更新，如果没有，创建</div><div class="line">   --&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 配置数据库方言，数据库中特有的设置关键字--&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.Mysql<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="第三部分-把映射文件放到核心配置文件中"><a href="#第三部分-把映射文件放到核心配置文件中" class="headerlink" title="第三部分 把映射文件放到核心配置文件中"></a>第三部分 把映射文件放到核心配置文件中</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--第三部分：把映射文件放到配置文件中--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"User/User.hbm.xml"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>注意路径中文件的位置，与当前的核心配置文件的相对路径</p>
<h2 id="实现添加操作"><a href="#实现添加操作" class="headerlink" title="实现添加操作"></a>实现添加操作</h2><h4 id="第一步-加载hibernate核心配置文件"><a href="#第一步-加载hibernate核心配置文件" class="headerlink" title="第一步 加载hibernate核心配置文件"></a>第一步 加载hibernate核心配置文件</h4><h4 id="第二步-创建SessionFactory对象"><a href="#第二步-创建SessionFactory对象" class="headerlink" title="第二步 创建SessionFactory对象"></a>第二步 创建SessionFactory对象</h4><h4 id="第三步-使用SessionFactory-创建Session对象"><a href="#第三步-使用SessionFactory-创建Session对象" class="headerlink" title="第三步 使用SessionFactory 创建Session对象"></a>第三步 使用SessionFactory 创建Session对象</h4><h4 id="第四步-开启事务"><a href="#第四步-开启事务" class="headerlink" title="第四步 开启事务"></a>第四步 开启事务</h4><h4 id="第五步-写具体逻辑-crud操作"><a href="#第五步-写具体逻辑-crud操作" class="headerlink" title="第五步 写具体逻辑 crud操作"></a>第五步 写具体逻辑 crud操作</h4><h4 id="第六步-提交事务"><a href="#第六步-提交事务" class="headerlink" title="第六步 提交事务"></a>第六步 提交事务</h4><h4 id="第七步-关闭资源"><a href="#第七步-关闭资源" class="headerlink" title="第七步 关闭资源"></a>第七步 关闭资源</h4><p>测试文件，使用单元测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hibernateTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> User.User;</div><div class="line"><span class="keyword">import</span> org.hibernate.Session;</div><div class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</div><div class="line"><span class="keyword">import</span> org.hibernate.Transaction;</div><div class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by isaac on 2017/9/3.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateDemo</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestADD</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//    第一步 加载hibernate核心配置文件</span></div><div class="line">        <span class="comment">//在src下面找到名称是hibernate.cfg.xml</span></div><div class="line">        <span class="comment">//在hibernate里面封装对象</span></div><div class="line">        Configuration cfg = <span class="keyword">new</span> Configuration();</div><div class="line">        cfg.configure();</div><div class="line"><span class="comment">//    第二步 创建SessionFactory对象</span></div><div class="line">        <span class="comment">//读取hibernate中核心配置文件内容，创建sessionFactory</span></div><div class="line">        <span class="comment">//在此过程中，根据映射关系，在配置数据库里面把表创建</span></div><div class="line">        SessionFactory sessionFactory = cfg.buildSessionFactory();</div><div class="line"><span class="comment">//    第三步 使用SessionFactory 创建Session对象</span></div><div class="line">        <span class="comment">//类似于连接</span></div><div class="line">        Session session = sessionFactory.openSession();</div><div class="line"><span class="comment">//    第四步 开启事务</span></div><div class="line">        Transaction tx = session.beginTransaction();</div><div class="line"><span class="comment">//    第五步 写具体逻辑 crud操作</span></div><div class="line">        User user = <span class="keyword">new</span> User();</div><div class="line">        user.setUsername(<span class="string">"Isaac"</span>);</div><div class="line">        user.setPassword(<span class="string">"10086"</span>);</div><div class="line">        user.setAddress(<span class="string">"China"</span>);</div><div class="line">        <span class="comment">//调用session方法实现添加</span></div><div class="line">        session.save(user);</div><div class="line"><span class="comment">//    第六步 提交事务</span></div><div class="line">        tx.commit();</div><div class="line"><span class="comment">//    第七步 关闭资源</span></div><div class="line">        session.close();</div><div class="line">        sessionFactory.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Hibernate配置文件详解"><a href="#Hibernate配置文件详解" class="headerlink" title="Hibernate配置文件详解"></a>Hibernate配置文件详解</h1><h2 id="Hibernate映射配置文件"><a href="#Hibernate映射配置文件" class="headerlink" title="Hibernate映射配置文件"></a>Hibernate映射配置文件</h2><ol>
<li>映射配置文件名称和位置没有固定要求</li>
<li>映射配置文件中，标签name属性值写实体相关内容<ul>
<li>class 标签 name 属性值实体类全路径</li>
<li>id 标签和 property 标签 name 属性值 实体属性值</li>
</ul>
</li>
<li>id 标签和 property标签，column属性可以省略<ul>
<li>不写值，column和name属性值一样</li>
</ul>
</li>
<li>property标签type属性设置生成字段类型</li>
</ol>
<h2 id="Hibernate核心配置文件"><a href="#Hibernate核心配置文件" class="headerlink" title="Hibernate核心配置文件"></a>Hibernate核心配置文件</h2><ol>
<li>配置写位置要求 ，在session-factory下</li>
<li>配置三部分要求<ul>
<li>数据库部分必须</li>
<li>hibernate部分可选的</li>
<li>映射文件必须的</li>
</ul>
</li>
<li>核心配置文件名称和位置固定的<ul>
<li>位置：src下面</li>
<li>名称：hibernate.cfg.xml</li>
</ul>
</li>
</ol>
<h1 id="Hibernate核心API"><a href="#Hibernate核心API" class="headerlink" title="Hibernate核心API"></a>Hibernate核心API</h1><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><ol>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Configuration cfg = <span class="keyword">new</span> Configuration();</div><div class="line">   cfg.configure();</div></pre></td></tr></table></figure>
</li>
<li><p>到src下面找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件放到对象里面（加载核心配置文件）</p>
</li>
</ol>
<h2 id="SessionFactory（重点）"><a href="#SessionFactory（重点）" class="headerlink" title="SessionFactory（重点）"></a>SessionFactory（重点）</h2><ol>
<li><p>使用configuration对象创建SessionFactory对象</p>
<ol>
<li><p>创建SessionFactory过程中坐的事情：</p>
<ul>
<li><p>根据核心配置文件中，有数据库配置，有文件映射部分，到数据库里面根据映射关系把表创</p>
</li>
<li><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>创建sessionFactory过程中，整个过程特别消耗资源</p>
<ol>
<li>在Hibernate操作中，建议一个项目一般创建一个SessionFactory对象</li>
</ol>
</li>
<li><p>具体实现</p>
<ol>
<li><p>写工具类，写静态代码块实现</p>
<p>静态代码块在类加载时候执行，执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration cfg = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        cfg = <span class="keyword">new</span> Configuration();</div><div class="line">        cfg.configure();</div><div class="line">        sessionFactory = cfg.buildSessionFactory();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sessionFactory;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="Session-重点"><a href="#Session-重点" class="headerlink" title="Session(重点)"></a>Session(重点)</h2><ol>
<li>Session 类似于 JDBC 中connection</li>
<li>调用session里不同的方法实现 crud 操作<ul>
<li>添加 save()</li>
<li>修改 update()</li>
<li>删除 delelte()</li>
<li>根据 id 查询 get()</li>
</ul>
</li>
<li>session对象单线程对象<ul>
<li>session对象不能共用，只能自己使用</li>
</ul>
</li>
</ol>
<h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><ol>
<li><p>事务对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Transaction tx = session.beginTransaction();</div></pre></td></tr></table></figure>
</li>
<li><p>事务提交和回滚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tx.commit();</div><div class="line">tx.rollback();</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="实体类编写规则"><a href="#实体类编写规则" class="headerlink" title="实体类编写规则"></a>实体类编写规则</h1><ol>
<li><p>实体类里面属性私有的</p>
</li>
<li><p>私有属性使用公开的 set 和 get 方法</p>
</li>
<li><p>要求实体属性有唯一值(一般使用id值)</p>
</li>
<li><p>实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类</p>
<ol>
<li>八个基本数据类型对应的包装类<ul>
<li>int - Integer</li>
<li>char - Character</li>
<li>其他的都是首字母大写 比如 double - Double</li>
</ul>
</li>
<li>比如 表示学生分数，假如 int score<ul>
<li>学生得了 0 分 ， int score = 0 ；</li>
<li>学生没参加考试 ， int score = 0；不能准确表示学生是否参加考试</li>
</ul>
</li>
</ol>
<p>解决：使用包装类就可以，Integer score = 0, 表示学生得了 0 分；Integer score = null 表示学生没有参加考试</p>
</li>
</ol>
<h1 id="主键生成规则"><a href="#主键生成规则" class="headerlink" title="主键生成规则"></a>主键生成规则</h1><h1 id="实体类crud操作"><a href="#实体类crud操作" class="headerlink" title="实体类crud操作"></a>实体类crud操作</h1><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><ol>
<li><p>调用session里面的save方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">User user = <span class="keyword">new</span> User();</div><div class="line">user.setUsername(<span class="string">"小马"</span>);</div><div class="line">user.setPassword(<span class="string">"10080"</span>);</div><div class="line">user.setAddress(<span class="string">"Panda"</span>);</div><div class="line"><span class="comment">//调用session方法实现添加</span></div><div class="line">session.save(user);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="根据id进行操作"><a href="#根据id进行操作" class="headerlink" title="根据id进行操作"></a>根据id进行操作</h3><ol>
<li><p>调用session里面的get方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一个参数：实体类的class</span></div><div class="line"><span class="comment">//第二个参数：id值</span></div><div class="line"> User user = session.get(User.class,<span class="number">1</span>);</div><div class="line"> System.out.println(user);</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line">        user0_.uid <span class="keyword">as</span> uid1_0_0_,</div><div class="line">        user0_.username <span class="keyword">as</span> username2_0_0_,</div><div class="line">        user0_.password <span class="keyword">as</span> password3_0_0_,</div><div class="line">        user0_.address <span class="keyword">as</span> address4_0_0_ </div><div class="line">    <span class="keyword">from</span></div><div class="line">        t_user user0_ </div><div class="line">    <span class="keyword">where</span></div><div class="line">        user0_.uid=?</div></pre></td></tr></table></figure>
<p>执行结果如上</p>
</li>
</ol>
<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p>首先查询，再修改值</p>
<ol>
<li>根据 id 查询，返回对象</li>
<li>根据uid修改对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据 id 查询</span></div><div class="line">User user = session.get(User.class,<span class="number">2</span>);</div><div class="line"><span class="comment">//向返回的user对象里面设置修改以后的值</span></div><div class="line">user.setUsername(<span class="string">"Utoly"</span>);</div><div class="line"><span class="comment">//调用session方法修改</span></div><div class="line"><span class="comment">//执行过程：到user对象中，找到Uid值，根据uid进行修改</span></div><div class="line">session.update(user);</div></pre></td></tr></table></figure>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>调用session里面 delete方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种 根据id查询对象</span></div><div class="line">User user = session.get(User.class,<span class="number">2</span>);</div><div class="line">session.delete(user);</div><div class="line"><span class="comment">//第二种</span></div><div class="line">User user1 = <span class="keyword">new</span> User();</div><div class="line">user1.setUid(<span class="number">1</span>);</div><div class="line">session.delete(user1);</div></pre></td></tr></table></figure>
<h1 id="实体类对象状态（概念）"><a href="#实体类对象状态（概念）" class="headerlink" title="实体类对象状态（概念）"></a>实体类对象状态（概念）</h1><ol>
<li>实体类对象有三种<ol>
<li>瞬时态：对象里面没有 id 值，对象与 session 也没有关系</li>
<li>持久态：对象里面有 id  值，对象与session 有关联</li>
<li>托管态：对象有 id 值，对象与 sessinon 没有关联</li>
</ol>
</li>
<li>演示操作实体类对象的方法<ol>
<li>saveOrUpdate 方法：实现添加、修改</li>
</ol>
</li>
</ol>
<h1 id="Hibernate的一级缓存"><a href="#Hibernate的一级缓存" class="headerlink" title="Hibernate的一级缓存"></a>Hibernate的一级缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p> 数据存到数据库里面，数据库本身是文件系统，使用流方式操作文件效率不高</p>
<ul>
<li>把数据存到内存中，不需要使用流方式，可以直接读取内存中数据</li>
<li>把数据放到内存中，提供读取效率</li>
</ul>
<h2 id="Hibernate缓存"><a href="#Hibernate缓存" class="headerlink" title="Hibernate缓存"></a>Hibernate缓存</h2><ol>
<li>hibernate框架中提供很多优化方式，hibernate的缓存就是一个优化方式</li>
<li>hibernate缓存特点：<ol>
<li>hibernate的一级缓存<ul>
<li>hibernate 的一级缓存默认打开</li>
<li>hibernate 的一级缓存使用范围，是 session 范围，从 session 创建到session关闭</li>
<li>hibernate的一级缓存中，存储数据必须 持久态数据</li>
</ul>
</li>
<li>hibernate的二级缓存<ul>
<li>目前已经不使用了，替代技术 redis </li>
<li>二级缓存默认不是打开的，需要配置</li>
<li>二级缓存使用范围，是 SessionFactory 范围</li>
</ul>
</li>
</ol>
</li>
<li>验证一级缓存存在</li>
</ol>
<h1 id="Hibernate-绑定-session"><a href="#Hibernate-绑定-session" class="headerlink" title="Hibernate 绑定 session"></a>Hibernate 绑定 session</h1><ol>
<li><p>在hibernate核心配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>调用sessionFactory里面的方法得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//提供返回与本地线程绑定的session的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sessionFactory.getCurrentSession();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Hibernate的-API-使用"><a href="#Hibernate的-API-使用" class="headerlink" title="Hibernate的 API 使用"></a>Hibernate的 API 使用</h1><h2 id="Query-对象"><a href="#Query-对象" class="headerlink" title="Query 对象"></a>Query 对象</h2><ol>
<li>使用query对象，不需要写 sql 语句，但是写 hql 语句<ul>
<li>hql: hibernate query language , hibernatenate 提供查询语句，这个hql语句与普通SQL语句很相似</li>
<li>hql 与 sql 的区别：<ul>
<li>使用 sql 操作表和表字段</li>
<li>使用 hql 操作实体类和属性</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>查询所有 hql 语句：</p>
<p>from 实体类名称</p>
</li>
<li><p>Query 对象使用</p>
<ol>
<li>创建 query 对象</li>
<li>调用 query 对象里面的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1. 创建query对象</span></div><div class="line"><span class="comment">//方法里写hql语句</span></div><div class="line">Query query = session.createQuery(<span class="string">"from User"</span>);</div><div class="line"><span class="comment">//2. 调用query对象的方法得到结果</span></div><div class="line">List&lt;User&gt; list = query.list();</div><div class="line"><span class="keyword">for</span>(User user:list)&#123;</div><div class="line">  System.out.println(user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h2 id="Criteria-对象"><a href="#Criteria-对象" class="headerlink" title="Criteria 对象"></a>Criteria 对象</h2><ol>
<li><p>这个对象查询操作，但是使用这个对象时候，不需要写语句，直接调用方法实现。</p>
</li>
<li><p>实现过程</p>
<ul>
<li>创建 criteria 对象</li>
<li>调用方法得到结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.创建criteria对象</span></div><div class="line">Criteria criteria = session.createCriteria(User.class);</div><div class="line"><span class="comment">//2.调用方法得到结果</span></div><div class="line">List&lt;User&gt; list = criteria.list();</div><div class="line"><span class="keyword">for</span>(User user : list)&#123;</div><div class="line">   System.out.println(user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h2 id="SQL-Query-对象"><a href="#SQL-Query-对象" class="headerlink" title="SQL Query 对象"></a>SQL Query 对象</h2><ol>
<li><p>使用 hibernate 时候，调用低层 sql 实现</p>
</li>
<li><p>实现过程</p>
<ul>
<li>创建对象</li>
<li>调用对象的方法得到结果</li>
<li>返回list集合每部分是数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.创建对象</span></div><div class="line">SQLQuery sqlQuery = session.createSQLQuery(<span class="string">"select * from t_user"</span>);</div><div class="line">List&lt;Object[]&gt; list = sqlQuery.list();</div><div class="line"><span class="comment">//返回每部分都是数组</span></div><div class="line"><span class="keyword">for</span>(Object[] objects:list)&#123;</div><div class="line">   System.out.println(Arrays.toString(objects));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>返回list中每部分是对象形式</li>
</ul>
</li>
</ol>
<h1 id="表与表之间关系回顾"><a href="#表与表之间关系回顾" class="headerlink" title="表与表之间关系回顾"></a>表与表之间关系回顾</h1><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><ul>
<li>分类和商品关系，一个分类里有多个商品，一个商品只有一个分类</li>
<li>客户和联系人是一对多关系<ul>
<li>客户：与公司有业务往来，百度、新浪、360…</li>
<li>联系人：</li>
</ul>
</li>
</ul>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><ul>
<li>订单和商品，一个订单里有多个商品，一个商品可以属于多个订单</li>
<li>用户和角色多对多关系<ul>
<li>用户：小王、小马、小宋</li>
<li>角色：总经理、秘书、司机、保安</li>
<li>一个用户可以有多个角色，一个角色有多个用户</li>
</ul>
</li>
</ul>
<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><h1 id="Hibernate的一对多操作（重点）"><a href="#Hibernate的一对多操作（重点）" class="headerlink" title="Hibernate的一对多操作（重点）"></a>Hibernate的一对多操作（重点）</h1><h2 id="一对多映射配置"><a href="#一对多映射配置" class="headerlink" title="一对多映射配置"></a>一对多映射配置</h2><p>以客户和联系人为例，客户是一，联系人是多</p>
<h3 id="第一步-创建实体类"><a href="#第一步-创建实体类" class="headerlink" title="第一步 创建实体类"></a>第一步 创建实体类</h3><h3 id="第二步-让两个实体类之间相互表示"><a href="#第二步-让两个实体类之间相互表示" class="headerlink" title="第二步 让两个实体类之间相互表示"></a>第二步 让两个实体类之间相互表示</h3><ol>
<li>在客户实体类里面表示多个联系人<ul>
<li>一个客户里面有多个联系人 </li>
<li>Hibernate要求使用集合表示多的数据 set</li>
</ul>
</li>
<li>在联系人实体类里面表示所属客户</li>
</ol>
<h3 id="第三步-配置映射关系"><a href="#第三步-配置映射关系" class="headerlink" title="第三步 配置映射关系"></a>第三步 配置映射关系</h3><p>在客户映射文件中，表示所有联系人</p>
<p>使用 set 标签表示所有联系人</p>
<p>set标签里面有name属性，属性值写在客户实体类里面表示联系人的 set 集合名称</p>
<h2 id="一对多级联操作"><a href="#一对多级联操作" class="headerlink" title="一对多级联操作"></a>一对多级联操作</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/12/编程训练/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/12/编程训练/" itemprop="url">
                  编程训练
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-12T18:03:13+08:00">
                2017-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h2><p>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Definition for binary tree</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> val;</div><div class="line">   TreeNode left;</div><div class="line">   TreeNode right;</div><div class="line">	TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Answer-to-the-question"><a href="#Answer-to-the-question" class="headerlink" title="Answer to the question"></a>Answer to the question</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="keyword">null</span>)<span class="keyword">return</span> run(root.right)+<span class="number">1</span>;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(root.right==<span class="keyword">null</span>)<span class="keyword">return</span> run(root.left)+<span class="number">1</span>;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">          <span class="keyword">return</span> Math.min(run(root.left), run(root.right))+<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The most important thing is that, it is a repeatitive process to calculate the depth from each child. So we find that if a node have both left and right node, we will choose a less depth. Apart from that, if the node just have right or left child node, we can choose the other one to calculate. Finally, if the node , don’t have a child, will return 0.</p>
<h1 id="逆波兰表达式运算"><a href="#逆波兰表达式运算" class="headerlink" title="逆波兰表达式运算"></a>逆波兰表达式运算</h1><h2 id="instruction"><a href="#instruction" class="headerlink" title="instruction"></a>instruction</h2><p>valuate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are+,-,*,/. Each operand may be an integer or another expression. </p>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(String []tokens)</span></span>&#123;</div><div class="line">    Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span>(String term:tokens)&#123;</div><div class="line">        <span class="keyword">switch</span> (term)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line">                numStack.push(numStack.pop()+numStack.pop());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line">                <span class="keyword">int</span> a = numStack.pop();</div><div class="line">                numStack.push(numStack.pop()-a);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line">                numStack.push(numStack.pop()*numStack.pop());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line">                <span class="keyword">int</span> b = numStack.pop();</div><div class="line">                numStack.push(numStack.pop()/b);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>: numStack.push(Integer.valueOf(term));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numStack.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Be careful of that we need to take the operator’s order into account. In Reverse Polish Notation, different order means completely different experssion. So do not use two stacks to reserve operand or operator. In Reverse Polish Notationm, it is vital that if we meet a operator, we should find two operands in stack to calculate immediately and push the result in the stack.</p>
<h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><h2 id="instruction-1"><a href="#instruction-1" class="headerlink" title="instruction"></a>instruction</h2><p>Sort a linked list in O($nlogn$) time using constant space complexity.</p>
<h2 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer"></a>Answer</h2><p>题目要求时间复杂度为O(nlogn)，可以考虑归并排序的思想</p>
<p>一般步骤：</p>
<ol>
<li>将待排序数组（链表）取中点一分为二</li>
<li>递归地对左半部分进行归并排序</li>
<li>递归地对右半部分进行归并排序</li>
<li>将两个部分合并</li>
</ol>
<h1 id="二叉树遍历方式"><a href="#二叉树遍历方式" class="headerlink" title="二叉树遍历方式"></a>二叉树遍历方式</h1><h2 id="instruction-2"><a href="#instruction-2" class="headerlink" title="instruction"></a>instruction</h2><p>Given a binary tree, return the preorder, postorder and  traversal of its nodes’ values.</p>
<h2 id="Personal-Views"><a href="#Personal-Views" class="headerlink" title="Personal Views"></a>Personal Views</h2><p>二叉树的遍历方式有三种，中序遍历、前序遍历、后序遍历。可以用访问根节点的次序来定义，并且左子节点的访问先于右子节点。即 前序遍历：根、左、右 ；中序遍历：左、根、右；后序遍历：左、右、根</p>
<h2 id="Postorder-Traversal"><a href="#Postorder-Traversal" class="headerlink" title="Postorder Traversal"></a>Postorder Traversal</h2><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><p>思路：不同的遍历方式根本上是为了按照不同的次序访问节点。因此可以使用堆栈来调整元素位置。使用两个栈，stack1存放待访问的节点，stack2存放已访问节点，最后将stack2依次弹出则得到需要顺序。不同的顺序遍历结点入栈的顺序不同。</p>
<p>postorder Traversal, 最后stack2弹栈按照 左、右、根，因此stack2中存放顺序为 根、右、左，即节点从stack1存入stack2的顺序为 根、右、左，由此：</p>
<ul>
<li>stack1t弹栈得到带访问节点node，将此节点（根节点）存入stack2</li>
<li>访问node左子节点，将此节点存入stack1</li>
<li>访问node右子节点，将此节点存入stack1</li>
<li>从stack1弹栈得到下一个待访问节点 （右 $\rightarrow$ 左）</li>
</ul>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><h2 id="Preorder-Traversal"><a href="#Preorder-Traversal" class="headerlink" title="Preorder Traversal"></a>Preorder Traversal</h2><h3 id="栈实现-1"><a href="#栈实现-1" class="headerlink" title="栈实现"></a>栈实现</h3><h3 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h3><p>存放次序为 根 、左 、右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    list.add(root.val);			<span class="comment">//先将根 存入列表</span></div><div class="line">    list.addAll(preorderTraversal(root.left));  <span class="comment">//左子节点存入列表</span></div><div class="line">    list.addAll(preorderTraversal(root.right));	<span class="comment">//右子节点存入列表</span></div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode left;</div><div class="line">    TreeNode right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x)&#123;val=x;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="TwoSum"><a href="#TwoSum" class="headerlink" title="TwoSum"></a>TwoSum</h3><h4 id="Instruction-1"><a href="#Instruction-1" class="headerlink" title="Instruction"></a>Instruction</h4><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2 ) are not zero-based.</p>
<p>You may assume that each input would have exactly on solution.</p>
<p><strong>Input</strong> : numbers = {2,7,11,15} , target = 9</p>
<p><strong>Output</strong> : index1 = 1,    index2 = 2</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Using map collection can solve this problem easily. For each pair of numbers, saving each num as a key of map, meanwhile saving index of the num as its value. Every time if we can not find the needed number , just put it in the map. So, the time we get a result is that the needed number we find is in the map.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(target-numbers[i]))&#123;</div><div class="line">                result[<span class="number">1</span>] = i + <span class="number">1</span>;</div><div class="line">                result[<span class="number">0</span>] = map.get(target - numbers[i]);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            map.put(numbers[i],i+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Note</strong> : map.put(key , value) , map.get(key) . number -&gt; key , index -&gt; value</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/12/C10T2W1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/12/C10T2W1/" itemprop="url">
                  C10T2W1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-12T14:18:33+08:00">
                2017-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Writing-task1"><a href="#Writing-task1" class="headerlink" title="Writing task1"></a>Writing task1</h1><p>The tables illustrate sales of Fairtrade*-labelled coffee and bananas in UK, Switerland , Denmark , Belgium , and Sweden in 1999 and in 2004.</p>
<p>Switerland sold  3 millions of euros in coffee  in 1999 , which is twice more than that in UK, and increased to 6 milllions euros in 2004. The sales in Denmark rose from £1.8 million in 1999 to £2 million in 2004. In 1999 Sweden had the least sales, just £0.8 million.The sale of in UK increased a lot from £1.5 million in 1999 to £20 million in 2004.</p>
<p>As for sales of Fairtrade-labelled bananas. In 1999, Switzerland sold 15 millions of euros in bananas and had a huge increase to £47 million in 2004 . Denmark sold £2 million , twice as big as that in UK, while Belgium just sold 0.6. The sales in UK and Belgium increased to £5.5 million and £4 million in 2004 respectively.</p>
<p>In conclusion, sales of coffee in UK are the biggest in 2004,  while sales of bananas in Switzerland in 2004 are the biggest too.</p>
<p>30min</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/11/C10T2W2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/11/C10T2W2/" itemprop="url">
                  C10T2W2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-11T13:54:18+08:00">
                2017-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Writing-task-2"><a href="#Writing-task-2" class="headerlink" title="Writing task 2"></a>Writing task 2</h1><p>Some people think that all university students study whatever they like. Others blieve that they should only be allowed to study subjects that will be useful in the future, such as those related to science and technology.</p>
<p>Discuss both these views and give your own opinion.</p>
<h1 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h1><h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/IELTS/C10T2W2.jpg" alt="提纲"></p>
<h2 id="Article"><a href="#Article" class="headerlink" title="Article"></a>Article</h2><p>The topic that all university students should study whatever they like or subjects which will be useful in the future is being discussed. Although each side of them have their own outlook , I suppose that all university students ought to study subjects that will be useful in the future.</p>
<p>As for subjects <del>which</del> students like ,students have various choose but these can’t work well.  Firstly, students will not completely know about all their subjects , just choosing subjects which they think they like. They may find that some kinds of subjects which they study are not same as they consider. With <del>disappointed</del> <u>disappointment</u> , they can not concentrate on the subject. Secondly, if university students study too much subjects , they  would not get good grades in each one. Students are busy with a large quantity of subjects which means heavy school work . As a result , they do not know what they have learnt. So university students should not study  no matter what they like.</p>
<p>Studying useful subjects make them more professional in the future. First , in the compus , the undergraduates who just study subjects which suit for their job have a deep understanding of the technology        . Besides, they use almost whole four years to study subjects about their job. Accumulating a great deal of experience , they could solve the problems, happening in work, easily. This kind of undergraduates meet with great favor in companys. In short , university students who just study useful subjects are more capable than others.</p>
<p>In conclusion, students studying whatever they like will not have a great achievement than students studying useful subjects. So in my opinion, university students sould study the useful subject.</p>
<p>40min</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/23/人工智能专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/23/人工智能专题复习/" itemprop="url">
                  人工智能复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T11:04:37+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="人工智能专题复习"><a href="#人工智能专题复习" class="headerlink" title="人工智能专题复习"></a>人工智能专题复习</h1><p>Made by © Isaac. Ty</p>
<p>山东大学 人工智能课程复习提纲</p>
<h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><p>直接表示、逻辑表示、产生式规则表示、语义网络表示法、框架表示法、脚本方法、过程表示</p>
<h4 id="逻辑表示法"><a href="#逻辑表示法" class="headerlink" title="逻辑表示法"></a>逻辑表示法</h4><ul>
<li>一阶谓词逻辑式谓词逻辑中最直观的一种逻辑。以谓词形式来表示动作的主体、客体，客体可以有多个。</li>
<li>谓词逻辑规范表达式：$P(x_1,x_2,x_3,…)$，P是谓词，x~i~是主体与客体</li>
<li>存在问题：谓词表示越细，推理越慢、效率越低，但表示清楚</li>
</ul>
<h4 id="产生式规则表示法"><a href="#产生式规则表示法" class="headerlink" title="产生式规则表示法"></a>产生式规则表示法</h4><ul>
<li><p>可以看成断言是一个语言变量的值或是多个语言变量间的关系的陈述句，语言变量的值或语言变量间的关系可以使一个词，不一定是数字</p>
</li>
<li><p>基本特征：</p>
<ul>
<li>数据库：存放构成产生式的基本元素，又是产生式的作用对象</li>
<li>一组规则：产生式本身</li>
<li>一个解释程序：从匹配成功的规则中选出一个加以执行</li>
</ul>
</li>
<li><p>基本结构：</p>
<ul>
<li>工作存储器(数据库)：存放当前已知的数据，包括推理过程中形成的中间结论。</li>
<li>产生式规则：每条产生式分左右两个部分，左部表示激活条件，右部表示产生结果。</li>
<li>规则解释程序：<ul>
<li>匹配器：判断规则条件是否成立</li>
<li>冲突消解器：选择可调用的规则</li>
<li>解释器：执行规则的动作。在满足结束条件时终止产生式系统</li>
</ul>
</li>
</ul>
</li>
<li><p>推理方法</p>
<p>正向、反向、双向、与或树</p>
<ul>
<li>正向：从已知事实出发，逐步推导出最后结论。</li>
</ul>
</li>
</ul>
<ul>
<li>反向：首先提出假设，然后验证这些假设的真假性，找到假设成立的所有证据或事实。</li>
<li><p>双向：既自顶向下、又自底向上作双向推理，直至某个中间界面上两方向结果相符便成功结束。</p>
</li>
<li><p>优点：</p>
<ul>
<li>模块性：规则与规则之间相互独立</li>
<li>灵活性：知识库易于增加、修改、删除</li>
<li>自然性：方便地表示专家的启发性知识与经验</li>
<li>透明性：易于保留动作所产生的变化、轨迹</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>知识库维护难</li>
<li>效率低。为了模块一致性</li>
<li>理解难。由于规则一致性彼此之间不能调用</li>
</ul>
</li>
</ul>
<h4 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h4><ul>
<li>表示形式：每一个要表达的事实用一个“结点”表示，而事实之间用“弧线”表示。即，有向图表示的三元组（结点1，弧，结点2）连接而成。</li>
<li>类属关系：类属关系是指有<strong>共同属性</strong>的不同事物间的分类关系、成员关系或实例关系<ul>
<li>常见属性：<ul>
<li>A-Kind-of  表示一个事物是另一个事物的一种类型</li>
<li>A-member-of  表示一个事物是另一个事物的成员</li>
<li>Is-a   表示一个事物是另一个事物的实例</li>
</ul>
</li>
</ul>
</li>
<li>包含关系：也称聚类关系，是指具有组织或结构特征的“部分与整体”之间的关系。（包含关系一般不具备属性的继承性）<ul>
<li>常见属性：<ul>
<li>Part-of 一个事物是另一个事物的一部分</li>
</ul>
</li>
</ul>
</li>
<li>属性关系：事物和其他属性之间的关系<ul>
<li>常见属性：<ul>
<li>Have   表示一个节点具有另一个节点所描述的属性 </li>
<li>Can  一个节点能做另一个节点的事</li>
</ul>
</li>
</ul>
</li>
<li>位置关系：不同事物在位置方面的关系<ul>
<li>常见位置关系：Located-on/-at/-under/inside/outside</li>
</ul>
</li>
<li>相近关系：不同事物在形状、内容等方面相似和接近<ul>
<li>常用相近关系：Similar-to 相似  Near-to 接近</li>
</ul>
</li>
<li>时间关系：指不同事件在其发生时间方面的先后关系<ul>
<li>常用时间关系：Before 表示一个事件在另一个事件之前发生  After 一个事件在一个事件之后发生</li>
</ul>
</li>
<li>多元逻辑关系：</li>
<li>推理方法<ul>
<li>网络匹配：结构上的匹配，包括结点和弧的匹配</li>
<li>继承推理：利用具有继承性质的语义联系建立一些并不一定显示存在于语义网络知识库中的网络结构。</li>
</ul>
</li>
<li>结论：<ul>
<li>语义网络图的好处是直观、清晰</li>
<li>缺点是表达范围有限。</li>
</ul>
</li>
<li>特点：<ul>
<li>结构性好：语义网络是一种结构化的知识表示方法，能够把事物的属性和事物间的各种语义关系显示地表示出来</li>
<li>联想性：语义网络作为人类联想记忆模型提出来，强调的就是事物之间的语义关系</li>
<li>自然性：语义网络实际上是一个带有标示的有向图，可直观的把事物的属性及事物间的语义联系表示出来，便于理解</li>
</ul>
</li>
</ul>
<h4 id="框架表示"><a href="#框架表示" class="headerlink" title="框架表示"></a>框架表示</h4><ul>
<li>定义：框架是由若干个结点和关系（统称槽）构成的网络。是语义网络更一般化形式的一种结构。同语义网络没有本质区别。</li>
<li>表示形式：框架名、槽名、侧面、值</li>
<li>推理方法：没有固定的推理机理。遵循匹配和继承的原理</li>
<li>软件开发过程中框架理论的使用<ul>
<li>人们将相同类型问题的解决途径进行抽象，抽取成一个应用框架Framework，提供一套明确机制，让开发人员很容易的扩展和控制整个Framework开发上的结构。</li>
<li>为某一特定目的实现一个基本的、可执行的架构。包含了应用程序从启动到运行的主要流程，流程中无法确定的步骤留给用户来实现。程序运行时框架系统自动调用用书实现的功能组件。系统的行为是主动的。</li>
</ul>
</li>
<li>性质：<ul>
<li>对事物进行描述。</li>
<li>通过它对一些从感官中没有直接得到的信息进行预测。</li>
<li>可以利用框架知识进行判断推理</li>
<li>可以通过来认识某一类事物</li>
<li>可以通过实例修正框架对某些事物的不完整描述</li>
</ul>
</li>
</ul>
<h4 id="脚本表示"><a href="#脚本表示" class="headerlink" title="脚本表示"></a>脚本表示</h4><ul>
<li>脚本方式式采用一个专用的框架来表示特定领域的知识</li>
<li>脚本通过元语作为槽名来代表要表示的对象的基本行为</li>
<li>有点像电影剧本</li>
</ul>
<h2 id="产生式系统"><a href="#产生式系统" class="headerlink" title="产生式系统"></a>产生式系统</h2><h3 id="产生式系统的基本组成"><a href="#产生式系统的基本组成" class="headerlink" title="产生式系统的基本组成"></a>产生式系统的基本组成</h3><h4 id="组成三要素"><a href="#组成三要素" class="headerlink" title="组成三要素(*)"></a>组成三要素(*)</h4><ol>
<li>一个综合<strong>数据库</strong>—— 存放信息</li>
<li>一组产生式<strong>规则库</strong>—— 知识</li>
<li>一个控制系统<strong>推理机</strong>—— 规则的解释或执行程序（控制策略、推理策略）</li>
</ol>
<p>产生式系统定义：把一组产生式放在一起，让它们相互配合，协同工作，一个产生式生成的结论可以供另一个产生式作为前提使用，以这种方式求得解决问题的系统叫作产生式系统。</p>
<h4 id="产生式系统的特点"><a href="#产生式系统的特点" class="headerlink" title="产生式系统的特点"></a>产生式系统的特点</h4><ul>
<li>数据驱动：从已知事实出发</li>
<li>模块化：知识的无序性</li>
<li>控制系统与问题无关</li>
<li>类似人类认识的过程：规则似乎式模拟人类如何解决问题的自然方法</li>
</ul>
<h4 id="产生式系统的类型"><a href="#产生式系统的类型" class="headerlink" title="产生式系统的类型(*)"></a>产生式系统的类型(*)</h4><ul>
<li>正向推理：从已知事实出发，通过规则库求得结论，也称自底向上或者数据驱动的方式。F规则</li>
<li>反向推理：从目标出发，反向使用规则，求得已知事实，也称自顶向下推理方式或者目标驱动方式。B规则</li>
<li>双向推理：既自顶向下又自底向上，直至达到某个终结环节两个方向的结果相符边成功结束。</li>
</ul>
<h4 id="产生式系统总结"><a href="#产生式系统总结" class="headerlink" title="产生式系统总结"></a>产生式系统总结</h4><ul>
<li>产生式系统是最简单的知识表示方法，也是应用最广泛的知识表示方法，适于表示各种启发式的经验性关联规则，领域专家无需知识工程工具就能够把自己的知识转化成IF-THEN规则</li>
<li>规则选择效率较低，控制策略不灵活，知识表示形式单一</li>
</ul>
<h3 id="产生式系统的搜索策略"><a href="#产生式系统的搜索策略" class="headerlink" title="产生式系统的搜索策略"></a>产生式系统的搜索策略</h3><h4 id="产生式系统的搜索策略-1"><a href="#产生式系统的搜索策略-1" class="headerlink" title="产生式系统的搜索策略"></a>产生式系统的搜索策略</h4><ol>
<li><strong>盲目搜索</strong>：也称为无信息搜索，即只按预定的控制策略进行搜索，在搜索过程中获得的中间信息不用来改进控制策略。</li>
<li><strong>启发式搜索</strong>：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向进行，加速问题的求解过程并找到最优解。</li>
</ol>
<h4 id="图搜索策略"><a href="#图搜索策略" class="headerlink" title="图搜索策略"></a>图搜索策略</h4><ul>
<li>回溯搜索：只保留从初始状态到当前状态的一条路径</li>
<li>图搜索：保留所有已搜索过的路径</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>节点深度： 根节点深度 = 0  ，其他节点深度 = 父节点深度 + 1</li>
<li>路径： 设一节点序列为$(n_0 ,n_1 ,……,n<em>k)$，对于i = 1,…,k，若节点$n</em>{i-1}$具有一个后继节点$n_i$，则该序列称为从$n_0$到$n_k$的路径</li>
<li>路径的耗散值： 一条路径的耗散值等于连接这条路径各节点间所有耗散值的总和。用$C(n_i,n_j)$表示从n~i~到n~j~的路径的耗散值</li>
<li>扩展一个节点： 生成出该节点所有后继节点，并给出它们之间的耗散值。$Expand(n)$。</li>
<li>辅助存储表：open表：未扩展节点表，closed表：已扩展节点表 </li>
</ul>
<h4 id="无信息图搜索过程"><a href="#无信息图搜索过程" class="headerlink" title="无信息图搜索过程"></a>无信息图搜索过程</h4><ul>
<li>深度优先搜索：<ul>
<li>栈实现</li>
<li>一般不能保证找到最优解。当深度限制不合理时，可能找不到解。可将算法改为可变深度限制。最坏的情况搜索空间等同于穷举</li>
<li>缺点：如果目标节点不在搜索所进入的分支上而该分支又是一个无穷分支，则就得不到解。</li>
<li>优点：如果目标节点恰好在搜索所进入的分支上，则可以较快地得到解</li>
</ul>
</li>
<li>宽度优先搜索：<ul>
<li>队列实现</li>
<li>当问题为单位耗散值时，且问题有解时，一定能找到最优解</li>
<li>方法与问题无关，具有通用性。</li>
<li>效率较低，属于图搜索方法</li>
<li>缺点：当目标节点距离初始节点较远时会产生许多无用的节点，搜索效率低</li>
<li>优点：只要问题有解，则总可以得到解，是完备的，而且是最短路径的解。</li>
</ul>
</li>
<li>回溯与宽度优先方法结合<ul>
<li>目的：解决宽度优先方法的空间问题和回溯方法不能找到最优解的问题</li>
<li>思想：首先个给回溯法一个比较小的深度限制，然后逐渐增加深度限制，直到找到解或遍历所有分支</li>
</ul>
</li>
</ul>
<h4 id="启发式图搜索"><a href="#启发式图搜索" class="headerlink" title="启发式图搜索"></a>启发式图搜索</h4><p>利用知识来引导搜索，达到减小搜索范围，降低问题复杂度的目的。</p>
<ol>
<li><p>启发信息的强度 </p>
<ul>
<li>强：降低搜索工作量，但可能导致找不到最优解。</li>
<li>弱：一般会使工作量降低不如强的多，极限情况下变为盲目搜索，但是可能会找到最优解</li>
</ul>
</li>
<li><p>启发信息</p>
<p>引入启发知识，在保证找到最佳解的情况下，尽可能减少搜索范围，提高搜索效率。</p>
</li>
<li><p>基本思想</p>
<p>定义启发函数$f$ ，对当前搜索状态进行评估，找出一个最有希望的节点来扩展。</p>
</li>
<li><p>A算法与A*算法定义</p>
<p>或图通常采用如下形式的<strong>估计函数</strong>时，称为A算法。</p>
<p>$f(n)=g(n)+h(n)$</p>
<p>$g(n)$表示从<strong>s到n点费用的估计</strong>，因为n为当前节点，搜索已达到n点，所以g$(n)可$</p>
<p>计算出。</p>
<p>$h(n)$表示从<strong>n到目标接近程度的估计</strong>，因为尚未找到解路径，所以$h(n)$仅仅是估计值。</p>
</li>
<li><p><strong>A算法(最好优先搜索)</strong>，适用于<strong>或图</strong>搜索。在所有待扩展结点中优先选择最有希望的结点进行扩展。在搜索过程中如果早期选择了一个错误，最好优先搜索提供了<strong>修改的机会</strong>，这是最好优先搜索算法的关键。 但是<strong>A算法并未显示地给出如何定义<u>启发函数</u>，A*算法就是对A算法的启发函数加上限制后的一种算法</strong>。</p>
</li>
</ol>
<h4 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h4><ul>
<li>$g(n)$ 从S到n的最短路径的<strong>耗散值</strong></li>
<li>$h(n)$ 从n到G的最短路径的<strong>耗散值</strong></li>
<li>$f(n)=g(n)+h(n)$ 从S经过n到G的最短路径<strong>耗散值</strong></li>
<li>$g’(n), h’(n), f’(n)$ 分别式$g(n), h(n), f(n)$的估计值</li>
</ul>
<h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>$f(n)=g(n)+h(n)$ </p>
<ol>
<li>若令$h(n)\equiv0$ ，则A算法相当于宽度优先搜索，因为上一层节点的搜索费用一般比下一层的小</li>
<li>若$g(n)\equiv 0$ ，则相当于最佳优先搜索算法</li>
<li>$g(n)\equiv h(n)\equiv0$ 相当于随机算法</li>
<li><strong>特别是当要求 $h(n) \le h’(n)$，就称为这种A算法为A* 算法</strong></li>
</ol>
<h4 id="A-算法性质"><a href="#A-算法性质" class="headerlink" title="A* 算法性质"></a>A* 算法性质</h4><p>定理1： 对有限图，如果从初始节点s到目标节点t有路径存在，则算法A一定成功</p>
<p>在A算法中，如果满足条件：</p>
<ol>
<li>g(n)是对g*(n)的估计 g(n)&gt;0 </li>
<li>h(n)≤h*(n)</li>
</ol>
<p>则A算法称为A*算法</p>
<h3 id="产生式系统-1"><a href="#产生式系统-1" class="headerlink" title="产生式系统"></a>产生式系统</h3><ul>
<li>[ ] 与或图的搜索及与或图启发式搜索算法AO*</li>
<li>[ ] 与或图搜索中的能解节点和不能解节点</li>
<li>[ ] 博弈树搜索</li>
<li>[ ] α-β剪枝的条件</li>
<li>[ ] 使用α-β剪枝规则完成博弈树搜索的剪枝</li>
</ul>
<h4 id="与或图表示问题"><a href="#与或图表示问题" class="headerlink" title="与或图表示问题"></a>与或图表示问题</h4><ul>
<li>与或图是一个超图，节点间通过连接符连接</li>
<li>K-连接符</li>
<li>$K(n,N) = C_n + k(n_1,N)+…+k(n_i,N)$</li>
<li>其中N为终结节点 ， $C_n$为连接符的耗散值</li>
</ul>
<h5 id="能解节点"><a href="#能解节点" class="headerlink" title="能解节点"></a>能解节点</h5><ul>
<li>终节点是能解节点</li>
<li>若非终节点有“或”子节点时，当前仅当至少有一能解解时，该非终节点能解</li>
<li>若非终节点有“与”子节点时，当且仅当其子节点均能解时，该非终节点才能解。</li>
</ul>
<h5 id="不能解节点"><a href="#不能解节点" class="headerlink" title="不能解节点"></a>不能解节点</h5><ul>
<li>没有后裔的非终节点式不能解节点</li>
<li>若非终节点有“或”子节点，当前仅当所有子节点均不能解，该非终节点不能解</li>
<li>若非终节点有“与”子节点，当至少有一个子节点不能解时，该非终节点才能解</li>
</ul>
<h4 id="与或图启发式搜索算法AO"><a href="#与或图启发式搜索算法AO" class="headerlink" title="与或图启发式搜索算法AO*"></a>与或图启发式搜索算法AO*</h4><ul>
<li><p>AO* 算法两个过程</p>
<ul>
<li><p>图生成过程，即扩展节点（利用起发信息进行）</p>
</li>
<li><p>计算耗散值的过程（根据与或关系）</p>
</li>
</ul>
</li>
<li><p>具有最小耗散值的解图称为最佳解图，其值也用$h^*(n)$表示</p>
</li>
</ul>
<h4 id="博弈树搜索"><a href="#博弈树搜索" class="headerlink" title="博弈树搜索"></a>博弈树搜索</h4><ul>
<li>博弈问题特点：<ul>
<li>双人对弈、轮流走步</li>
<li>信息完备，双方所得到的信息一样</li>
<li>零和，对一方有利的棋，对另一方不利，不存在对双方有利或无利的棋</li>
<li>博弈过程寻找对数必败态的过程</li>
<li>双方无法干预对方选择</li>
<li>可使用图搜索，但是效率很低</li>
</ul>
</li>
<li><p>博弈实例：</p>
<ul>
<li>下棋双方对立</li>
<li>一方为正方，MAX节点</li>
<li>另一方反方，MIN节点</li>
<li>正方反方交替走步，MAX节点MIN节点交替出现</li>
<li>图中所有终结点均表示该选手必输的情况，取胜方的目标式设法使棋局发展为结束在对方走步时的终结点上。</li>
</ul>
</li>
<li><p>博弈策略考虑问题：</p>
<ul>
<li>对MIN走后的每一个MAX结点，必须证明MAX对MIN可能走的每一个棋局对弈后能获胜，即MAX必须考虑应付MIN的所有招法。因此MAX结点可看成<strong>与结点</strong>。</li>
<li>对MAX走后的每一个MIN结点，只需证明MAX有一步能走赢就可以，即MAX只要考虑走出一步棋使MIN无法招架。因此MIN结点可看成<strong>或节点</strong>。</li>
</ul>
</li>
<li><p>极大极小搜索过程—-对各个局面进行评估</p>
<ul>
<li>评估目的：对后面的状态提前考虑，并且以各种状态的评估值为基础做出最好的选择</li>
<li>评估方法：用评价函数对棋局进行评估<ul>
<li>赢的评估值设为+∞，输的评估值设为-∞，平局的评估值设为0</li>
</ul>
</li>
<li>评估的标准：由于下棋的双方是对立的，只能选择其中一方为评估的标准方</li>
<li>由于正方和反方交替走步，因此MAX节点和MIN节点会交替出现。</li>
<li>正方（MAX节点）从所有子节点中，选取具有<strong>最大评估值的节点</strong>。</li>
<li>反方（MIN节点）从所有子节点中选取具有<strong>最小评估值的节点</strong></li>
<li>反复进行选取，可以得到双方各个节点的评估值</li>
</ul>
</li>
</ul>
<h4 id="alpha-beta-搜索过程"><a href="#alpha-beta-搜索过程" class="headerlink" title="$\alpha-\beta$搜索过程"></a>$\alpha-\beta$搜索过程</h4><p>在极小极大搜索过程中，必须求出所有终端节点的评估值，当考虑的棋步比较多时，计算量会大大增加。为提高搜索效率，引入了通过对评估值的上下限进行估计，从而减少需进行评估的节点范围的$\alpha-\beta$剪枝法</p>
<ul>
<li><p>Max节点的评估下限值 $\alpha$</p>
<p>作为正方出现的Max节点，假设它的MIN子节点有N个，那么当它的第一个MIN子节点的评估值为$\alpha$时，对于其他子节点</p>
<ul>
<li>有高过$\alpha$的，就取最高的值作为MAX节点的评估值</li>
<li>没有高估的，则该MAX的节点评估值为$\alpha$</li>
<li>总之Max节点的估计值不会低于$\alpha$，$ \alpha$称为该MAX节点的评估下限值</li>
</ul>
</li>
<li><p>MIN节点的评估上限值$\beta$</p>
<p>作为反方出现的MIN节点，假设它的MAX子节点有N个，那么当它的第一个MAX子节点的评估值为$\beta$时，对于其他子节点</p>
<ul>
<li>有低于$\beta$的，就取那个低于$\beta$的值作为该MIN节点的估计值</li>
<li>没有低于的，则该MIN节点的估计值取$\beta$</li>
<li>总之，该MIN节点的评估值不会高过$\beta$，这个$\beta$就称为该MIN节点的评估上限值</li>
</ul>
</li>
<li><p>$\alpha$剪枝法</p>
<p>设MAX节点的下限为$\alpha$，则其所有MIN子节点中，其评估值的$\beta$上限小于等于$\alpha$的节点，其以下部分的搜索都可以停止了，即对这部分进行$\alpha$剪枝。</p>
</li>
<li><p>$\beta $剪枝法</p>
<p>设MIN节点的上限为$\beta$，则其所有的MAX子节点中，其评估值的$\alpha$下限大于等于 $\beta$的节点，其以下部分的搜索都可以停止了，即对这部分进行$\beta$剪枝。</p>
</li>
<li><p>MAX节点的下界为$\alpha$，MIN节点的上界为$\beta$。则剪枝的条件为：</p>
<ul>
<li>祖先节点的$\alpha$值 $\ge$ 后辈节点的$\beta$值时，$\alpha$剪枝</li>
<li>祖先节点的$\beta$值$ \le $后辈界节点的$\alpha$值时，$\beta$剪枝</li>
</ul>
</li>
</ul>
<h2 id="经典逻辑理论"><a href="#经典逻辑理论" class="headerlink" title="经典逻辑理论"></a>经典逻辑理论</h2><h3 id="归结原理"><a href="#归结原理" class="headerlink" title="归结原理"></a>归结原理</h3><p>一种定理证明方法，从理论上解决了定理证明问题。</p>
<p>在有限步内给予判定。</p>
<h3 id="子句和子句集"><a href="#子句和子句集" class="headerlink" title="子句和子句集"></a>子句和子句集</h3><p>子句：</p>
<ul>
<li>无量词约束</li>
<li>元素只是文字的析取</li>
<li>否定符只作用于单个文字</li>
<li>元素间默认为合取</li>
</ul>
<p>子句集：合取范式形式下的子命题（元素）的集合</p>
<p>文字：不含任何连接词的谓词公式</p>
<p>子句：一些文字的析取（谓词的和）</p>
<p>子句集求取： G ——&gt;SKOLEM范式 ——&gt;消去存在变量——&gt;以 ， 取代 </p>
<h3 id="公式G和由公式求取的子句集的关系"><a href="#公式G和由公式求取的子句集的关系" class="headerlink" title="公式G和由公式求取的子句集的关系"></a>公式G和由公式求取的子句集的关系</h3><p>G是不可满足的 $\equiv$ S是不可满足的。即G与S不等价，但在不可满足意义下一致</p>
<h3 id="归结的一般过程"><a href="#归结的一般过程" class="headerlink" title="归结的一般过程"></a>归结的一般过程</h3><ul>
<li>将命题写成合取范式</li>
<li>求出子句集</li>
<li>对子句集使用归结推理规则</li>
<li>归结式作为新子句参加归结</li>
<li>归结式为空，s不可满足的（矛盾），原命题成立</li>
</ul>
<h3 id="置换-合一，最一般合一者"><a href="#置换-合一，最一般合一者" class="headerlink" title="置换/合一，最一般合一者"></a>置换/合一，最一般合一者</h3><p>置换：在一个谓词公式中用置换项去置换变量，形如${t_1/x_1,t_2/x_2,…,t_n/x_n}$的有限集合。其中$x_i$是变量，$t$是不同于$x_i$的项；$t_i/x_i$表示用$t_i$置换$x_i$，并且要求$t_i$与$x_i$不相同，而且$x_i$不能循环出现在另一个t中</p>
<p>合一：寻找相对变量的置换，使两个谓词公式一致。设有公式集$F={F_1,F_2,…,F_n}$，若存在一个置换$\theta$，可使$F_1\theta = F_2\theta=…=F_n\theta$，则称$\theta$是F的一个合一。一个公式集的合一不唯一</p>
<h3 id="Skolem标准型（斯克林范式）"><a href="#Skolem标准型（斯克林范式）" class="headerlink" title="Skolem标准型（斯克林范式）"></a>Skolem标准型（斯克林范式）</h3><ul>
<li>前束范式：公式A是一个前束范式，如果A中的一切量词都位于该公式的最左边（不含否定词），且这些量词的辖域都延伸到公式末端。</li>
<li>把所有的量词都提到前面去，然后消掉所有量词<ul>
<li>原则：消去存在量词，略去全称量词</li>
<li>左边有全称量词的存在量词，消去时应该改写成为全称量词的函数；如没有则改写成常量。</li>
</ul>
</li>
<li>SKOLEM定理：谓词逻辑的任意公式都可以化为与之等价的前束范式，但是前束范式不唯一</li>
<li>SKOLEM标准形：消去量词后的谓词公式</li>
</ul>
<h3 id="用归结法证明问题"><a href="#用归结法证明问题" class="headerlink" title="用归结法证明问题(*)"></a>用归结法证明问题(*)</h3><h3 id="归结过程的控制策略及策略的完备性"><a href="#归结过程的控制策略及策略的完备性" class="headerlink" title="归结过程的控制策略及策略的完备性"></a>归结过程的控制策略及策略的完备性</h3><ul>
<li>解决问题：归结方法的知识爆炸</li>
<li>控制策略的目的：归结点尽量少</li>
<li>控制策略的原则：给出控制策略，以使仅对选择合适的子句间方可做归结，避免多余的、不必要的归结式出现。或者说，少做些归结仍能导出空子句。</li>
<li>采用支撑集 </li>
<li>线性归结：线性归结策略首先从子句集中选取一个称作顶子句的子句C0开始作归结。归结过程中所得到的归结式Ci立即同另一子句B_i进行归结得归结式Ci+1</li>
<li>单元归结：单元归结策略要求在归结过程中，每次归结都有一个子句是单元子句（只含一个文字的子句）或单元因子。显而易见，此方法可以简单地削去另一个非单子句中的一个因子，使其长度减少，构成简单化，归结效率较高。</li>
<li>输入归结</li>
</ul>
<h2 id="不确定性推理模型"><a href="#不确定性推理模型" class="headerlink" title="不确定性推理模型"></a>不确定性推理模型</h2><h3 id="Bayes贝叶斯网"><a href="#Bayes贝叶斯网" class="headerlink" title="Bayes贝叶斯网"></a>Bayes贝叶斯网</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>一系列变量的联合概率分布的图形表示；一个表示变量之间的相互依赖关系的数据结构；图论与概率论的完美结合</li>
<li>贝叶斯网就是一个在弧的连接关系上加入连接强度的因果关系网络。是一种变形的语义网络（特殊的有向无环图）DAG+CPT</li>
</ul>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>两个部分：DAG+CPT<ul>
<li>贝叶斯网络结构图，这是一个<strong>有向无环图</strong>（DAG:Directed Acyclic Graph），其中图中的每个节点代表相应的变量。当有向弧由节点A指向节点B时，则称：A是B的父节点；B是A的子节点。</li>
<li>节点和节点之间的<strong>条件概率表</strong>（Conditional Probability Table, CPT），也就是一系列的概率值，表示了局部条件概率分布。P(node|parents) 。</li>
</ul>
</li>
<li>目的：由证据得出原因发生的概率。即观察到P(Y)，求P(X|Y)</li>
</ul>
<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><ul>
<li><p>有向非循环图是各个节点变量关系传递的合理表达形式。</p>
</li>
<li><p>条件概率的引入使得计算较之全连接网络有了大大的简化。</p>
</li>
<li><p>CPT表(条件概率表)相对比较容易得到，有时可以用某种概率分布表示，需要做的只是计算表示的参数。</p>
</li>
<li><p>简单联合概率可以直接从网络关系上得到</p>
<ul>
<li><p>$P(X,Y)=P(X)P(Y|X)$</p>
</li>
<li><p>$P(X,Y,Z)=P(X)P(Y)P(Z|X,Y)$</p>
</li>
<li><p>例图中的联合概率密度为：$P(S,C,L,E)=P(E|S,C,L)<em>P(L|S,C)</em>P(C|S)*P(S)$</p>
</li>
<li><p>E与L在S条件下独立，所以$P(E|S,C,L)＝P(E|S,C) $</p>
<p>L与C在S, E条件下独立，所以$P(L|S,C)=P(L|S) $       </p>
<p>C与S在E条件下独立，所以$P(C|S)=P(C)$</p>
</li>
</ul>
</li>
</ul>
<h4 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h4><ul>
<li><p>独立</p>
<ul>
<li><p>$P(X,Y) = P(X)P(Y)$</p>
</li>
<li><p>$P(X|Y)= P(X)$</p>
<p>$P(Y|X)= P(Y)$</p>
</li>
</ul>
</li>
<li><p>对于X,Y,E：X与Y在给定E的条件下独立</p>
<ul>
<li><p>$P(X|Y,E)= P(X|E)$</p>
</li>
<li><p>$  P(Y|X,E)= P(Y|E)   $  </p>
<p>例如$P(E|L,S)=P(E|S),P(L|E,S)=P(L|E)$</p>
</li>
</ul>
</li>
<li><p>多个变量组：d分离(d-separate)</p>
<ul>
<li><p>$P(X_1,X_2,…,X_n|Y_1,Y_2,…,Y_m,E_1,E_2,…,E_p) =P(X_1,X_2,…,X_n|E_1,E_2,…,E_p) $</p>
</li>
<li><p>如果一组节点$X$在给定$E$的条件下，从$X_i$到$Y_j$的每一条通路都被$E_k$  d分离，则称X独立于另一组节点Y</p>
</li>
<li><p>D分离是一种寻找条件独立的有效方法</p>
</li>
<li><p>D分离-串行Linear连接</p>
<p>$X \rightarrow Z\rightarrow Y$ 串行事件中，事件X通过事件Z影响事件Y，反之事件Y也是通过事件Z影响事件X。但是如果原因证据Z是给定的，那么通道就被阻塞，X和Y就是独立的了。 $X,Y$被节点$Z$ D分离</p>
</li>
<li><p>D分离-分叉Diverging连接</p>
<p>如果父节点Z是已知的，没有更多的信息能够通过Z影响到所有子节点。同理父节点Z是已知时，子节点$X,…,N$是相互独立的。称子节点$ X,…,N$是被$Z$节点D分离的</p>
</li>
<li><p>D分离-汇集Converging连接</p>
<p>如果不从父节点得到推断，子节点Z就一无所知，那么，父节点是相互独立的，它们之间没有相互影响。</p>
<p>但是如果某事件影响了Z，那么，各个父节点就不是相互独立的了。该事件可以直接影响Z，也可以通过它的后代节点影响Z。这种现象称作条件依存。总之，如果子节点有了变化，或子节点的后代节点发生变化，信息是可以通过汇集连接传播的。</p>
<p>E能D分离S和C</p>
</li>
</ul>
</li>
</ul>
<h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><ul>
<li>因果推理是从起因到效果。 主要操作：按照给定证据的V和它的所有双亲的联合概率，重新表达给定证据的寻问结点的所求条件概率。</li>
<li>诊断推理是从效果到起因。 主要思想：利用贝叶斯规则将诊断推理转化为因果推理</li>
<li>辩解推理：因果推理与诊断推理结合使用。推理使用嵌入在一个诊断推理中的因果推理。</li>
</ul>
<ul>
<li>计算结果的语义解释（*）</li>
</ul>
<h3 id="主观Bayes贝叶斯网"><a href="#主观Bayes贝叶斯网" class="headerlink" title="主观Bayes贝叶斯网"></a>主观Bayes贝叶斯网</h3><h4 id="主观Bayes："><a href="#主观Bayes：" class="headerlink" title="主观Bayes："></a>主观Bayes：</h4><ul>
<li>贝叶斯规则 $P(B|A)=\frac{P(A|B)P(B)}{P(A)}$</li>
<li>思路：先定好怎么办，再凑公式</li>
<li>LS：充分似然率  $LS = \frac{O(B|A)}{O(B)}=\frac{P(A|B)}{P(A|-B)}$，A为真时对B的影响</li>
<li>LN：必要似然率 $LN = \frac{O(B|-A)}{O(B)}=\frac{P(-A|B)}{P(-A|-B)}$，A为假时对B的影响</li>
</ul>
<h4 id="几率函数O-x-：-O-x-frac-P-x-1-P-x"><a href="#几率函数O-x-：-O-x-frac-P-x-1-P-x" class="headerlink" title="几率函数O(x) ：$O(x)=\frac{P(x)}{1-P(x)}$"></a>几率函数O(x) ：$O(x)=\frac{P(x)}{1-P(x)}$</h4><ul>
<li>P(x)=0，O(x)=0 假；逻辑不发生</li>
<li>P(x)=0.5，O(x)=1 可能发生/不发生</li>
<li>P(x)=1，O(x)=∞ 真；逻辑发生</li>
<li>$O(B|A)=LS*O(B)$</li>
<li>$O(B|-A) =LN*O(B)$</li>
</ul>
<h4 id="取值规则"><a href="#取值规则" class="headerlink" title="取值规则"></a>取值规则</h4><ul>
<li>LS , LN ≥ 0，不独立。都在[0,∞)</li>
<li>LS , LN 不能同时&gt;1 或 &lt;1 。（证明）</li>
<li>LS , LN 可同时 = 1</li>
</ul>
<h4 id="计算A1-A2必然发生时，求结论B1的更新值"><a href="#计算A1-A2必然发生时，求结论B1的更新值" class="headerlink" title="计算A1,A2必然发生时，求结论B1的更新值"></a>计算A1,A2必然发生时，求结论B1的更新值</h4><ul>
<li>A 必然出现时 P(A)=1:<ul>
<li>$O(B)=\frac{P(B)}{1-P(B)}$</li>
<li>$O(B|A) =LS*O(B)$</li>
<li>$O(B|-A) =LN*O(B)$</li>
<li>$P(A)=\frac{O(A)}{1+O(A)}$</li>
</ul>
</li>
</ul>
<h3 id="确定性方法-CF模型"><a href="#确定性方法-CF模型" class="headerlink" title="确定性方法-CF模型"></a>确定性方法-CF模型</h3><h4 id="规则A-—B，可信度表示为CF-B-A-："><a href="#规则A-—B，可信度表示为CF-B-A-：" class="headerlink" title="规则A —B，可信度表示为CF(B,A)："></a>规则A —B，可信度表示为CF(B,A)：</h4><ul>
<li>$CF(B,A)=MB(B,A)-MD(B,A)$</li>
<li>CF是由证据A得到的假设B的确定性因子</li>
<li>MB是证据A得到假设B的<strong>信任增加度量</strong></li>
<li>MD是证据A得到的假设B的<strong>不信任增加度量</strong></li>
<li>确定性因子把信任与不信任组合在了一起</li>
</ul>
<h4 id="MB和MD表达式（-）"><a href="#MB和MD表达式（-）" class="headerlink" title="MB和MD表达式（*）"></a>MB和MD表达式（*）</h4><p>$$ \begin{equation}MB(B,A)=\begin{cases} 1 &amp;\mbox P(B)=1 \ \frac {max{P(B|A),P(B)}-P(B)}{1-P(B)} &amp;\mbox 其它\end{cases}\end{equation}$$</p>
<p>$$\begin{equation}MD(B,A)=\begin{cases}1 &amp;\mbox P(B)=0 \\ \frac{min{P(B|A),P(B)}-P(B)}{-P(B)} &amp;\mbox 其它\end{cases}\end{equation}$$</p>
<h4 id="CF-B-A-表达式-（-）"><a href="#CF-B-A-表达式-（-）" class="headerlink" title="CF(B,A)表达式  （*）"></a>CF(B,A)表达式  （*）</h4><p>$$\begin{equation}CF(B,A)=\begin{cases}\frac{P(B|A)-P(B)}{1-P(B)} &amp;\mbox P(B|A) \ge P(B) \ \frac{P(B|A)-P(B)}{P(B)} &amp;\mbox  P(B|A) &lt; P(B)\end{cases}\end{equation}$$</p>
<h4 id="CF-B-A-表示的意义"><a href="#CF-B-A-表示的意义" class="headerlink" title="CF(B,A)表示的意义"></a>CF(B,A)表示的意义</h4><ul>
<li>证据为真时，相对于P(~B)=1-P(B)来说，A对B为真的支持程度。即A发生更 支持B发生</li>
<li>相对于P(B)来说，A对B为真的不支持程度。即A发生不支持B发生</li>
<li>$-1 \le CF(B,A) \le 1$</li>
</ul>
<h4 id="CF的特殊值"><a href="#CF的特殊值" class="headerlink" title="CF的特殊值"></a>CF的特殊值</h4><ul>
<li>CF(B,A) = 1 前提真，结论必真 P(B|A)=1</li>
<li>CF(B,A) = -1前提真，结论必假 P(B|A)=0</li>
<li>CF(B,A) = 0 前提真假与结论无关  P(B|A) = P(B)</li>
<li>实际中CF(B,A)由专家确定，并非由P(B|A),P(B)计算得到</li>
</ul>
<h4 id="证据A的可信度表示为CF-A"><a href="#证据A的可信度表示为CF-A" class="headerlink" title="证据A的可信度表示为CF(A)"></a>证据A的可信度表示为CF(A)</h4><ul>
<li>特殊值<ul>
<li>CF(A)=1  前提肯定真</li>
<li>CF(A)=-1 前提肯定假</li>
<li>CF(A)=0  对前提一无所知</li>
<li>CF(A)&gt;0 , 表示A以CF(A)程度为真</li>
<li>CF(A)&lt;0 , 表示A以CF(A)程度为假</li>
</ul>
</li>
</ul>
<h4 id="确定性方法-CF模型计算"><a href="#确定性方法-CF模型计算" class="headerlink" title="确定性方法-CF模型计算"></a>确定性方法-CF模型计算</h4><ul>
<li>规则推理计算</li>
<li>规则合成计算</li>
<li>简单的推理计算<ul>
<li>规则推理计算 1，2，（3，4）</li>
<li>是否必然发生，都乘概率，只是必然概率为1</li>
</ul>
</li>
<li>$$</li>
</ul>
<h3 id="证据理论（DS）"><a href="#证据理论（DS）" class="headerlink" title="证据理论（DS）"></a>证据理论（DS）</h3><ul>
<li>基本概率分配函数m(x)：<ul>
<li>$m(x): 2^U \rightarrow [0,1]$，在U的幂集上定义，取值[0,1]</li>
<li>m(A)表示了证据对U的子集A成立的一种信任度</li>
<li>A属于U，且不等于U，表示对A的精确信任度</li>
<li>A等于U，表示这个数不知如何分配</li>
</ul>
</li>
<li>信任函数Bel(A)：集合和他的子集合的信任总和</li>
<li>似然函数</li>
</ul>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="机器学习可以分为几类"><a href="#机器学习可以分为几类" class="headerlink" title="机器学习可以分为几类"></a>机器学习可以分为几类</h3><p>常见的机器学习方法可分为 连接学习、归纳学习、分析学习和遗传算法与强化学习等</p>
<h3 id="机器学习系统"><a href="#机器学习系统" class="headerlink" title="机器学习系统"></a>机器学习系统</h3><p>应有环境、知识库、学习环节和执行环节四个基本部分组成</p>
<h3 id="实例学习及实例学习的两个空间模型"><a href="#实例学习及实例学习的两个空间模型" class="headerlink" title="实例学习及实例学习的两个空间模型"></a>实例学习及实例学习的两个空间模型</h3><ol>
<li>例子空间(实例)—&gt;解释例子(泛化)—&gt;规则空间(概念)—&gt;选择例子(例化)</li>
<li>例子空间的描述语言可以描述所有例子；规则空间的描述语言可以描述所有规则</li>
<li>例子空间<ul>
<li>示教例子的质量: 不能有错，同时提供正例和反例，逐步分批由选择地送入。</li>
<li>选择的条件：最有力地划分规则空间；证实肯定假设规则的集合；否定假设规则的集合。</li>
</ul>
</li>
<li>解释例子(泛化)<ul>
<li>解释例子的目的是从例子中提出用于搜索空间的信息。把示教例子变换成易于进行符号归纳的形式（有时很难）</li>
</ul>
</li>
<li>规则空间(最根本，真正学习的部分)<ul>
<li>定义：一套符号来规定表示规则的算符、术语，所有的描述都在其中。</li>
<li>归纳方法：从一般到特殊</li>
<li>对规则空间的要求：<ul>
<li>规则空间表达能力与规则空间搜索难度</li>
<li>表示和例子的一致</li>
<li>引入新术语（规则空间）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="归纳学习及学习的偏置：变形空间与候选消除学习"><a href="#归纳学习及学习的偏置：变形空间与候选消除学习" class="headerlink" title="归纳学习及学习的偏置：变形空间与候选消除学习"></a>归纳学习及学习的偏置：变形空间与候选消除学习</h3><h4 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h4><ol>
<li>实例学习：从特殊的训练样例中得到的普遍规律</li>
<li>归纳：保证输出的假设能与训练样例相拟合</li>
<li>归纳假设的一个基本假定（偏置）：对于未见实例最好的假设就是与训练数据最佳拟合的假设</li>
<li>归纳学习假设：任一假设如果在足够大的训练样例样例集中很好地逼近目标函数，它也能在未见实例中很好地逼近目标函数</li>
</ol>
<h4 id="假设从一般到特殊的转化"><a href="#假设从一般到特殊的转化" class="headerlink" title="假设从一般到特殊的转化"></a>假设从一般到特殊的转化</h4><p>任何被较特殊的假设划分为正例的实例都会被较一般的实例划分为正例</p>
<h4 id="Find-S算法：寻找极大特殊假设"><a href="#Find-S算法：寻找极大特殊假设" class="headerlink" title="Find-S算法：寻找极大特殊假设"></a>Find-S算法：寻找极大特殊假设</h4><p>使用more_general_than偏序的搜索算法，从H中最特殊假设（最小假设）开始，然后在假设覆盖正例失败时将其一般化</p>
<p>Find-S算法</p>
<ol>
<li>将h初始化H中最特殊假设</li>
<li>对每个正例x<ul>
<li>对h的每个属性约束$a_i$，如果x满足$a_i$，那么不做任何处理</li>
<li>否则将h中$a_i$替换为x满足的另一个更一般约束</li>
</ul>
</li>
<li>输出假设h</li>
</ol>
<p>Find-S算法重要特点：对以属性约束的合取式描述的假设空间H，保证输出为H中与正例一致的最特殊的假设</p>
<h4 id="变形空间和候选消除算法"><a href="#变形空间和候选消除算法" class="headerlink" title="变形空间和候选消除算法"></a>变形空间和候选消除算法</h4><p>候选消除算法输出与训练样例一致的<strong>所有假设的集合</strong>；在描述这一集合时不需要明确列举所有成员；可用于启发式搜索控制规则来表示，容错性能差。</p>
<ol>
<li><p>一致的定义：一个假设h与训练样例集合D一致，当且仅当对D中每一个样例$<x,c(x)>$都有h(x)=c(x)</x,c(x)></p>
</li>
<li><p>先列表后消除法</p>
<p>能表示变型空间的一种方法是列出其所有成员</p>
<ul>
<li>优点：保证得到所有与训练数据一致的假设</li>
<li>缺点：非常繁琐地列出H中的所有假设，大多数实际的假设空间无法做到。</li>
</ul>
</li>
<li><p>变型空间的更简洁表示</p>
<p>变型空间被表示为它的极大一般g和极大特殊s的成员，这些成员形成了一般和特殊边界的集合，这些边界在整个偏序结构中划分出变型空间。</p>
<p>变型空间方法的初始G集是最上面的一个点（最一般的概念），初始S集是最下面的直线上的点（训练正例），初始H集是整个规则空间。</p>
<p>在搜索过程中，G 集逐步下移（进行特例化），S 集逐步上移（进行泛化），H 逐步缩小。最后H收敛为满足要求的概念。</p>
<p>搜索：使用一个可能合理的假设规则的集合H，H是规则空间的子集，是规则空间中间的一段。</p>
<p>H中最一般的元素组成的子集称为G集合，最特殊的元素组成的子集称为S集合。（H是上界G和下界S之间的一段。）</p>
<p>学习基本思想：尽可能合理的进行特殊化和一般化处理，通过搜索减小H，找到一个假设规则。</p>
<p>具体方法：消除候选元素法</p>
</li>
<li><p>形式化定义</p>
<ul>
<li>极大一般：更一般中的极大者(元)-下确界</li>
<li>极大特殊:更特殊中的极小者(元)-上确界</li>
<li>关于假设空间H和训练数据D的一般边界G，是在H中与D相一致的<strong>极大一般</strong>成员的集合</li>
<li>关于假设空间H和训练数据D的特殊边界S，是在H中与D相一致的<strong>极大特殊</strong>成员的集合</li>
</ul>
</li>
<li><p>候选消除算法</p>
<p>将G集合初始化为H中极大一般假设$G0={&lt;\emptyset,\emptyset,\emptyset,\emptyset,\emptyset,\emptyset,\emptyset&gt;}$</p>
<p>将S集合初始化为H中极大特殊假设$S0={&lt;?,?,?,?,?,?,?&gt;}$</p>
<ul>
<li><p>初始化G和S</p>
</li>
<li><p>如果d是一个<strong>正例</strong></p>
<p>从G中移去所有与d不一致的假设</p>
<p>对S中每个与d不一致的假设s，从S中移出s，把s的所有的极小一般（泛化）式h加入到S中，其中h满足h与d一致，而且G的某个成员比h更一般</p>
</li>
<li><p>如果d是一个<strong>反例</strong></p>
<p>从S中移去所有与d不一致的假设</p>
<p>对G中每个与d不一致的假设g，从G中移出g，把g的所有的极小特殊（例化）式h加入到G中，其中h满足h与d一致，而且S的某个成员比h更特殊</p>
</li>
</ul>
<p>正例去掉G中不符合的概念，然后修改S，归纳出最特殊的结果，尽量少改S</p>
<p>反例去掉S中符合的概念，然后修改G，做特殊化得到最一般的结构，尽量少改G</p>
</li>
<li><p>变型空间法的优缺点</p>
<ul>
<li>搜索空间太大，有可能引起计算爆炸问题（规则总地来说是越扩越多）</li>
<li>抗干扰性差，所有数据驱动方法的通病。解决方法：例子一组一组地给。</li>
<li>采用析取规则，即此算法不可能发现“或”的关系。 </li>
</ul>
</li>
<li><p>归纳偏置</p>
<p>归纳学习需要的预先假定，称为归纳偏置</p>
<ul>
<li><p>一个有偏的假设空间</p>
<p>在EnjoySport例子中，假设³空间限制为只包含属性值的合取（肯定有偏）</p>
<p>因为这一限制，导致假设空间不能够表示简单一些的析取形式的目标概念。</p>
</li>
<li><p>无偏的学习器</p>
<p>为了保证目标概念在假设空间中，需要提供一个假设空间，它能表达所有的可教授概念。换言之，它能表达实例集X的所有子集。</p>
</li>
<li><p>EnjoySport的无偏形式</p>
<p>带来的问题：概念学习算法无法从训练样例中泛化。</p>
<p>要想获得单个目标概念，就必须提供X中所有实例作为训练样例</p>
</li>
<li><p>无偏学习的无用性</p>
<p>归纳学习的一个基本属性：学习器如果不对目标概念的形式做预先的假定，它从根本上无法对未见实例进行分类</p>
</li>
</ul>
</li>
</ol>
<h3 id="基于解释的学习"><a href="#基于解释的学习" class="headerlink" title="基于解释的学习(*)"></a>基于解释的学习(*)</h3><p>基于解释的学习，不考虑很多实例，采用演绎推理，少用归纳。可以克服归纳学习的不可靠问题。</p>
<p>基本思想：利用单个问题的求解例子，依据领域知识对实例进行详细分析，构造求解过程的因果关系的解释结构，并获取控制知识，然后对解释进行推广得到一般性描述，以便用于指导以后求解类似问题。</p>
<p>从本质上是属于演绎学习。</p>
<p>解释的过程是为获得相似问题的解决方法（概念）</p>
<h3 id="决策树学习方法，神经网络学习方法-不要求计算"><a href="#决策树学习方法，神经网络学习方法-不要求计算" class="headerlink" title="决策树学习方法，神经网络学习方法(不要求计算)"></a>决策树学习方法，神经网络学习方法(不要求计算)</h3><h4 id="决策树-Decision-Tree"><a href="#决策树-Decision-Tree" class="headerlink" title="决策树(Decision Tree)"></a>决策树(Decision Tree)</h4><p>一种描述<u><strong>概念空间</strong></u>的有效的归纳推理办法。基于决策树的学习方法可以进行不相关的多概念学习，具有简单快捷的优势，已经在各个领域取得广泛应用。</p>
<ol>
<li><p>基本思想</p>
<p>以信息熵为度量标准，构造一棵熵值下降最快的树，到叶子节点处的熵值为零，此时每个叶节点中的示例都属于同一类。</p>
</li>
<li><p>基本概念</p>
<p>决策树学习采用的是自顶向下的递归方法</p>
<p>决策树的每一层节点依照某一属性值向下分为子节点，待分类的实例在每一节点处与该节点相关的属性值进行比较，根据不同的比较结果朝相应的子节点扩展，这一过程在到达决策树的叶节点时结束，此时得到结论。</p>
<p>从根节点到叶节点的每一条路经都对应着一条合理的规则，规则间各个部分（各个层的条件）的关系是合取关系。整个决策树就对应着一组析取的规则。</p>
<p><u><strong>决策树学习算法的最大优点是，它可以自学习。</strong></u>在学习的过程中，不需要使用者了解过多背景知识，只需要对训练例子进行较好的标注，就能够进行学习。如果在应用中发现不符合规则的实例，程序会询问用户该实例的正确分类，从而生成新的分枝和叶子，并添加到树中。</p>
<p>树是由<u><strong>节点</strong></u>和<strong><u>分枝</u></strong>组成的层次数据结构。<strong>节点</strong>用于存贮信息或知识，<strong>分枝</strong>用于连接各个节点。树是图的一个特例，图是更一般的数学结构，如贝叶斯网络。</p>
<p>决策树是<u><strong>描述分类过程的一种数据结构</strong></u>，从上端的根节点开始，各种分类原则被引用进来，并依这些分类原则将根节点的数据集划分为子集，这一划分过程直到某种约束条件满足而结束</p>
</li>
</ol>
<ul>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%86%B3%E7%AD%96%E6%A0%91.png" alt="决策树图"></p>
<p>可以看到，一个决策树的内部结点包含学习的实例，每层分枝代表了实例的一个属性的可能取值，叶节点是最终划分成的类。如果判定是二元的，那么构造的将是一棵二叉树，在树中每回答一个问题就降到树的下一层。</p>
<p>判定结构可以机械的转变成产生式规则。可以通过对结构进行广度优先搜索，并在每个节点生成“IF…THEN”规则来实现。如图的决策树可以转换成下规则：</p>
<pre><code>IF “个子大”THEN

       IF “脖子短”THEN 

                 IF “鼻子长”  THEN可能是大象
</code></pre></li>
</ul>
<ol>
<li><p>构造决策树(四个问题)</p>
<ul>
<li><p><strong>收集待分类的数据</strong>，这些数据的所有属性应该是完全标注的。</p>
</li>
<li><p><strong>设计分类原则</strong>，即数据的哪些属性可以被用来分类，以及如何将该属性量化。</p>
</li>
<li><p><strong>分类原则的选择</strong>，即在众多分类准则中，每一步选择哪一准则使最终的树更令人满意。</p>
</li>
<li><p><strong>设计分类停止条件</strong>，实际应用中数据的属性很多，真正有分类意义的属性往往是有限几个，因此在必要的时候应该停止数据集分裂：例如</p>
<p>该节点包含的数据太少不足以分裂</p>
<p>继续分裂数据集对树生成的目标(例如ID3中的熵下降准则)没有贡献</p>
<p>树的深度过大不宜再分。</p>
</li>
</ul>
</li>
<li><p>决策树性质</p>
<ul>
<li>证据由属性值对表示</li>
<li>目标函数有离散输出值</li>
<li>需要不相关的描述</li>
<li>容忍训练数据的错误</li>
</ul>
</li>
</ol>
<h4 id="人工神经网络-ANNs"><a href="#人工神经网络-ANNs" class="headerlink" title="人工神经网络(ANNs)"></a>人工神经网络(ANNs)</h4><ol>
<li><p>概述</p>
</li>
<li><p>神经网络表示-<strong><u>非图形符号表示</u></strong></p>
<ul>
<li><p>决策树是一种图形符号表示</p>
<p>– 能表示<strong><u>与或规则</u></strong></p>
<p>– 形象直观地<strong><u>图形符号</u></strong></p>
</li>
<li><p>ANNs非图形符号表示法</p>
<p>– 一种<strong><u>函数表示法</u></strong>；</p>
<p>– 从大量的数据中<strong><u>抽取规则函数</u></strong>（或者根本无法表示的识别能力)</p>
</li>
</ul>
</li>
<li><p>ANN表示的信息</p>
<p>所学的概念是一种非精确表示</p>
</li>
<li><p>ANN的学习</p>
<ul>
<li>提供的训练阳历应是数字信息，且有明确的概念</li>
<li>ANN训练完毕后用于区分其他信息</li>
<li>ANN解决问题的步骤：<ol>
<li>选择确定<strong><u>网络结构</u></strong>：输入层、输出层、隐含层的结点数码以及连接权重</li>
<li>选择<strong><u>学习算法</u></strong></li>
<li><strong><u>训练神经网络</u></strong>直至能输出正确的结构</li>
<li><strong><u>使用神经网络</u></strong></li>
</ol>
</li>
</ul>
</li>
<li><p>网络结构</p>
<ul>
<li><p>双层网络/多层网络</p>
</li>
<li><p>全连接/部分连接神经网络</p>
</li>
<li><p>前馈神经网络—— BP算法</p>
<p>计算每个单元的误差，首先计算输出单元的误差；利用<u><strong>输出单元的误差再计算上一层单元的误差</strong></u>，依次向上传播，因此又称<strong><u>反向传播</u></strong>，又称<strong><u>逆推学习算法</u></strong>，简称BP算法。</p>
</li>
<li><p>随机神经网络—— 模拟退火算法</p>
</li>
<li><p>自组织特征映射神经网络</p>
</li>
</ul>
</li>
<li><p>学习速率</p>
<ul>
<li>ƞ称作学习速率，一般设定为小数</li>
<li>学习速率主要用于控制权重的变化</li>
<li>学习速率ƞ的大小对学习算法的影响：<ul>
<li>过大会引起飘移</li>
<li>过小收敛速度太慢，学习效率不高</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="神经网络学习法中学习速率n的概念"><a href="#神经网络学习法中学习速率n的概念" class="headerlink" title="神经网络学习法中学习速率ƞ的概念"></a>神经网络学习法中学习速率ƞ的概念</h4><h4 id="了解ID3学习算法构建决策树的原理和过程"><a href="#了解ID3学习算法构建决策树的原理和过程" class="headerlink" title="了解ID3学习算法构建决策树的原理和过程"></a>了解ID3学习算法构建决策树的原理和过程</h4><p>采用自顶向下的贪婪搜索遍历可能的决策树空间</p>
<ol>
<li>ID3的思想<ul>
<li><strong>自顶向下</strong>构造决策树</li>
<li>从“哪一个属性将在树的根节点被测试”开始</li>
<li>使用统计测试来确定每一个实例属性单独分类训练样例的能力</li>
</ul>
</li>
<li>ID3的过程<ul>
<li>分类能力最好的属性被选作树的根节点(如年龄、长相、文化程度、收入、工作性质、家庭背景，性别，姓氏等等)</li>
<li>根节点的每个可能值产生一个分支</li>
<li>训练样例排列到适当的分支</li>
<li>重复上述过程</li>
</ul>
</li>
<li>ID3算法<ol>
<li>随机选择训练实例的子集构成训练窗口</li>
<li>重复下列步骤：<ol>
<li>对窗口内的实例集构造其决策树</li>
<li>寻找决策树的一个反例</li>
<li>如果反例存在则将其加入到训练窗口中，并转1；否则返回得到决策树</li>
</ol>
</li>
<li>ID3检查所有的候选属性，选择增益最大的属性A作为根节点，形成数。然后对子树C~1~ ,C~2~ ,…,C~m~以同样处理，递归形成决策树。</li>
</ol>
</li>
<li>ID3和候选消除算法的比较<ul>
<li>ID3的搜索范围是一个完整的假设空间，但不彻底地搜索这个空间</li>
<li>候选消除算法的搜索范围是不完整的假设空间，但彻底地搜索这个空间</li>
<li>ID3的归纳偏置完全是搜索车略排序假设的结果，来自搜索策略</li>
<li>候选消除算法完全是假设表示的表达能力的结果，来自对搜索空间的定义。</li>
</ul>
</li>
</ol>
<h2 id="计算智能"><a href="#计算智能" class="headerlink" title="计算智能"></a>计算智能</h2><h3 id="关于A-B-C智能（-）"><a href="#关于A-B-C智能（-）" class="headerlink" title="关于A,B,C智能（*）"></a>关于A,B,C智能（*）</h3><p>贝兹德克（ Bezdek ）于1992年提出了一种A，B，C智能模型，从而表示ABC与神经网络、模式识别和智能之间的关系：</p>
<ul>
<li>Artificial ，人工的、符号的（非生物的）</li>
<li>Biological ，生物的</li>
<li>Computational ，计算的</li>
</ul>
<p>计算智能是一种智力方式的底层认知，它与人工智能的区别是认知层次从中层下降到底层。中层系统含有知识，底层系统没有知识。</p>
<p>当一个系统只涉及数值(低层)数据，含有模式识别部分，不应用于人工智能意义上的知识，而且系统能够呈现出：计算适应性、计算容错性、接近人的计算速度、计算误差率与人接近，则该系统就是<strong>计算智能系统</strong>。</p>
<p>当一个计算智能系统以非数值方式并加上知识，即认为<strong>人工智能系统</strong>。</p>
<h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><h4 id="算法的思想"><a href="#算法的思想" class="headerlink" title="算法的思想"></a>算法的思想</h4><p>在生物系统中，进化被认为是一种成功的自适应方法，具有很好的健壮性。其主要特点：</p>
<ol>
<li>直接对结构对象进行操作，不存在求导和函数连续性的限定。</li>
<li>具有内在的隐含并行性和更好的全局寻优能力；</li>
<li>采用概率化的寻优方法，能自动获取和指导优化的搜索空间。</li>
<li>自适应地调整搜索方向，不需要确定的规则</li>
</ol>
<p>遗传算法将“优胜劣汰，适者生存”的生物进化原理引入优化参数形成的编码串群体中，按所选择的<strong><u>适应度函数</u></strong>并通过遗传中的<u><strong>复制、交叉及变异</strong></u>对个体进行筛选，<strong>适应度高</strong>的个体被保留下来，组成新的群体，新的群体既继承了上一代的信息，又优于上一代</p>
<h4 id="三种基本操作：复制、交叉、变异"><a href="#三种基本操作：复制、交叉、变异" class="headerlink" title="三种基本操作：复制、交叉、变异"></a>三种基本操作：复制、交叉、变异</h4><ol>
<li><p>复制：从一个旧种群中选择生命力强的个体位串产生新种群的过程，具有<strong>高适应度</strong>的位串更有可能在下一代中产生一个或多个子孙。</p>
<p>复制操作可以通过随机方法来实现。首先产生0~1之间均匀分布的随机数，若某串的复制概率为40%，则当产生的随机数在0.40~1.0之间时，该串被复制，否则被淘汰。</p>
</li>
<li><p>交叉：复制操作能从旧种群中选择出优秀者，但不能创造新的染色体。而交叉模拟了生物进化过程中的<strong>繁殖现象</strong>，通过两个染色体的交换组合，来产生新的优良品种。</p>
<p>交叉的过程为：在匹配池中任选两个染色体，随机选择一点或多点交换点位置；交换双亲染色体交换点右边的部分，即可得到两个新的染色体数字串。</p>
</li>
<li><p>变异：用来模拟生物在自然的遗传环境中由于各种偶然因素引起的基因突变，它<strong>以很小的概率随机地改变遗传基因</strong>（表示染色体的符号串的某一位）的值。在染色体以二进制编码的系统中，它随机地将染色体的某一个基因由1变成0，由0变成1.</p>
<p>若只有选择和交叉，而没有变异，则无法在初始基因组合以外的空间进行搜索，使进化过程在早期就陷入局部解而进入终止过程，从而影响解的质量。为了在尽可能大的空间中获得质量较高的优化解，必须采用变异操作。</p>
</li>
</ol>
<h4 id="适应度函数与轮盘赌算法"><a href="#适应度函数与轮盘赌算法" class="headerlink" title="适应度函数与轮盘赌算法"></a>适应度函数与轮盘赌算法</h4><p>在遗传算法中，衡量个体优劣的尺度是<strong><u>适应度</u></strong>，根据适应度的大小决定某些个体是繁殖或是消亡。</p>
<p>通常，适应度是费用、赢利、方差等目标的表达式。</p>
<ol>
<li><p>统一表达式</p>
</li>
<li><p>适应度缩放</p>
</li>
<li><p>复制（轮盘选择）</p>
<ul>
<li>依次累计群体内各个个体的适应度，得相应的累计值$S_i$,最后一个累计值为$S_n$</li>
<li>在$[0,S_n]$区间内产生均匀分布的随机数R</li>
<li>依次用S~i~ 与R相比较，第一个出现S~i~大于或等于R的个体i被选为复制对象</li>
<li>重复(2),(3)直至满足所需要的个体数目。</li>
</ul>
<p>每代群体中，被复制的个体数目由复制概率Pt控制， Pt常取0.1～0.2，也就是说，群体中有90%～80%个体被复制，相应地有10%<br>～20%个体被淘汰，以保持群体大小。</p>
</li>
</ol>
<h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><ol>
<li><p>编码（coding）</p>
<p>遗传算法首先要对实际问题进行编码，用字符串表达问题。这种字符串相当于遗传学中的染色体。每一代所产生的字符串个体总和称为群体。为了实现方便，字符串长度固定，字符选为0或1。</p>
<p>遗传算法的工作对象是字符串，因此对字符串的编码有两点要求：</p>
<ul>
<li>字符串要反映所研究问题的性质</li>
<li>字符串的表达要便于计算处理</li>
</ul>
<p>对于兼有多种性质的问题，可以采用长字符串顺序分别表示。例如，可选25位0/1字符串表示物体的体积、重量及颜色，其中前10位数表示体积量，中间10位数表示重量，后5位数表示颜色。</p>
</li>
</ol>
<h4 id="遗传算法工作步骤（-）"><a href="#遗传算法工作步骤（-）" class="headerlink" title="遗传算法工作步骤（*）"></a>遗传算法工作步骤（*）</h4><p>复制概率$P_t$：用于控制复制与淘汰的个体数目，取值范围0.4~1。</p>
<p>交叉率$P_c$：参加交叉运算的染色体个数占全体染色体总数的比例，取值范围0.4~0.99</p>
<p>变异率$P_m$：发生变异的基因位数所占全体染色体的基因总位数的比例，取值范围0.0001～0.1</p>
<h4 id="与粒子群算法的相同与不同"><a href="#与粒子群算法的相同与不同" class="headerlink" title="与粒子群算法的相同与不同"></a>与粒子群算法的相同与不同</h4><h3 id="群智能（Swarm-Intelligence）"><a href="#群智能（Swarm-Intelligence）" class="headerlink" title="群智能（Swarm Intelligence）"></a>群智能（Swarm Intelligence）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong><u>智能源于社会性的相互作用</u></strong>，群智能发展的基石。</p>
<p>已有的群智能理论和应用研究证明群智能方法是一种能够有效解决<strong><u>大多数优化问题的新方法</u></strong></p>
<h4 id="两大特点"><a href="#两大特点" class="headerlink" title="两大特点"></a>两大特点</h4><p>并行性和分布式</p>
<h4 id="已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法"><a href="#已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法" class="headerlink" title="已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法"></a>已有的群智能理论的研究和应用证明群智能方法是一种能够有效解决优化问题的方法</h4><h4 id="群智能典型算法"><a href="#群智能典型算法" class="headerlink" title="群智能典型算法"></a>群智能典型算法</h4><ul>
<li>蚁群算法</li>
<li>粒子群算法</li>
<li>鱼群算法</li>
<li>猴群算法</li>
</ul>
<h4 id="蚁群算法，粒子群算法"><a href="#蚁群算法，粒子群算法" class="headerlink" title="蚁群算法，粒子群算法"></a>蚁群算法，粒子群算法</h4><ol>
<li><p>蚁群算法</p>
<ol>
<li><p>蚁群算法：</p>
<p>蚂蚁觅食的过程，随机移动，遇到食物返回的路上分泌信息素（易挥发的化学性物质），关键路径上的信息素浓度相对高。</p>
</li>
<li><p>蚁群算法原理：</p>
<ul>
<li>基于蚂蚁觅食时最优路径的选择问题，可以构造人工蚁群来解决最优问题</li>
<li>人工蚁群中把具有最简单功能的工作单元看作蚂蚁</li>
<li>人工蚂蚁与自然蚁群相似：优先选择信息素浓度大的路径；区别：人工蚂蚁具有一定的记忆能力，能够记忆已经访问过的节点</li>
<li>人工蚁群在选择吓一跳路径的时候按照一定的算法有意识的寻找最短路径，而不是盲目的。</li>
</ul>
</li>
<li>蚁群算法中的各种行为因子<ul>
<li>范围</li>
<li>环境</li>
<li>觅食规则</li>
<li>移动规则</li>
<li>避障规则</li>
<li>信息素规则</li>
</ul>
</li>
<li>蚁群算法的应用<ul>
<li>聚类问题</li>
<li>路由算法设计</li>
<li>图着色</li>
<li>车辆调度</li>
<li>机器人路径规划</li>
</ul>
</li>
</ol>
</li>
<li><p>粒子群算法</p>
<ol>
<li><p>粒子群优化算法：</p>
<p>模拟鸟群或蜂群的觅食行为。</p>
</li>
<li><p>基本思想：通过群体中个体之间的协作和信息共享来寻找最优解。</p>
</li>
<li><p>粒子群优化算法原理：</p>
<ul>
<li>每个飞行的小鸟抽象为一个无质量、无体积的粒子</li>
<li>每个粒子有一个适应度（评估）函数模拟每只小鸟与食物的<strong>距离</strong></li>
<li>每个粒子有一个<strong>速度</strong>决定它的飞行方向和距离，初始值可以随机确定</li>
<li>每一次单位时间的飞行后，所有粒子分享信息，下一步将飞向<strong>自身最佳位置</strong>（个体极值）和<strong>全局最优位置</strong>（全局极值）的加权中心</li>
</ul>
</li>
<li><p>粒子群优化算法流程</p>
<ol>
<li>初始化一群粒子（群体规模），包括随机的位置和速度</li>
<li>评价每个粒子的适应度</li>
<li>对每个粒子更新个体最优位置P~id~</li>
<li>更新全局最优位置P~gbest~</li>
<li>根据速度和位置方差更行每个粒子的速度和位置（V~id~和P~id~)</li>
<li>如果未满足结束条件（通常为满足足够好的适应值或达到设定的最大迭代次数），返回2 </li>
</ol>
</li>
<li><p>粒子速度和位置的更新公式（*）</p>
<p>第k+1时刻第i个粒子的位置和速度更新为：</p>
<p>$$V^{k+1}<em>{id} = wv^k</em>{id}+c_1rand()(p<em>id+x^k</em>{id})+c<em>2rand()(p</em>{gbest}+x^k_{id})$$</p>
<p>$$x^{k+1}<em>{id}=x^k</em>{id}+v^{k+1}_{id}    i=1,2,…; d=1,2,…,D$$</p>
<p>惯性权重w</p>
<ul>
<li>使粒子保持运动惯性，使其有扩展搜索空间的趋势，有能力探索新的区域。</li>
<li>表示微粒对当前自身运动状态的信任，依据自身的速度进行惯性运动。</li>
<li>较大的w有利于跳出局部极值，而较小的w有利于算法收敛。</li>
</ul>
<p>加速常数$c_1$和$c_2$</p>
<ul>
<li><p>代表将粒子推向$P<em>{best}$和$G</em>{best}$位置的统计加速项的权重。</p>
</li>
<li><p>表示粒子的动作来源于自己经验的部分和其它粒子经验的部分。</p>
</li>
<li><p>较小的值允许粒子在被拉回之前可以在目标区域外徘徊，而较大的值则导致粒子突然冲向或越过目标区域。    </p>
</li>
<li><p>将c1和c2统一为一个控制参数，φ=c1+c2</p>
<p>如果φ很小，粒子群运动轨迹将非常缓慢；</p>
<p>如果φ很大，则粒子的位置变化非常快；</p>
<p>实验表明，当φ=4.1（通常c1=2.0，c2=2.0）时，具有很好的收敛效果。</p>
</li>
</ul>
<p>粒子数</p>
<ul>
<li>一般取20~40，对较难或特定类别的问题可以取100~200</li>
</ul>
<p>最大速度$V_max$</p>
<ul>
<li>决定粒子在一个循环中最大的移动距离，通常设定为粒子的范围宽度。</li>
</ul>
<p>终止条件</p>
<ul>
<li>最大循环数以及最小错误要求</li>
</ul>
</li>
<li><p>与遗传算法的比较</p>
<ol>
<li>共性：<ul>
<li>都属于仿生算法</li>
<li>都属于全局优化方法</li>
<li>都属于随机搜索算法</li>
<li>都隐含并行性</li>
<li>根据个体的适应信息进行搜索，因此不受函数约束条件的限制，如连续性、可导性等；</li>
<li>对高位复杂问题，往往会遇到早熟收敛和收敛性能差的缺点，都无法保证收敛到最优点</li>
</ul>
</li>
<li>差异：<ul>
<li>PSO有记忆，所有粒子都保存较优解的知识，而GA，以前的知识随着种群的改变被改变</li>
<li>PSO中的粒子是一种单向信息共享机制。而GA中的染色体之间相互共享信息，使得整个种群都向最优区域移动</li>
<li>GA需要编码和遗传操作，而PSO没有交叉和变异操作，粒子只是通过内部速度进行更行，因此原理更简单、参数更少、实现更容易。</li>
</ul>
</li>
<li>粒子群优化算法的应用<ul>
<li>巡航导弹的飞行高度进行优化</li>
<li>车辆路径问题的应用</li>
<li>邮政投递</li>
<li>火车及汽车的调度</li>
<li>港口装卸集装箱</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="人工鱼群算法"><a href="#人工鱼群算法" class="headerlink" title="人工鱼群算法"></a>人工鱼群算法</h4><p>模拟鱼群的觅食行为、集群行为、跟随行为、和随机游动行为。大多数时间，鱼会想有更多食物的方向游动，同事，它们会尽量聚集在一起来并保持和鱼群中心位置的鱼游动方向一致</p>
<h4 id="每种算法提出的思想依据与理论基础"><a href="#每种算法提出的思想依据与理论基础" class="headerlink" title="每种算法提出的思想依据与理论基础"></a>每种算法提出的思想依据与理论基础</h4><h4 id="蚁群算法和粒子群算法应用领域"><a href="#蚁群算法和粒子群算法应用领域" class="headerlink" title="蚁群算法和粒子群算法应用领域"></a>蚁群算法和粒子群算法应用领域</h4><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><ol>
<li>NPL的困难<ul>
<li>歧义（Ambiguity）<ul>
<li>注音歧义</li>
<li>分词歧义</li>
<li>无法在句子内部解决的歧义</li>
<li>短语歧义</li>
</ul>
</li>
<li>病构（ill-Formedness）</li>
<li>重述（Paraphrasing）</li>
</ul>
</li>
</ol>
<ol>
<li><p>NPL方法论</p>
<p>语言处理的科学内容</p>
</li>
<li><p>NPL的任务和瓶颈</p>
<ol>
<li><p>NLP的性质</p>
<p>NLP需要的知识非常复杂</p>
<ul>
<li>理解语言的过程是动态的，不是静态的</li>
<li>NLP需要的知识大多是归纳的，不是演绎的</li>
<li>人也不一定能够做出一致的理解结果，存在Upper Bound</li>
<li>NLP是一个非确定性过程</li>
<li>领域词典不充分</li>
</ul>
</li>
</ol>
</li>
<li><p>统计语言模型及解决问题的思想</p>
<p>|    模型    |    算法     |<br>| :——: | :——-: |<br>|  状态机模型   |   动态编程    |<br>| 形式规则系统模型 |   及其学习    |<br>|   统计模型   | 分类/序列模型算法 |<br>|  向量空间模型  |  最大期望算法   |</p>
<p>​</p>
</li>
</ol>
<h3 id="人工智能历史"><a href="#人工智能历史" class="headerlink" title="人工智能历史"></a>人工智能历史</h3><h4 id="人工智能方法与传统程序的不同"><a href="#人工智能方法与传统程序的不同" class="headerlink" title="人工智能方法与传统程序的不同"></a>人工智能方法与传统程序的不同</h4><p>传统方法解决问题。利用已有知识，问题可以结构化-数据结构，数学表达式-数学公式、算法。</p>
<p>利用知识，特别是依赖人类经验的启发知识是人工智能方法与传统数学方法的根本不同之处。基于此，人工智能可以解决众多的难以数学表达的非结构化的实际问题</p>
<p>人工智能首先研究的是以符号表示的知识而不是数值为研究对象。其次采用的是启发式推理的方法而不是常规的算法。控制结构和领域知识是分离的，同时还允许出现相对正确的答案。</p>
<h4 id="人工智能的本质"><a href="#人工智能的本质" class="headerlink" title="人工智能的本质"></a>人工智能的本质</h4><h4 id="研究人工智能的途径"><a href="#研究人工智能的途径" class="headerlink" title="研究人工智能的途径"></a>研究人工智能的途径</h4><h4 id="人工智能的重要影响人物"><a href="#人工智能的重要影响人物" class="headerlink" title="人工智能的重要影响人物"></a>人工智能的重要影响人物</h4><ul>
<li>阿伦-图灵：计算机科学理论创始人</li>
<li>马文-明斯基：人工智能之父，框架理论创立者，首位获得图灵奖的人工智能学者</li>
<li>约翰-麦卡锡：人工智能之父，LISP语言发明人，首次提出AI概念</li>
<li>赫伯特-西蒙：符号主义学派创始人，中国科学院外籍院士</li>
<li>艾伦-纽厄尔：符号主义学派创始人一致，西蒙的学生</li>
</ul>
<h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h3><ol>
<li>归结原理<ul>
<li>P4 49页   求归结步骤和归结树</li>
<li>P4 27页   化为Skolem标准形</li>
</ul>
</li>
<li>主观贝叶斯方法<ul>
<li>P5 100页  根据R1,R2，LS,LN求B的更新值(A1,A2必然发生的情况)</li>
</ul>
</li>
<li>确定性方法<ul>
<li>P5  124页  CF(B1),CF(B2)的计算</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/20/计算机体系结构专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/计算机体系结构专题复习/" itemprop="url">
                  计算机体系结构专题复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T21:57:47+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机体系结构专题复习"><a href="#计算机体系结构专题复习" class="headerlink" title="计算机体系结构专题复习"></a>计算机体系结构专题复习</h1><p>made by © Isaac .Ty</p>
<h2 id="第一章-计算机系统结构基础及并行性的开发"><a href="#第一章-计算机系统结构基础及并行性的开发" class="headerlink" title="第一章 计算机系统结构基础及并行性的开发"></a>第一章 计算机系统结构基础及并行性的开发</h2><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><ul>
<li>机器：能存储和执行相应语言程序的算法和数据结构的<strong>执行体</strong>。</li>
<li>计算机语言：<ul>
<li>用以 述控制流程的、有一定规则的字符集合<ul>
<li>语言不是专属软件范畴，可以分属于计算机系统的各个层次，具有不同作用            </li>
</ul>
</li>
</ul>
</li>
<li>多层次结构：从使用语言的角度，一台由软、硬件组成的通用计算机系统可以被看成是按功能划分的多层机器组成的层次结构</li>
<li><p><strong>多级层次结构</strong>(机器—语言)</p>
<ul>
<li>M5:应用语言机器——–应用语言</li>
<li>M4:高级语言机器——–高级语言</li>
<li>M3:汇编语言机器——–汇编语言</li>
<li>M2:操作系统机器——-作业控制语言</li>
<li>M1:传统机器————-机器指令系统</li>
<li>M0:微程序机器———-微指令系统</li>
</ul>
</li>
<li><strong>编译</strong>：用转换程序将高一级机器上的程序变换成低一级机器上的等效程序。</li>
<li><strong>解释</strong>：在低级机器上使用一串程序或指令来仿真高级机器上的一条语句或指令的功能。</li>
<li>模拟：在一种机器上实现另一种机器的指令系统</li>
<li>仿真：用微程序直接解释另一种机器指令系统的方法</li>
</ul>
<h3 id="计算机系统结构、计算机组成和计算机实现"><a href="#计算机系统结构、计算机组成和计算机实现" class="headerlink" title="计算机系统结构、计算机组成和计算机实现"></a>计算机系统结构、计算机组成和计算机实现</h3><ul>
<li><strong>系统结构</strong>：计算机系统中各级界面的定义及其上下功能的分配</li>
<li><strong>透明</strong>：各个层级的程序员所看到的计算机属性不同，系统结构的研究内容之一就是要<strong>确定属性</strong>的透明性。</li>
<li>计算机组成：计算机系统结构的<strong>逻辑实现</strong>，包括机器级内部的<strong>数据流和控制流</strong>的组成以及逻辑设计等</li>
<li>透明性：客观存在的事物或属性从某个角度看不到。 在一个计算机系统中，低层机器的属性往往对高层程序员是透明的。计算机组成设计的内容，对传统机器程序员来讲一般是透明的</li>
</ul>
<h3 id="计算机系统的软、硬件取舍和性能评测及定量设计原理"><a href="#计算机系统的软、硬件取舍和性能评测及定量设计原理" class="headerlink" title="计算机系统的软、硬件取舍和性能评测及定量设计原理"></a>计算机系统的软、硬件取舍和性能评测及定量设计原理</h3><h4 id="计算机性能评测"><a href="#计算机性能评测" class="headerlink" title="计算机性能评测"></a>计算机性能评测</h4><p>软件和硬件的逻辑等效性</p>
<ul>
<li>硬件实现:速度快、成本高;灵活性差、占用内存少</li>
<li>软件实现:速度慢、复制费用低;灵活性好、占用内存多、易设计、可改性强、适应性强、设计周期短;</li>
</ul>
<p>软件和硬件的分配</p>
<ul>
<li>在满足应用的前提下，软硬件功能分配的比例主要看能否充分利用硬件、器件技术的进展，使系统具有高的性价比</li>
</ul>
<p>软件和硬件的取舍原则</p>
<ul>
<li><p>原则1：考虑现有硬件、器件条件下，系统要有<strong>高的性价比</strong>，主要从实现费用、速度和其他性能要求来综合考虑</p>
<p>计算机系统产量比较大，增大硬件功能实现的比例才是合适的。    </p>
</li>
<li><p>原则2：考虑准备采用和可能采用的<strong>组成技术</strong>，使之尽可能不要过多或者不合理地限制各种组成、实现技术的采用</p>
</li>
<li><p>原则3：不能仅从<strong>硬件</strong>的角度考虑如何便于应用组成技术的成果和便于发挥器件技术的进程，还应从<strong>软件</strong>的角度把如何为编译和操作系统的实现以及如何为高级程序的设计提供更多、更好的硬件支持放在首位</p>
</li>
<li><p>结论：要缩短底<strong>层系统结构</strong>和<strong>机器语言</strong>与<strong>上层高级语言、操作系统</strong>和<strong>程序设计环境之间</strong>的语义差距，加强系统结构对软件设计的支持。</p>
</li>
<li><p>CPU性能公式：</p>
<ul>
<li><p>程序执行的总指令条数$IC$</p>
</li>
<li><p>平均每条指令的时钟周期数$CPI$</p>
</li>
<li><p>时钟主频$f_c$</p>
<p>$T_{CPU} =IC\times CPI \times \frac{1}{f_c}$</p>
</li>
<li><p>n种指令，每种指令的时钟周期数$CPI_i$，出现次数$I_i$</p>
</li>
</ul>
</li>
</ul>
<h4 id="定量设计原理"><a href="#定量设计原理" class="headerlink" title="定量设计原理"></a>定量设计原理</h4><p>哈夫曼压缩原理</p>
<ul>
<li>尽可能加速<strong>高概率事件</strong>远比加速处理<strong>低概率事件</strong>对性能提高要显著。</li>
</ul>
<p><strong>Amdahl定律</strong></p>
<ul>
<li>系统中某一部件由于采用某种更快的执行方式后整个系统性能的提高与这种<strong>执行方式的执行频率</strong>或<strong>占总执行时间的比例</strong>有关</li>
<li>对系统中的系能瓶颈部分采取措施提高后能得到系统性能改进的程度</li>
<li>系统加速比 $S<em>p=\frac{T</em>{old}}{T<em>{new}} = \frac {1}{(1-f</em>{new})+f<em>{new}/r</em>{new}}$ </li>
<li>例1、例2、例3</li>
<li>改进效果好的高性能系统应是一个各部分性能均能平衡得得到提高的系统，不能只是其中某一个功能部件的性能得到提高</li>
</ul>
<h4 id="程序访问的局部性规律"><a href="#程序访问的局部性规律" class="headerlink" title="程序访问的局部性规律"></a>程序访问的局部性规律</h4><p>局部性分时间上的局部性和空间上的局部性</p>
<ul>
<li>时间局部性：程序中近期被访问的信息项很可能马上将被再次访问。</li>
<li>空间局部性：指那些在访问地址上相邻近的信息项很可能会被一起访问。</li>
</ul>
<p>存储器体系的构成就是以访问局部性原理为基础的</p>
<p>​    </p>
<h2 id="第二章-数据表示、寻址方式与指令系统"><a href="#第二章-数据表示、寻址方式与指令系统" class="headerlink" title="第二章 数据表示、寻址方式与指令系统"></a>第二章 数据表示、寻址方式与指令系统</h2><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><h4 id="数据表示和数据结构"><a href="#数据表示和数据结构" class="headerlink" title="数据表示和数据结构"></a>数据表示和数据结构</h4><p><strong>数据表示</strong>：能由机器<strong>硬件识别</strong>和<strong>引用</strong>的数据类型，即它有对这种类型的数据进行操作的指令和运算部件。</p>
<p><strong>数据结构</strong>：通过软件映像，变换成机器中所具有的数据来表示实现。</p>
<p>不同的<strong>数据表示</strong>可为数据结构的实现提供不同的支持，表现为实现效率和方便性的不同。数据结构和数据表示是<strong>软件和硬件的交界面</strong>。</p>
<p><strong>数据表示的确定实质上是软、硬件的取舍问题</strong></p>
<h4 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h4><ol>
<li><p>自定义数据表示</p>
<p>标志符和数据描述符</p>
<ul>
<li><p><strong><em>标志符</em></strong></p>
<p>让每个数据带上<strong>类型标志位</strong>以说明数据值究竟是二进制整数、十进制整数……将数据类型与数据本身连在一起</p>
<p>优点（6条）：简化指令系统和程序设计、简化编译程序、便于通过硬件实现一致性校验、硬件自动变换类型、数据库系统实现和数据类型无关的要求使程序不用修改即可处理多种不同类型的数据、支持软件调试和应用软件开发</p>
<p>缺点（2条）：每个数据字增设标志符增加程序所占主存空间，但是缩短了操作码位数；采用标志符降低指令执行速度。</p>
</li>
<li><p><strong><em>数据描述符</em></strong></p>
<p>描述符与数据分开存放，描述所要访问的数据是整块的还是单个的，访问该数据块或数据元素所要的地址及其它信息</p>
<p>优点：(1)<strong>描述符</strong>实现阵列数据的索引要比用<strong>变址方法</strong>实现更方便，且便于检查程序中的阵列越界错误；(2)为向量、数组数据结构的实现提供了一定的支持。</p>
</li>
</ul>
</li>
<li><p><strong><em>向量、数组数据表示</em></strong></p>
<p>增设向量、数组数据表示提供对向量、数组数据结构提供支持</p>
<p>优点：加快形成元素地址；用一条向量、数组指令流水可同时对整个向量、数组进行高速处理；硬件判断下标是否越界，并让越界判断和元素运算并行；节省存储空间和处理时间；简化编译程序</p>
<p>向量处理机：具有向量表示和相应的向量运算指令的计算机</p>
<p>标量处理机：不具有向量表示和相应的向量运算指令的计算机</p>
</li>
<li><p><strong><em><u>浮点数表示方式的核心</u></em></strong>：数据字长与这种数据表示方式的<strong>表数范围</strong>、<strong>表示精度</strong>和<strong>表数效率</strong>之间的关系</p>
</li>
</ol>
<h3 id="寻址方式（重点）"><a href="#寻址方式（重点）" class="headerlink" title="寻址方式（重点）"></a>寻址方式（重点）</h3><p>指令按什么方式寻找到所需的操作数或信息</p>
<h4 id="寻址方式的三个面向"><a href="#寻址方式的三个面向" class="headerlink" title="寻址方式的三个面向"></a>寻址方式的三个面向</h4><p><strong>面向主存</strong>：主要访问主存，少量访问寄存器</p>
<p><strong>面向寄存器</strong>：主要访问寄存器，少量访问主存和堆栈</p>
<p><strong>面向堆栈</strong>：主要访问堆栈，少量访问主存和寄存器</p>
<h4 id="寻址方式在指令中的指明"><a href="#寻址方式在指令中的指明" class="headerlink" title="寻址方式在指令中的指明"></a>寻址方式在指令中的指明</h4><ul>
<li>占用<strong>操作码的某些位</strong>来指明</li>
<li>在<strong>地址码部分</strong>专门设置寻址方式位字段指明</li>
</ul>
<h4 id="寻址方式的种类"><a href="#寻址方式的种类" class="headerlink" title="寻址方式的种类"></a>寻址方式的种类</h4><ul>
<li>寄存器寻址：指令中的地址码是寄存器的编号，而不是操作数地址或本身<ul>
<li>寄存器直接寻址：寄存器内容即操作数</li>
<li>寄存器简介寻址：寄存器内容是操作数的地址</li>
</ul>
</li>
<li>立即寻址：指令的地址码字段直接是操作数</li>
<li>直接寻址：指令的地址码字段直接指出操作数在主存中的地址</li>
<li>间接寻址：指令的地址码字段指向的存储单元存储的不是操作数，而是操作数的地址</li>
<li>相对寻址：把程序计数器PC的内容加上指令中的形式地址而形式操作数的有效地址</li>
<li>变址寻址：将变址寄存器的内容加上指令中的形式地址而形成操作数有效地址，实现程序块的规律性变化</li>
<li>基址寻址：将基址寄存器的内容加上指令中的形式地址而形成操作数有效地址，优点是可以扩大寻址能力</li>
</ul>
<h4 id="程序在主存中的定位技术"><a href="#程序在主存中的定位技术" class="headerlink" title="程序在主存中的定位技术"></a>程序在主存中的定位技术</h4><p><strong>逻辑地址</strong>：程序员编写程序时使用的地址</p>
<p><strong>物理地址</strong>：程序在主存中的实际地址</p>
<ul>
<li>静态再定位：在目的程序装入主存的时候，由装入程序用<strong>软件方法</strong>把目的程序的<strong>逻辑地址变换为物理地址</strong>，程序执行时，<strong>物理地址不再改变</strong>。 不利于多道程序执行</li>
<li>动态再定位：基址寻址。<ul>
<li>增加相应的基址寄存器和地址加法器硬件，程序不做变换直接装入主存的同时，将装入主存的起始地址装入对应该道程序使用的基址寄存器中。</li>
<li>程序执行时，只要通过<strong>地址加法器</strong>将<strong>逻辑地址</strong>加上<strong>基址寄存器的程序基址</strong>形成有效地址后进行访存操作即可。</li>
<li>需要通过上、下界寄存器进行判断</li>
</ul>
</li>
<li>虚实地址映像表<ul>
<li>采用虚拟存储器，增加映像表硬件，使得程序空间可以超过主存空间</li>
<li>基址寻址。B为基址寄存器号，存放24位的基地址。(B)~(8-13)~+D形成24位宽的访存物理地址</li>
</ul>
</li>
<li>物理主存中的信息分布<ul>
<li>IBM370</li>
<li>任意存储</li>
<li>整数倍存储</li>
</ul>
</li>
</ul>
<h3 id="指令系统的设计和优化"><a href="#指令系统的设计和优化" class="headerlink" title="指令系统的设计和优化"></a>指令系统的设计和优化</h3><h4 id="指令系统设计基本原则"><a href="#指令系统设计基本原则" class="headerlink" title="指令系统设计基本原则"></a>指令系统设计基本原则</h4><p><strong>指令系统</strong>是程序设计者看到的机器的主要属性，是软、硬件的主要界面，在很大程度上决定了计算机具有的基本功能</p>
<p>指令系统的设计主要包括<strong>指令的功能</strong>（操作类型、寻址方式和具体内容）和<strong>指令格式</strong>的设计</p>
<h4 id="指令设计的步骤"><a href="#指令设计的步骤" class="headerlink" title="指令设计的步骤"></a>指令设计的步骤</h4><ul>
<li>根据应用，初拟指令的分类和具体指令</li>
<li>试编出用该指令系统设计的各种高级语言的编译程序</li>
<li>用大量测试程序进行模拟测试，看指令系统的操作码和寻址方式效能是否都比较高</li>
<li>将程序中高频出现的指令串复合改成一条强功能新指令，即改用硬件方式实现；而将频度很低的指令操作改成基本的指令组成的指令串来实现，即用软件的方式实现</li>
</ul>
<h5 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h5><ul>
<li>非特权型：主要供应用程序员使用，也可供系统程序员使用，包括算术逻辑运算、数据传送、浮点运算、字符串、十进制运算、控制转移及系统控制</li>
<li>特权型：系统程序员使用，用户无权使用，包括启动I/O、停机等待、存储管理保护、控制系统状态、诊断等；</li>
</ul>
<h5 id="编译程序设计"><a href="#编译程序设计" class="headerlink" title="编译程序设计"></a>编译程序设计</h5><ul>
<li>设计原则：如何支持编译系统能高效、简易地将源程序翻译成目标代码<ul>
<li>规整性、对称性、独立性和全能性、正交性、可组合性、可扩充性</li>
</ul>
</li>
</ul>
<h5 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h5><ul>
<li>指令码密度适中、兼容性、适应性</li>
</ul>
<h4 id="指令格式的优化"><a href="#指令格式的优化" class="headerlink" title="指令格式的优化"></a>指令格式的优化</h4><p>指令由<strong>操作码</strong>和<strong>地址码</strong>两部分组成。</p>
<p><strong>指令格式的优化</strong>：用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。（哈弗曼压缩）</p>
<p>操作码的优化：缩短指令字长，减少程序总位数及增加指令字能表示的操作信息和地址信息。</p>
<h5 id="操作码优化"><a href="#操作码优化" class="headerlink" title="操作码优化"></a>操作码优化</h5><p>操作码$I_i$的使用频度$p_i$</p>
<p>操作码的<strong>信息源熵</strong>  (信息源所含的平均信息量)   $H=- \sum _i p_i \log p_i$</p>
<p>信息冗余度    $\frac {实际平均码长-H}{实际平均码长}$  </p>
<h5 id="哈夫曼压缩（计算：哈夫曼树构成）"><a href="#哈夫曼压缩（计算：哈夫曼树构成）" class="headerlink" title="哈夫曼压缩（计算：哈夫曼树构成）"></a>哈夫曼压缩（计算：哈夫曼树构成）</h5><p>当各种事件发生概率不均等时，采用优化技术，对发生概率高的事件用短的位数来表示，而对出现概率较低的事件允许使用较长的位数来表示，以缩短表示的平均位数。</p>
<p>用于代码压缩、程序压缩、空间压缩和时间压缩</p>
<p>编码长度不唯一，但是平均码长唯一</p>
<p>步骤：</p>
<ul>
<li>将所有指令的使用频度由小到大排序，每次选择其中最小的两个频度合并成一个频度，使它们二者之和称为一个新结点。再按该频度大小插入到余下未参与结合的频度中。直到全部形成根结点为止。</li>
<li>对每一个结点向下延伸，分出两个分支，分别用一位代码的”0“或”1“表示。</li>
</ul>
<p>由于短码不可能是长码的前缀，从而保证了解码的唯一性和事实性</p>
<h5 id="基于哈夫曼编码的扩展操作码（计算：指令设计）"><a href="#基于哈夫曼编码的扩展操作码（计算：指令设计）" class="headerlink" title="基于哈夫曼编码的扩展操作码（计算：指令设计）"></a>基于哈夫曼编码的扩展操作码（计算：指令设计）</h5><ul>
<li><p>完全哈夫曼编码码长种类太多，不利于译码和实现</p>
</li>
<li><p>界定于定长二进制编码和完全哈夫曼编码之间的一种编码方式</p>
</li>
<li><p>操作码长度不固定，但只有有限种选择</p>
</li>
<li><p><strong>高概率使用短码，低概率使用长码</strong>；短码不能是长码的前缀（11为扩展码）</p>
</li>
<li><p>缩短操作码的平均长度，以减低信息冗余度</p>
<p>等长15/15/15…  扩展法    等长 8/64/523扩展法</p>
</li>
<li><p>指令设计：基于编码给机器操作码编码</p>
</li>
</ul>
<h5 id="指令字格式的优化"><a href="#指令字格式的优化" class="headerlink" title="指令字格式的优化"></a>指令字格式的优化</h5><ul>
<li>主存按位编址，指令字不按整数边界存储，而是逐条紧挨存储。会直接带来程序的总位数减少，然而访存指令速度下降。</li>
<li>指令字按整数边界存储</li>
<li>此处有图</li>
<li>扩大操作数地址的寻址范围<ul>
<li>采用基址寄存器寻址、相对寻址或寄存器寻址</li>
<li>基于分段的编址（段号+段内地址）</li>
</ul>
</li>
<li>操作数的地址码长度可以有<strong>很宽的变化范围</strong>，可以与可变长操作码配合，可以显著减少存储空间的浪费。</li>
<li>多种地址制，同一种地址制还可以采用多种地址形式和长度，也可以直接用空白来存放直接操作数或常数。<ul>
<li>多种地址制图</li>
<li>同种地址制下的多种地址形式和长度</li>
</ul>
</li>
<li>优化措施<ul>
<li>采用<strong>扩展操作码</strong>，根据指令的<strong>频度</strong>的分布选择合适的编码方式，以缩短操作码平均码长。</li>
<li>采用<strong>多种寻址方式</strong>，以缩短地址码长，并在有限地址长度内提供更多信息</li>
<li>采用<strong>多种地址制</strong>，增强指令功能，从宏观上缩短程序长度，加快程序执行速度</li>
<li>在<strong>同种地址制内再采用多种地址形式</strong>，让每种地址字段可以有多种长度，且让长操作码与短操作码进行组配</li>
<li>在维持指令字的存储器中按整数边界存储的前提下，使用多种不同的指令字长计算</li>
</ul>
</li>
</ul>
<h5 id="指令编排（P63"><a href="#指令编排（P63" class="headerlink" title="指令编排（P63)"></a>指令编排（P63)</h5><h3 id="指令系统的发展和改进"><a href="#指令系统的发展和改进" class="headerlink" title="指令系统的发展和改进"></a>指令系统的发展和改进</h3><h2 id="第三章-存储、中断、总线与输入-输出系统"><a href="#第三章-存储、中断、总线与输入-输出系统" class="headerlink" title="第三章 存储、中断、总线与输入/输出系统"></a>第三章 存储、中断、总线与输入/输出系统</h2><h3 id="存储系统的基本要求和并行主存系统"><a href="#存储系统的基本要求和并行主存系统" class="headerlink" title="存储系统的基本要求和并行主存系统"></a>存储系统的基本要求和并行主存系统</h3><h4 id="存储系统的基本要求"><a href="#存储系统的基本要求" class="headerlink" title="存储系统的基本要求"></a>存储系统的基本要求</h4><ul>
<li><p>大容量、高速度、低价格</p>
</li>
<li><p>存储器<strong>容量</strong> $S_M=W \times l \times m$ </p>
<p>$W $为存储器字长，$l$为存储器字数，$m$为并行存储器体数</p>
</li>
<li><p>存储器速度</p>
<ul>
<li>访问时间$T_A$：存储器从接收访存读申请至信息被读到数据总线上的时间</li>
<li>存储周期$T_M$：连续启动一个存储器所需要的间隔时间（$T_M&gt;T_A$)</li>
<li>频宽（带宽）$B_M$：存储器可提供的数据传送速率<ul>
<li>最大频宽：单体$B_M = W /T_M $，m个存储体并行的最大频宽 $B_M = W\times m/T_M$</li>
<li>实际频宽</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h4><h5 id="单体单字存储器"><a href="#单体单字存储器" class="headerlink" title="单体单字存储器"></a>单体单字存储器</h5><p>当并行的存储器公用一套地址寄存器和地址译码电路时称为单体方式</p>
<p>每次访问一个存储器的一个字</p>
<p>最大的频宽$B_M = W /T_M$ </p>
<h5 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h5><p>把<strong>存储器字长</strong>增加n倍，为保持总容量不变，把存储器字数（地址数）相应减少n倍</p>
<p>在一个周期内访问n个数据</p>
<p>最大频宽 $B_M = W \times n / T_M$ </p>
<p><strong>取指令冲突</strong>：在遇到程序转移而且转移成功时，一个存储周期读出的n条指令中，后面的指令将无用</p>
<p><strong>读操作数冲突</strong>：一次同时读出的n个操作数，不一定都有用</p>
<p><strong>写数据冲突</strong>：必须凑齐n个数之后才能一起写入存储器</p>
<p><strong>读写冲突</strong>：当要读出的一个字和要写入存储器的字处在同一个存储字内时，无法在一个存储周期内完成</p>
<h5 id="多体单字"><a href="#多体单字" class="headerlink" title="多体单字"></a>多体单字</h5><p>由多组容量小、字长短的存储器片子组成，每个存储片子都有自己的地址译码、读/写驱动等外围电路</p>
<p>每个存储片子都有独立的地址译码、读/写驱动等外围电路</p>
<h5 id="模m低位交叉编址"><a href="#模m低位交叉编址" class="headerlink" title="模m低位交叉编址"></a>模m低位交叉编址</h5><ul>
<li>CPU字在主存中按模m低位交叉编址<ul>
<li>单体容量为l的m各分体，其$M_j$体的编址模式为$m\times i +j $，其中$ i = 0,1,2,..,l-1$ , $j=0,1,2,…,m-1$</li>
</ul>
</li>
<li>寻址规则<ul>
<li>体地址 $j = A \mod m$ </li>
<li>体内地址 $i = A / m$ <ul>
<li>$M_0 : 0,m,2m,…,m(l-1)+0$ </li>
<li>$M_i:i,m+i,2m+i,…,m(l-1)+i$ </li>
</ul>
</li>
</ul>
</li>
<li>适合于单处理机内 数据存储和带Cache主存</li>
</ul>
<h5 id="模m高位交叉编址"><a href="#模m高位交叉编址" class="headerlink" title="模m高位交叉编址"></a>模m高位交叉编址</h5><h5 id="定量分析-P85"><a href="#定量分析-P85" class="headerlink" title="定量分析(P85)"></a>定量分析(P85)</h5><p>转移概率$\lambda$，每个周期能访问的平均字数 $B = \frac {1-(1-\lambda)^m}{\lambda}$</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li>从最坏情况考虑，设所有申请(包括指令和数据)都是全随机的，用单来单服务、先来先服务的排队论模型进行模拟，可得出随 $m$ 的提高，主存频宽只是以近似$\sqrt m$的关系改善</li>
<li>当然，指令流和数据流也不会是全随机的，因此，𝐵的值总是会比$\sqrt m$的值要大</li>
<li>正是因为程序的转移概率不会很低，数据分布的离散性较大，所以单靠增大𝑚来 高并行主存系统的频宽是有限的，而且性能价格比还会随𝑚的增大而下降，就必须从系统结构上进行改进，采用存储体系</li>
</ul>
<h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>CPU终止正在执行的程序，转去处理随机提出的请求，待处理完毕后，再回到原先被中断的程序继续恢复执行的过程称为“中断”</p>
<p>相应和处理各种中断的软硬件系统总称为<strong>中断系统</strong></p>
<ul>
<li>内部中断：由CPU异常引起</li>
<li>外部中断：由中断信号引起<ul>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ul>
</li>
<li>软件中断：由自陷指令引起，用于操作系统服务</li>
</ul>
<h4 id="中断的分类和分级"><a href="#中断的分类和分级" class="headerlink" title="中断的分类和分级"></a>中断的分类和分级</h4><p>中断源：引起中断的各种事件</p>
<p><strong>中断请求</strong>：中断源向中断系统发出中断的申请</p>
<p><strong>中断响应</strong>：允许其中断CPU现行程序的运行，转去对该请求进行预处理，包括保存好端点现场，调出有关该中断的中断服务程序</p>
<h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><p>对中断进行分类，对每一类中断给定一个硬件的中断服务入口，再由软件分支转入相应的中断处理程序</p>
<h5 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h5><p>异常：由执行<strong>现行指令</strong>引起的临时停止事件，如运算结果溢出、页面失效等，一般不能屏蔽，应予立即相应和处理</p>
<p>中断：指那些<strong>与当前进程运行无关</strong>的请求临时停止的事件，如机器故障中断请求、外设中断请求、定时中断请求等，可以屏蔽、未被响应的中断源保留在中断字寄存器中，直至屏蔽解除后得到响应和处理</p>
<h5 id="中断的分级"><a href="#中断的分级" class="headerlink" title="中断的分级"></a>中断的分级</h5><p>同一类中各个中断请求的响应和处理的优先次序，一般由软件或通道来管理；而不同类的中断要根据其性质、紧迫性、重要性以及软件处理的方便性分成不同级别</p>
<h4 id="中断的响应和处理次序-P89"><a href="#中断的响应和处理次序-P89" class="headerlink" title="中断的响应和处理次序(P89)"></a>中断的响应和处理次序(P89)</h4><p>中断响应次序（处理中断流程）</p>
<ul>
<li>同时发生多个不同中断类的中断请求时，中断响应硬件中的<strong>排队器所决定的响应次序</strong></li>
<li>一般在处理某级中某个中断请求时，是不能被与它同级的或比它低一级的中断请求所中断，只有比它高一级的中断请求才能中断其处理，等响应和处理完毕后再继续处理原先那个中断请求</li>
</ul>
<p>中断处理次序</p>
<ul>
<li>中断处理完的次序</li>
<li>由于中断处理程序也可能被中断，中断处理次序可能不同于中断响应次序</li>
</ul>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><ul>
<li>只要操作系统根据需要软的方法，改变各级中断处理程序的中断级屏蔽位状态，就可以改变实际的中断处理。这就是中断系统采用软、硬件结合的好处</li>
<li><strong>中断响应用排队器</strong>硬件实现可以加快响应和断点现场保护，中断处理采用软的技术可以 供很大的灵活性，因此，中断系统的软、硬件功能的实质是中断处理程序软件和中断响应硬件的功能分配</li>
<li>为了改善性能，用软件实现的功能，可以部分改用硬件来实现</li>
</ul>
<h4 id="中断系统的软、硬件分配"><a href="#中断系统的软、硬件分配" class="headerlink" title="中断系统的软、硬件分配"></a>中断系统的软、硬件分配</h4><h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><p><strong>总线</strong>：用于互连计算机、CPU、存储器、I/O端口及外部设备、远程通信设备间<strong>信息传送通路的集合</strong></p>
<p>总线系统：总线与其相配合的<strong>附属控制电路</strong></p>
<p>按照信息传送功能、性能的不同，总线系统包括<strong>数据线</strong>、<strong>地址线</strong>、<strong>时序</strong>和<strong>中断信号</strong>等控制/状态线、<strong>电源线</strong>、地线以及<strong>备用线</strong>等</p>
<ul>
<li>数据线的根数决定同时传送的<strong>数据位数</strong>，即数据通路宽度</li>
<li>地址线的根数决定<strong>直接寻址的范围</strong></li>
<li>控制/状态线决定总线的<strong>功能和使用能力</strong></li>
<li>备用线用于<strong>系统功能的扩充</strong></li>
</ul>
<h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><h5 id="按系统中的位置"><a href="#按系统中的位置" class="headerlink" title="按系统中的位置"></a>按系统中的位置</h5><ul>
<li>芯片级：CPU芯片内的总线;</li>
<li>板级：连接插件版内的各组件，局部总线、内部总线;</li>
<li>系统级：系统间或主机与I/O接口或设备之间的总线</li>
</ul>
<h5 id="按信息传送方向"><a href="#按信息传送方向" class="headerlink" title="按信息传送方向"></a>按信息传送方向</h5><ul>
<li>单向传输</li>
<li>双向传输<ul>
<li>半双向：可沿相反方向传送，但同时只能向一个方向传送</li>
<li>全双向：可以同时向两个方向传送，速度快、造价高、结构复杂</li>
</ul>
</li>
</ul>
<h5 id="按使用方法"><a href="#按使用方法" class="headerlink" title="按使用方法"></a>按使用方法</h5><ul>
<li><p>专用总线：只连接<strong>一对物理部件</strong>的总线</p>
<ul>
<li>优点：<ul>
<li>多个部件可以同时收发信息，不争用总线，系统流量高</li>
<li>通信时不用指明源和目的，控制简单;</li>
<li>任何总线的失效只会使连接该总线的两个部件不能直接通信，但它们仍可以通过其他部件间接通信，因而系统可靠</li>
</ul>
</li>
<li>缺点：<ul>
<li>总线数多，总线数与部件数成平方倍关系增加</li>
<li>难以小型化、集成电路化</li>
<li>总线较长时，成本相当高</li>
<li>利用率低</li>
<li>不利于系统模块化</li>
</ul>
</li>
</ul>
</li>
<li><p>非专用总线：可以被多种功能或多个部件分时共享，同一时间只有一对部件可使用总线进行通信</p>
<ul>
<li><p>优点：</p>
<ul>
<li>总线数少、造价低</li>
<li>总线接口标准化，模块性强</li>
<li>可扩充能力强</li>
<li>部件的增加不会使电缆、接口和驱动电路激增</li>
<li>易用多重总线提高总线的带宽和可靠性，使故障弱化</li>
</ul>
</li>
<li>缺点：<ul>
<li>系统流量小，经常会出现争用总线的情况，降低效率，共享总线失效会导致系统瘫痪</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总线的控制方式"><a href="#总线的控制方式" class="headerlink" title="总线的控制方式"></a>总线的控制方式</h4><p>非专用总线上的多个设备或者部件同时请求使用总线，使得由<strong>总线控制机构</strong>按某种优先次序裁决，保证只有一个高优先级的申请者首先取得对总线的使用权</p>
<p>集中式控制：总线控制机构基本集中在一起，不论是在连接到总线的一个部件中，还是在单独的硬件中</p>
<p>分布式控制：总线控制逻辑分散在连到总线的各个部件间</p>
<h5 id="集中式控制"><a href="#集中式控制" class="headerlink" title="集中式控制"></a>集中式控制</h5><p>优先次序的确定可以有<strong>串行连接</strong>、<strong>定时查询</strong>和<strong>独立请求</strong>三种不同的方式，也可以是它们的结合。采用何种方式取决于控制线数目、总线分配速度、灵活性、可靠性等因素的综合考虑</p>
<ol>
<li><p><strong>集中式的串行连接</strong></p>
<ul>
<li>所有部件都经公共的“总线请求”线向总线控制器发出请求，</li>
<li>当“总线忙”信号未建立，总线空闲，请求响应，送出“总线可用”信号，串行通过每个部件。</li>
<li>如某个部件接收到“总线可用”信号但未发送请求，则送往下一个部件，如该部件发出过请求，则停止信号</li>
<li>建立“总线忙”，清除请求信号，准备数据传送</li>
<li>数据传送期间，“总线忙”维持“总线可用”的建立</li>
<li>传送完，去除“总线忙”和“总线可用”信号</li>
</ul>
<p>优先次序是由“总线可用”线所接部件的物理位置决定的</p>
<p>优点：</p>
<ul>
<li>选择算法简单，控制总线少(3根)</li>
<li>部件增减容易，可扩充性好</li>
<li>逻辑简单，容易通过重复设置提高可靠性</li>
</ul>
<p>缺点：</p>
<ul>
<li>对“总线可用”线及其有关电路的失效很敏感</li>
<li>优先级是线连固定，不能由程序改变，灵活性差增加</li>
<li>“总线可用”信号顺序脉动地通过各个部件，限制总线的分配速度</li>
<li>受总线长度的限制，增减或移动设备受到限制</li>
</ul>
</li>
<li><p><strong>集中式定时查询</strong></p>
<ul>
<li>总线上的每个部件通过“总线请求”线发出请求</li>
<li>若总线处于空闲，“总线忙”未建立，总线控制器收到请求后，让计数器开始计数，定时查询各部件以确定是哪个部件发出请求</li>
<li>查询到请求发出部件，该部件建立“总线忙”，计数器停止计数，控制器停止查询</li>
<li>去除该部件的“总线请求”，让该部件获得总线使用权，传送完成后去除“总线忙”</li>
<li>如果总线分配前计数器清0，同串行链接；如果总线分配前不清0，则是循环优先级；如果总线分配前计数器设置某个初值，则指定这个部件为最高优先级;如果总线分配前将部件号重新设置一下，则可以指定各部件为任意所希望的优先级</li>
</ul>
<p>优点：</p>
<ul>
<li>因计数器初值，部件号均可由程序设定，优先次序可由程序控制，灵活性强</li>
<li>可靠性高</li>
</ul>
<p>缺点：</p>
<ul>
<li>控制线数较多，需2+log2N,扩展性稍差</li>
<li>控制较为复杂</li>
<li>速度取决与计数信号的频率和部件数，不能很高</li>
</ul>
</li>
<li><p><strong>集中式独立请求</strong></p>
<ul>
<li>共享总线的每个部件各自都有一对“总线请求”和“总线准许”线</li>
<li>总线控制器根据某种算法对同时送来的多个请求进行仲裁</li>
</ul>
<p>优点：</p>
<ul>
<li>总线分配速度快，不用查询</li>
<li>可以使用程序可控的预订方式、自适应方式、循环方式或它们的混和方式灵活确定下一个使用总线的部件</li>
<li>能方便地隔离失效部件的请求</li>
</ul>
<p>缺点：</p>
<ul>
<li>控制线数量多，N个设备必须有2N+1根控制线</li>
<li>总线控制器复杂</li>
</ul>
</li>
</ol>
<h4 id="总线的通讯方式"><a href="#总线的通讯方式" class="headerlink" title="总线的通讯方式"></a>总线的通讯方式</h4><h5 id="同步通讯"><a href="#同步通讯" class="headerlink" title="同步通讯"></a>同步通讯</h5><p>两个部件的信息是通过<strong>定宽</strong>、<strong>定距</strong>的<strong>系统时标</strong>进行同步的</p>
<ul>
<li>传送率高，受总线长度影响小</li>
<li>时钟在总线上的时滞可能会造成同步误差，时钟线上的干扰信号容易引起误同步</li>
<li>为提高可靠性，目的部件需要对数据是否正确接受予以回答：正常时不回答，出错时在同步时间片过去后向源部件发送出错信号，使之重发数据</li>
</ul>
<h5 id="异步通讯（图什么意思）"><a href="#异步通讯（图什么意思）" class="headerlink" title="异步通讯（图什么意思）"></a>异步通讯（图什么意思）</h5><ul>
<li>单向源(目)控制：通讯过程只由目的或源部件中的一个控制。<ul>
<li>优点：简单、高速</li>
<li>缺点：没有来自目的部件的信息指明数据传送是否有效;不同速度之间的部件之间通信比较复杂;部件内需设置缓冲器以缓冲来不及处理的数据;效率低，高速部件难以发挥效能;要求“数据准备”信号干扰要小，否则易误认成有效信号</li>
</ul>
</li>
<li>双向控制：由源和目的双方控制<ul>
<li>单向控制的缺点是不能保证下一数据传送之前让所有数据线和控制线的电平信号恢复成初始状态，从而可能造成错误状态</li>
<li>异步双向互锁方式虽然增加了信号沿总线来回传送的次数，使控制硬件变得更加复杂<ul>
<li>异步互锁可以解决在下一个“数据准备”到达目的端时，上一个“数据接受”仍处于高电平<ul>
<li>适应各种不同速度的I/O设备，保证数据传送的正确性，且有较高的数据传送速率(其速率为源部件和目的部件中相对较低的速率来通信，比同步方式总是以所有部件中最低的速率来通信的效率要高)        </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据宽度与总线线数"><a href="#数据宽度与总线线数" class="headerlink" title="数据宽度与总线线数"></a>数据宽度与总线线数</h4><h5 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h5><p>数据宽度：I/O设备取得I/O总线后所<strong>传送数据的总量</strong>，</p>
<p>数据通路宽度：数据<strong>总线的物理宽度</strong>(即一个时钟周期所传送的数据量)</p>
<p><strong>一个数据宽度可能需要多个数据周期才能完成</strong></p>
<p>数据宽度类型</p>
<ul>
<li><strong>单字(单字节)宽度</strong>适合输入机、打印机等低速设备</li>
<li><strong>定长块宽度</strong>适合于磁盘等高速设备</li>
<li><strong>可变长块宽度</strong>适合于高优先级的中高速磁带、磁盘等设备</li>
</ul>
<h5 id="总线的线数"><a href="#总线的线数" class="headerlink" title="总线的线数"></a>总线的线数</h5><ul>
<li>总线线数越多，成本越高，干扰越大，可靠性越低，占用空间也越大，当然，传送速度和流量也越高</li>
<li>总线长度越长，成本越高，干扰越大，波形畸变越严重，可靠性越低</li>
<li>因此，总线增长，线数就应该越少</li>
<li>总线线数可以通过用线的组合、编码，以及并/串—串/并转换来实现，但一般会降低总线的流量</li>
</ul>
<h3 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h3><h4 id="输入输出系统概述"><a href="#输入输出系统概述" class="headerlink" title="输入输出系统概述"></a>输入输出系统概述</h4><p>输入输出系统：包括<strong>输入输出设备</strong>、<strong>设备控制器</strong>及与<strong>输入输出操作有关的硬件</strong></p>
<p>输入输出系统：计算机系统中处理机与主存储器之外的部分</p>
<p><strong>输入输出系统</strong>是处理机与外界进行数据交换的通道。</p>
<p>输入输出设备：与处理机有关的、除人以外的各种设备</p>
<h5 id="输入输出系统的特点"><a href="#输入输出系统的特点" class="headerlink" title="输入输出系统的特点"></a>输入输出系统的特点</h5><ul>
<li>异步性：<ul>
<li>输入输出设备通常不使用统一的中央时钟，各个<strong>设备按照自己的时钟工作</strong>，但又要在某些时刻接受处理机的控制</li>
<li>处理机与外围设备之间，外围设备与外围设备之间能够<strong>并行工作</strong></li>
</ul>
</li>
<li>实时性：<ul>
<li>对于一般外部设备：可能丢失数据，或造成外围设备工作的错误</li>
<li>对于实时控制计算机系统，如果处理机提供的服务不及时，可能造成巨大的损失</li>
<li>对于处理机本身的硬件或软件错误：如电源故障、数据校验错、页面失效、非法指令、地址越界等，处理机须及时处理</li>
<li>对不同类型的设备，必须具有与设备相配合的多种工作方式</li>
</ul>
</li>
<li>与设备无关性：<ul>
<li>独立于具体设备的标准接口。例如，串行接口、并行接口、SCSI(SmallComputer System Interface)接口等</li>
<li>计算机系统的使用者，在需要更换外围设备时，各种不同型号，不同生产厂家的设备都可以直接通过标准接口与计算机系统连接</li>
<li>处理机采用统一的硬件和软件对品种繁多的设备进行管理</li>
<li>某些计算机系统已经实现了即插即用技术</li>
</ul>
</li>
</ul>
<h4 id="通道处理机的工作原理和流量设计"><a href="#通道处理机的工作原理和流量设计" class="headerlink" title="通道处理机的工作原理和流量设计"></a>通道处理机的工作原理和流量设计</h4><h5 id="通道处理机工作原理"><a href="#通道处理机工作原理" class="headerlink" title="通道处理机工作原理"></a>通道处理机工作原理</h5><ul>
<li>用户一般不能直接安排输入/输出操作，而通过程序状态的切换来实现输入输出，以保证系统的可靠性</li>
<li>中央处理机用来控制外部设备操作用的输入/输出指令称为<strong>管态指令</strong></li>
<li>用户在<strong>目态程序</strong>中不能直接使用<strong>管态指令</strong>，只能使用要求输入/输出的广义指令，然后进入相应的管理程序执行输入/输出的管态指令。</li>
</ul>
<h5 id="启动I-O指令"><a href="#启动I-O指令" class="headerlink" title="启动I/O指令"></a>启动I/O指令</h5><p>选择通道；选择子通道；选取通道指令；选取控制器、设备；向设备发送启动命令；启动成功，则结束通道开始选择设备期，进入通道程序，并退出管态程序，返回目态程序</p>
<h5 id="通道数据传送方式"><a href="#通道数据传送方式" class="headerlink" title="通道数据传送方式"></a>通道数据传送方式</h5><ul>
<li><p><strong>字节多路</strong>：适合于连接像光电机的字符类低速设备</p>
<ul>
<li>送<strong>一个字符</strong>(字节)的时间很短，但字符(字节)间的等待时间很长</li>
<li>以字节交叉方式轮流为多台低速设备服务</li>
<li>可有多个子通道，独立执行通道命令，并行操作</li>
</ul>
</li>
<li><p><strong>数组多路</strong>：适合于连接多台像磁盘的高速设备</p>
<ul>
<li>传送速率很高，但传送开始前的<strong>寻址辅助操作时间很长</strong></li>
<li>成组交叉方式，传送完K个字节数据后重新选择下一个设备</li>
</ul>
</li>
<li><p><strong>选择通道</strong>：适合于连接优先级高的磁盘等高速设备</p>
<ul>
<li><p>独占通道</p>
</li>
<li><p>在数据传送期内只选择一次设备</p>
<p>​    </p>
</li>
</ul>
</li>
</ul>
<h5 id="通道流量的设计"><a href="#通道流量的设计" class="headerlink" title="通道流量的设计"></a>通道流量的设计</h5><p>通道流量是通道在数据传送期间内，单位时间传送的字节数。它能达到的最大流量称为通道极限流量</p>
<p>通道的极限流量与其工作方式、数据传送期内<strong>选择一次设备的时间</strong> $T_S$ 和<strong>传送一个字节的时间</strong> $T_D$长短相关</p>
<ol>
<li><p>字节多路的通道极限流量</p>
<p>每选择一台设备只传送一个字节   </p>
<p> $f_{max \cdot byte} = \frac {1}{T_S+T_D}$ </p>
</li>
<li><p>数组多路的通道极限流量</p>
<p>每选择一台设备就能传送完K个字节，如果要传N个字节，就要分N/K次传送，每次传送选择一次设备</p>
<p>$f_{max\cdot block} = \frac {K}{T_S+KT_D} = \frac{1}{\frac {T_S}{K} + T_D}$ </p>
</li>
<li><p>选择通道的通道极限流量</p>
<p>每选择一台设备就把N个字节全部传送完</p>
<p>$f_{max \cdot select} = \frac {N}{T_S+NT_D} = \frac{1}{\frac{T_S}{N}+T_D}$ </p>
</li>
</ol>
<p>如果通道的$T_S$ 、$T_D $确定时，且N&gt;K时，有 </p>
<p>$f<em>{max\cdot select} \ge f</em>{max\cdot block} \ge f_{max\cdot byte}$</p>
<p>设备要求通道的实际最大流量与三种通道的工作方式有关</p>
<ul>
<li><p>字节多路是该通道连接各设备的字节传送速率之和</p>
<ul>
<li>$f_{byte\cdot j} = \sum ^{p<em>j}</em>{i=1} f_{i\cdot j}$</li>
</ul>
</li>
<li><p>数组多路和选择通道是所连接各设备的字节传送速率中之最大者</p>
<ul>
<li>$f<em>{block\cdot j} = max f</em>{i\cdot j} , f<em>{select\cdot j} = max f</em>{i\cdot j}   i = 1,…,p_j$ </li>
</ul>
<p>$j$：通道编号  $f_{i,j}$ ：为第$j$号通道上所挂的第$i$台设备的字节传送速率</p>
<p>$p_j$：为第$j$号通道上所连接的设备的台数</p>
</li>
<li><p>为了保证第j号通道上所挂设备在满负荷的最坏情况下都不丢失信息，必须使设备要求通道的实际最大流量不超过通道的极限流量</p>
<p>$f<em>{byte\cdot j}\le f</em>{max\cdot byte\cdot j}$</p>
<p>…</p>
</li>
<li><p>上述流量设计的基本条件只保证了宏观上设备不丢失数据，并不能保证每一个局部时刻都不丢失信息</p>
</li>
<li><p>通常高速设备请求的响应优先级比较高，高速设备频繁发出请求并总是优先得到响应和处理，使得速率较低的设备长期得不到通道而丢失信息。</p>
</li>
<li><p>在设备或设备控制器中设置一定容量的缓冲器来缓冲得不到及时处理的数据，或是通过动态 高低速设备的响应优先级</p>
</li>
</ul>
<h2 id="第四章-存储体系"><a href="#第四章-存储体系" class="headerlink" title="第四章 存储体系"></a>第四章 存储体系</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="存储体系及其分支"><a href="#存储体系及其分支" class="headerlink" title="存储体系及其分支"></a>存储体系及其分支</h4><p><strong>存储体系</strong>：在构成存储系统的几种不同的存储器（M~1~-M~n~）之间，配上辅助软件或硬件，使之从应用程序员的角度看，在逻辑上是一个整体（对应用程序员透明）</p>
<p>等效访问速度接近$M_1$，容量接近于$M_n$，每位价格接近于$M_n$。</p>
<h5 id="主存—辅存存储层次（容量）"><a href="#主存—辅存存储层次（容量）" class="headerlink" title="主存—辅存存储层次（容量）"></a>主存—辅存存储层次（容量）</h5><p>虚拟存储器：由于主存容量无法满足需求，因此在主存和辅存之间，增设辅助的软、硬件设备，使它们形成统一整体</p>
<h5 id="Cache—主存存储层次（速度）"><a href="#Cache—主存存储层次（速度）" class="headerlink" title="Cache—主存存储层次（速度）"></a>Cache—主存存储层次（速度）</h5><p>由于主存速度满足不了要求，因而在CPU和主存之间增设高速、小容量、每位价格较高的Cache，用辅助硬件将其和主存构成整体，称为“Cache-主存存储层次”</p>
<h5 id="多级存储层次"><a href="#多级存储层次" class="headerlink" title="多级存储层次"></a>多级存储层次</h5><p>从CPU角度看，整个存储体系是一个整体，其速度接近于$M_1$，容量接近于$M_n$，每位价格接近于$M_n$</p>
<h4 id="存储体系构成依据"><a href="#存储体系构成依据" class="headerlink" title="存储体系构成依据"></a>存储体系构成依据</h4><p>当CPU需要某个地址的内容的时候，总是希望该内容在速度最快的$M_1$当中</p>
<p>未来被访问信息的可预知性：</p>
<ul>
<li>时间局部性：在最近的未来所要用到的信息很可能是现在正在使用的信息</li>
<li>空间局部性：在最近的未来所要用到的信息很可能是何现在正在使用的信息在程序空间上是邻近的</li>
</ul>
<p>不必将整个程序整体存入$M_1$，只需要将近期访问过的块（或页）调入$M_1$</p>
<p>预知的准确性是存储层次设计好坏的主要标志，很大程度取决于所用的算法和地址映像变换方式</p>
<h4 id="存储体系的性能参数（老师PDF中无）"><a href="#存储体系的性能参数（老师PDF中无）" class="headerlink" title="存储体系的性能参数（老师PDF中无）"></a>存储体系的性能参数（老师PDF中无）</h4><h4 id="存储器层次结构设计的问题"><a href="#存储器层次结构设计的问题" class="headerlink" title="存储器层次结构设计的问题"></a>存储器层次结构设计的问题</h4><ul>
<li><strong>映像方式</strong>：低层存储器的块<strong>按什么规则</strong>装入高层存储器</li>
<li><strong>映像机构</strong>：映像方式的实现，如何识别和查找高层存储器的信息块</li>
<li><strong>替换策略</strong>：访问失效后，如何淘汰信息块，而换新块</li>
<li><strong>写策略</strong>：写操作发生时采用何种策略以<strong>保持相邻两级存储器中数据的一致性</strong>，发生写操作失效时是否将背写的块从低层存储器取入高层存储器</li>
</ul>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h4 id="虚拟存储器的管理方式"><a href="#虚拟存储器的管理方式" class="headerlink" title="虚拟存储器的管理方式"></a>虚拟存储器的管理方式</h4><p>虚拟存储器通过<strong>地址映像表</strong>机构来实现在主存中的定位。将程序分割成<strong>段</strong>或者<strong>页</strong>，用相应的映像表指明该程序某个段或页是否已装入主存；</p>
<ul>
<li>若已装入，指明在主存中的<strong>起始地址</strong></li>
<li>若未装入，去辅存中调入段或者页，装入主存后再在映像表中建立号程序空间与实存空间的地址映像关系</li>
</ul>
<p>程序执行时先<strong>查映像表</strong>，将程序<strong>虚地址</strong>变成<strong>实地址</strong>后再访问主存</p>
<p>根据存储映像算法的不同，有多种不同的存储管理方式的虚拟存储器，其中主要由段式、页式、段页式</p>
<h5 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h5><p><strong>段</strong>是程序逻辑独立的模块，每个段从0开始编址。当某个段调入主存时，只要系统赋予该段一个基址，就可以由该<strong>基址</strong>和单元的<strong>段内地址</strong>形成主存内的<strong>实际地址</strong>。将主存按段分配的存储管理方式称为段式管理</p>
<p>优点：</p>
<ul>
<li>使大程序分模块编址，使得多个程序员并行编程，缩短编程时间，在执行或者编译过程中对不断变化的变长短也便于处理</li>
<li>便于多道程序共用已在主存内的程序和数据</li>
<li>由于各段是按其逻辑特点组合的，因而容易以段为单位实现存储保护</li>
</ul>
<p>缺点：</p>
<ul>
<li>段长度完全取决于自身，主存中起点随意，给调入段分配主存带来了困难</li>
<li>需要构造复杂的段映像表，还需要为主存系统建立一个实主存管理表，包括占用区域表和可用区域表</li>
</ul>
<h5 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h5><p>页式虚拟存储器把<strong>虚拟空间</strong>机械地划分成一个个<strong>固定大小的块</strong>，每块称为一页，把<strong>主存储器的地址</strong>空间也按虚拟地址空间<strong>同样的大小</strong>划分为页。页是一种<strong>逻辑上的划分</strong>，可以由系统任意指定。</p>
<p><strong>虚拟地址空间</strong>中的也称为<strong>虚页</strong>，主存地址空间中的页称为<strong>实页</strong></p>
<p>每个用户使用<strong>基址寄存器</strong>（CPU内），通过用户号U可以直接找到与该用户程序相对应的基址寄存器，从这个基址寄存器中读出<strong>页表起始地址</strong>。访问这个页表地址，把得到的主存页号P与虚地址中的业内偏移直接拼接起来得到主存实地址。</p>
<ul>
<li>页表项简单，查找速度快；</li>
<li>页面大小固定不利于系统的效率；</li>
<li>页式管理在存储空间较大时，由于页表过大，效率降低；</li>
<li>存储空间的保护困难</li>
</ul>
<p>优点：</p>
<ul>
<li>主存储器的利用率比较高</li>
<li>页表相对比较简单</li>
<li>地址变换的速度比较快</li>
<li>对磁盘的管理比较容易</li>
</ul>
<p>缺点：</p>
<ul>
<li>程序的模块化性能不好</li>
<li>页表很长，需要占用很大的存储空间</li>
</ul>
<h5 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h5><ul>
<li><p>页式：对应用程序员完全透明，由系统划分。</p>
<ul>
<li>硬件较少，地址变换速度快，</li>
<li>调入操作简单，静态连接程序;</li>
</ul>
</li>
<li><p>段式：段独立，有利于程序员灵活实现段的连接、段的扩大/缩小和修改，而不影响其他段，易于针对其特定类型实现保护，把共享的程序或数据单独构成一个段，从而易于实现多个用户、进程对共用段的管理，动态连接程序;</p>
</li>
<li><p>段页式：把<strong>实存</strong>机械地等分成固定大小的<strong>页</strong>，<strong>程序</strong>按模块<strong>分段</strong>，每个段又分成与主存页面大小相同的页。</p>
</li>
</ul>
<h4 id="页式虚拟存储器的构成"><a href="#页式虚拟存储器的构成" class="headerlink" title="页式虚拟存储器的构成"></a>页式虚拟存储器的构成</h4><h5 id="地址映像和变换"><a href="#地址映像和变换" class="headerlink" title="地址映像和变换"></a>地址映像和变换</h5><ul>
<li><strong>地址映像</strong>：将每个<strong>虚拟存储单元</strong>按某种规则装入实存，即建立多用户虚地址$N_s$与实存地址$n_p$之间的对应关系。</li>
<li><strong>地址变换</strong>：程序按照这种映像关系装入实存后，在执行时，多用户虚拟地址$N_s$如何变换成对应的实地址$n_p$</li>
<li><strong>页面冲突</strong>：发生两个以上的虚页想要进入主存同一个页面位置而产生页面争用现象。</li>
</ul>
<h5 id="地址变化规则"><a href="#地址变化规则" class="headerlink" title="地址变化规则"></a>地址变化规则</h5><p>减少实页冲突概率，硬件少、成本低，实现方便、变化速度快</p>
<p>由于虚拟空间远远大于实存空间，因此页式虚拟存储器常采用全相联映像</p>
<p><strong>全相联映像</strong>（页表法）：任何虚页可以映像装入到任何实页位置。<strong>冲突概率最低</strong></p>
<p><strong>相联目录表法</strong>：把页表压缩成只存放已装入主存的那些<strong>虚页号</strong>与<strong>实页位置$n_v$</strong>的对应关系</p>
<p>比较的表格</p>
<h5 id="页面替换算法-P125"><a href="#页面替换算法-P125" class="headerlink" title="页面替换算法(P125)"></a>页面替换算法(P125)</h5><ul>
<li><p>页面替换发生时间：</p>
<p>当发生页面失效时，要从磁盘中调入一页到主存。如果主存所有页面都已经被占用，必须从主存储器中淘汰一个不常使用的页面，以便腾出主存空间来存放新调入的页面</p>
</li>
<li><p>替换算法的确定：</p>
<ul>
<li>主存命中率</li>
<li>是否便于实现，软、硬件成本</li>
</ul>
</li>
<li><p>页面替换算法使用的场合</p>
<ul>
<li>虚拟存储器中，主存页面的替换，一般用软件实现</li>
<li>Cache块替换一般用硬件实现</li>
<li>虚拟存储器的快慢表中，块表存储字的替换用硬件实现</li>
<li>虚拟存储器中，用户基地址寄存器的替换用硬件实现</li>
</ul>
</li>
<li><p>随机算法（Random，RAND）：用软的或硬的随机数产生器来形成主存中被替换的页号</p>
<ul>
<li>简单，易于实现</li>
<li>没有利用历史信息</li>
<li>命中率低，很少使用</li>
</ul>
</li>
<li><p>先进先出算法（First-In-First-Out，FIFO）：选择最早装入主存的页作为被替换的页</p>
<ul>
<li>操作系统为主存页面表中给每个实页配置一个计算器字段，每当一页装入时，让该页的计数器清零，其他已装入页的计数器都加“1”</li>
<li>需要替换时，计数器值最大的页号即最先进入主存而且现在准备被替换掉的页号</li>
<li>虽然使用历史信息，但是不一定反映程序的局部性</li>
</ul>
</li>
<li><p>近期最少使用算法（Least Recently Used，LRU）：选择近期最少访问的页被作为替换的页</p>
<ul>
<li>配备计数器</li>
<li>比较正确反映程序的局部性</li>
</ul>
</li>
<li><p>优化替换算法（Optimal Replacement Algorithm，OPT）：在时刻t找出主存中每个页<strong>将要用到时刻$t_i$</strong>，然后选择其中$t_i-t$最大页作为替换页。</p>
<ul>
<li>理想的算法</li>
</ul>
</li>
</ul>
<h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><h4 id="工作原理和基本结构"><a href="#工作原理和基本结构" class="headerlink" title="工作原理和基本结构"></a>工作原理和基本结构</h4><p>用以弥补主存速度的不足，在处理机和主存之间设置一个高速、小容量的Cache，构成Cache—主存存储层次。CPU来看，速度接近于Cache，容量却是主存的</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>图</p>
<h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><ul>
<li>把<strong>主存</strong>和<strong>Cache</strong>机械等分成相同大小的块（行），块比页小得多</li>
<li>除Cache到处理机的通路外，还设有主存到处理机的通路</li>
<li>处理机到Cache是字传送，主存到Cache是块传送</li>
</ul>
<h5 id="Cache设计要素"><a href="#Cache设计要素" class="headerlink" title="Cache设计要素"></a>Cache设计要素</h5><ul>
<li><strong>Cache</strong>和<strong>CPU</strong>是同类型的半导体器件</li>
<li>访问<strong>Cache</strong>时间是访问<strong>主存</strong>时间的1/4到1/10；</li>
<li>Cache在物理位置上<strong>靠近CPU</strong>，不在主存，减少传输延迟</li>
<li><strong>Cache-主存</strong>间的地址映像和变换，以及替换、调用算法用硬件实现</li>
</ul>
<h4 id="地址映像与变换"><a href="#地址映像与变换" class="headerlink" title="地址映像与变换"></a>地址映像与变换</h4><h5 id="地址映像"><a href="#地址映像" class="headerlink" title="地址映像"></a>地址映像</h5><p>将每个主存块按某种规则装入Cache，并建立主存地址与Cache地址之间的对应关系</p>
<h5 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h5><p>主存块按照映像关系转入Cache后，每次访问Cache如何将主存地址变换成Cache地址</p>
<h5 id="选取地址映像方法考虑的主要因素"><a href="#选取地址映像方法考虑的主要因素" class="headerlink" title="选取地址映像方法考虑的主要因素"></a>选取地址映像方法考虑的主要因素</h5><ul>
<li>地址变换的硬件容易实现</li>
<li>地址变换的速度要快</li>
<li>主存空间利用率要高</li>
<li>发生块冲突的概率要小</li>
</ul>
<h5 id="全相联映像与变换"><a href="#全相联映像与变换" class="headerlink" title="全相联映像与变换"></a>全相联映像与变换</h5><p>主存中的任意一块都可以映像到Cache中任意一块。</p>
<p>目录表硬件方式实现</p>
<p><strong>相联目录表法</strong>（主存地址到Cache地址映射）</p>
<p>特点：冲突概率低、空间利用率高、地址变换快</p>
<p>缺点：目录表代价大；查表速度难提高</p>
<h5 id="直接映像与变换"><a href="#直接映像与变换" class="headerlink" title="直接映像与变换"></a>直接映像与变换</h5><ul>
<li><p>映像规则</p>
<p>主存中一块只能映像到Cache的一个特定的块中</p>
<p>主存第i块只能映像到  $i\mod 2^{n_{cb}}$块位置上</p>
<p><strong><u><em>整个Cache地址与主存地址地位部分完全相同</em></u></strong></p>
</li>
<li><p>区号存储器</p>
<p>存放Cache中每一块位置目前被主存中的哪个区的块所占用的区号</p>
</li>
<li><p>优点</p>
<p>硬件实现简单，不需要相联访问存储器</p>
<p>访问速度较快，实际上不做地址变换</p>
</li>
<li><p>缺点</p>
<p>块的冲突率较高</p>
<p>出现大量空闲块</p>
</li>
<li><p>很少使用</p>
</li>
</ul>
<h5 id="组相联映像与变换"><a href="#组相联映像与变换" class="headerlink" title="组相联映像与变换"></a>组相联映像与变换</h5><p>映像规则：<strong>各组之间直接映像，组内各块全相联映像</strong></p>
<p>将<strong>Cache空间</strong>和<strong>主存空间</strong>都分成组，每组S块（$S = 2^s$）；将Cache分成Q组（$Q=2^q$），整个Cache作为一个区。主存分成和Cache同样大小的$2^{n_d}$个区，每个区包含Q组</p>
<p>变换 ： 图</p>
<p>优点：</p>
<ul>
<li>块冲突概率低</li>
<li>块的利用率大幅度提高</li>
<li>块失效率明显降低</li>
</ul>
<p>缺点：实现难度和造价要比直接映像方式高</p>
<p>地址变换过程：用主存地址的组号G按地址访问块表存储器。把读出来的一组<strong>区号</strong>与<strong>主存地址中区号和块号</strong>进行相联比较，如果有相等的，表示Cache命中；如果没有相等的，表示Cache没有命中</p>
<h5 id="段相联映像"><a href="#段相联映像" class="headerlink" title="段相联映像"></a>段相联映像</h5><p>映像规则：组间全相联，组内直接映像</p>
<h4 id="Cache存储器的LRU替换算法的硬件实现（不在老师PDF）"><a href="#Cache存储器的LRU替换算法的硬件实现（不在老师PDF）" class="headerlink" title="Cache存储器的LRU替换算法的硬件实现（不在老师PDF）"></a>Cache存储器的LRU替换算法的硬件实现（不在老师PDF）</h4><h4 id="Cache存储器的透明性及性能分析"><a href="#Cache存储器的透明性及性能分析" class="headerlink" title="Cache存储器的透明性及性能分析"></a>Cache存储器的透明性及性能分析</h4><h5 id="Cache存储器的透明性分析及其解决方法"><a href="#Cache存储器的透明性分析及其解决方法" class="headerlink" title="Cache存储器的透明性分析及其解决方法"></a>Cache存储器的透明性分析及其解决方法</h5><p>由于Cache存储器的<strong>地址变换</strong>和<strong>块替换算法</strong>全由<strong>硬件实现</strong>，因此Cache— 主存存储器层次对应用程序员和系统程序员都是透明的</p>
<p>造成Cache与主存不一致的原因：<strong>多CPU和IO设备共享主存，不共享Cache</strong></p>
<p>多处理机共享Cache的难度</p>
<ul>
<li>Cache的容量必须大大增加</li>
<li>共享Cache的物理位置很难同时靠近多个CPU，延时会增加</li>
<li>Cache的频宽难以支持两个以上的CPU同时访问</li>
</ul>
<p>Cache与主存不一致的两种情况</p>
<ul>
<li>由于CPU写Cache，<strong>没有立即写主存</strong></li>
<li>由于IO处理机或IO设备<strong>写主存</strong></li>
</ul>
<p>写回法（抵触修改法，WB）：在CPU执行写操作时，信息<strong>只写回Cache</strong>，仅当需要<strong>被替换</strong>时，才将已<strong>被写入</strong>过的Cache块送回主存再调入新块</p>
<p>写直达法（直达法，WT）：利用Cache—主存存储层次在<strong>处理机和主存之间的直接通路</strong>，每当处理机写入Cache同时，也通过此通路直接写入主存。</p>
<p>优缺点比较：</p>
<ul>
<li>可靠性：写直达法由于写回法</li>
<li>与主存通信量：写回法少于写直达法</li>
<li>控制复杂性：写直达法比写回法简单</li>
<li>硬件实现的代价：写回法要比写直达法好</li>
<li>采用何种算法与适用场合有关：单处理机（节省成本）用写回法；共享多处理机（保证信息交换可靠）用写直达法</li>
</ul>
<p>共享主存多CPU系统存在的问题：<strong>仅靠直写法不能保证同一主存单元在各Cache中对应内容一致</strong></p>
<h5 id="共享主存多CPU系统保持内容一致性解决方法（-）"><a href="#共享主存多CPU系统保持内容一致性解决方法（-）" class="headerlink" title="共享主存多CPU系统保持内容一致性解决方法（**）"></a>共享主存多CPU系统保持内容一致性解决方法（**）</h5><ul>
<li>播写法<ul>
<li>任何处理机要写入Cache时，写入自己Cache的目标块和主存中</li>
<li><strong>播写</strong>所有Cache中有此单元的地方，或者让所有Cache中有此单元的块作废</li>
</ul>
</li>
<li>控制某些<strong>共享信息</strong>不得进入Cache<ul>
<li>如信号灯、作业队</li>
</ul>
</li>
<li>目录表法<ul>
<li>在CPU读、写Cache不命中时，先查主存中的目录表，以判定目标块是否在别的Cache内，以及是否正在被修改等</li>
</ul>
</li>
</ul>
<h4 id="P158-4-14"><a href="#P158-4-14" class="headerlink" title="P158 4-14"></a>P158 4-14</h4><h3 id="三级存储体系"><a href="#三级存储体系" class="headerlink" title="三级存储体系"></a>三级存储体系</h3><h2 id="第五章-标量处理机"><a href="#第五章-标量处理机" class="headerlink" title="第五章 标量处理机"></a>第五章 标量处理机</h2><p>加快机器语言解释的两种方式</p>
<ol>
<li><p>通过选<strong>用更高速的器件</strong>，采用<strong>更好的运算方法</strong>、提高指令内各微操作的<strong>并行程度</strong>，<strong>减少解释过程所需要的拍数</strong>，以加快每条指令的解释</p>
</li>
<li><p>指令流水线技术：通过控制机构采用同时<strong>解释两条</strong>、<strong>多条</strong>以至整段程序的控制方式，加快整个机器语言程序的解释</p>
<p><strong>重叠、流水</strong></p>
</li>
</ol>
<h3 id="重叠方式"><a href="#重叠方式" class="headerlink" title="重叠方式"></a>重叠方式</h3><h4 id="重叠原理与一次重叠"><a href="#重叠原理与一次重叠" class="headerlink" title="重叠原理与一次重叠"></a>重叠原理与一次重叠</h4><p>解释一条指令的微操作可归并成<strong>取指令</strong>、<strong>分析</strong>和<strong>执行</strong>三部分。</p>
<ul>
<li>取指令：按指令计数器的内容访主存，取出该指令送到<strong>指令寄存器</strong>。</li>
<li>指令的分析：对指令的<strong>操作码进行译码</strong>，按寻址方式和地址字段形成<strong>操作数真地址</strong>，并用此真地址去<strong>取操作数</strong>，为执行下一条指令还要形成<strong>下条指令地址</strong></li>
<li>指令的执行：对操作数进行<strong>运算、处理</strong>，或<strong>存储运算结果</strong></li>
</ul>
<h5 id="顺序解释（-）"><a href="#顺序解释（-）" class="headerlink" title="顺序解释（**）"></a>顺序解释（**）</h5><p>各指令之间顺序串行地进行，每条指令内部的各个微操作也顺序串行执行</p>
<ul>
<li>优点：控制简单，方便进行时序控制</li>
<li>缺点：利用率低，速度低</li>
</ul>
<h5 id="重叠解释"><a href="#重叠解释" class="headerlink" title="重叠解释"></a>重叠解释</h5><p><strong>在解释第$k$条指令的操作完成之前，就可开始解释第$k+1$条指令</strong>。虽然不能加快一条指令的实现，却能加快相邻两条以至整段程序的解释</p>
<h5 id="重叠解释的要求"><a href="#重叠解释的要求" class="headerlink" title="重叠解释的要求"></a>重叠解释的要求</h5><ol>
<li><p>解决访主存的<strong>冲突</strong></p>
<ul>
<li><strong>操作数</strong>和<strong>指令</strong>分别存放于两个<strong>独立编址</strong>且可<strong>同时访问的存储器</strong>中。有利于实现指令的保护，但是增加了主存总线控制的复杂性和软件设计的麻烦</li>
<li>采用多提交叉主存结构，第$k$条的操作数和第$k+1$条指令不在同一个个体内。存在一定局限性</li>
<li>增设采用<strong>先进先出</strong>方式工作的<strong>指令缓冲寄存器</strong>（指缓）趁主存有空时，预取下一条或下几条指令于指缓中</li>
</ul>
</li>
<li><p>解决”分析“和”执行“操作的并行</p>
<p>硬件上应有独立的<strong>指令分析部件</strong>和<strong>指令执行部件</strong>。例如，在加法运算中，单独的地址加法器用于地址计算，执行部件也有单独的加法器完成操作数相加</p>
</li>
<li><p>解决”分析“和”执行“操作控制上的同步</p>
<p>”分析“和”执行“所需要的时间不同，需要在硬件中解决<strong>控制上的同步问题</strong>，保证任何时候都只是”执行“与”分析“重叠执行</p>
<p>一次重叠：指令分析部件和执行部件任何时候都只有<strong>相邻两条指令</strong>在重叠解释</p>
<p>节省硬件，简化控制</p>
</li>
<li><p>解决指令间各种相关问题</p>
<ul>
<li>数据相关：在执行本条指令过程中，如果用到的<strong>指令、操作数、变址位移量</strong>等正是前面指令执行的<strong>结果</strong>，则必须<strong>等待前面的指令完成</strong>，并把<strong>结果写到主存或通用寄存器之后</strong>，本条指令才开始执行。<ul>
<li>指令相关</li>
<li>主存操作数相关 （延迟）</li>
<li>通用寄存器相关</li>
</ul>
</li>
<li>控制相关：由条件分支指令、转子程序指令、中断等引起的相关</li>
</ul>
</li>
</ol>
<h4 id="相关处理"><a href="#相关处理" class="headerlink" title="相关处理"></a>相关处理</h4><ol>
<li>转移指令的处理</li>
<li>指令相关的处理</li>
<li>主存空间数相关的处理</li>
<li>通用寄存器组相关的处理</li>
</ol>
<h3 id="流水方式"><a href="#流水方式" class="headerlink" title="流水方式"></a>流水方式</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>采用指缓的处理机中，一条指令的解释可以分解为“<strong>分析</strong>”和“<strong>执行</strong>”两个子过程。在指令分析器和指令执行部件的输出端各有一个<strong>锁存器</strong>，可以分别保存指令“分析”和指令“执行”的结果</p>
<p>指令串行—&gt;一次重叠，机器的最大吞吐率提高了一倍</p>
<p>流水将一条指令的解释<strong>分解为更多的子过程</strong></p>
<p>一次重叠：2个子过程</p>
<p>流水：多个子过程</p>
<h5 id="流水线特点"><a href="#流水线特点" class="headerlink" title="流水线特点"></a>流水线特点</h5><ul>
<li>流水线中处理的必须是<strong>连续任务</strong>，只有<strong>连续不断地提供任务</strong>才能充分发挥流水线的效率</li>
<li>把一个任务分解为<strong>几个有联系的子任务</strong>，<strong>每个子任务由一个专门的功能部件</strong>来实现</li>
<li>流水线中<strong>各段的时间应尽量相等</strong>，否则将引起“堵塞”、“断流”等</li>
<li>流水线需要有“<strong>装入时间</strong>”和“<strong>排空时间</strong>”</li>
</ul>
<h5 id="流水线分析"><a href="#流水线分析" class="headerlink" title="流水线分析"></a>流水线分析</h5><ul>
<li>如果把一条指令的解释分解成时间相等的m各子过程，则每隔 $\Delta t = T/m$就可以处理一条指令</li>
<li>流水的最大吞吐率取决于子过程的经过时间$\Delta t $，$\Delta t$ 越小，<strong>流水的最大吞吐率就越高</strong></li>
<li>部件之间设有锁存器，<strong>受同一时钟信号控制</strong>，以实现各子部件信息的同步推进</li>
<li>时钟信号<strong>不得低于速度最慢部件的经过时间与锁存器的存取时间之和</strong>，还要考虑时钟信号到各锁存器可能存在的延时</li>
<li>子过程的细分会<strong>因锁存器数增多而增大任务或指令流水流过流水线的时间</strong>，这在一定程度上会抵消子过程细分使吞吐率提高的好处</li>
<li>由于流水线从开始启动到流出第一个结果，需要经过一段流水线建立时间，因此<strong>实际吞吐率总是低于其最大吞吐率</strong></li>
</ul>
<h5 id="流水线的分类—多功能的链接方式"><a href="#流水线的分类—多功能的链接方式" class="headerlink" title="流水线的分类—多功能的链接方式"></a>流水线的分类—多功能的链接方式</h5><p><strong>静态流水线</strong>：在同一段时间内，多功能流水线中的各个功能只能<strong>按照一种固定的方式连接</strong>，实现一种固定的功能，只有当按照这种连接方式工作的所有任务<strong>都流出流水线之后</strong>，多功能流水线才能重新连接，以实现其他功能</p>
<p><strong>动态流水线</strong>：在同一段时间内，多功能流水线中的各段可以按照不同的方式连接，在各个功能部件之间不发生冲突的前提下，<strong>同时执行多种功能</strong></p>
<h5 id="流水线的分类—是否有反馈信号"><a href="#流水线的分类—是否有反馈信号" class="headerlink" title="流水线的分类—是否有反馈信号"></a>流水线的分类—是否有反馈信号</h5><p>按照流水线的各个功能段之间是否有反馈信号，可以把流水线分为<strong>线性流水线</strong>和<strong>非线性流水线</strong></p>
<ul>
<li>线性：每个流水段都流过一次，且仅流过一次，通常<strong>只完成一种固定的功能</strong></li>
<li>非线性：在流水线的某些流水段之间有<strong>反馈回路或前馈回路</strong> </li>
</ul>
<h4 id="标量流水线的主要性能"><a href="#标量流水线的主要性能" class="headerlink" title="标量流水线的主要性能"></a>标量流水线的主要性能</h4><h5 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h5><p>吞吐率：<strong>单位时间</strong>内<strong>流水线所完成的任务数量</strong>或输出的结果数量</p>
<p>若各个子过程经过的时间都是$\Delta t<em>2$，则最大吞吐率为： $T</em>{p_{max}} = 1/\Delta t_2$ </p>
<p>若各个子过程进行的工作不同，所经过的时间也不一定相同，所以在子过程之间设置接口锁存器，让各个锁存器都受同一时钟的同步 $T<em>{p</em>{max}} = \frac {1}{max{\Delta t_1,\Delta t_2 , \Delta t_3 ,\Delta t_4}}$ </p>
<p>受限于流水线中最慢子过程经过的时间。流水线中经过最长时间的子过程称为瓶颈子过程</p>
<p>消除瓶颈的方法</p>
<ul>
<li>细分</li>
<li>瓶颈段并联</li>
</ul>
<h5 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h5><p>指<strong>流水线的速度</strong>与<strong>等效的非流水线</strong>的速度之比</p>
<p>$T_{非流水} = n <em> m </em> \Delta t_0$</p>
<p>$S<em>p = \frac {T</em>{非流水}}{T} = \frac{nm\Delta t_0}{m\Delta t_0 + (n-1)\Delta t_0} = \frac {m}{1+\frac{m-1}{n}}$ </p>
<h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>指流水线中的<strong>设备实际使用时间</strong>占<strong>整个运行时间之比</strong>，也称流水线设备的时间利用率</p>
<p>如果是线性流水线，且各段经过时间相等，则在T时间内，流水线的效率都相等，均为 $\eta _0$</p>
<p>即 $\eta _1 = \eta _2 = … = \frac {n\Delta t_0}{T}=\frac{n}{m+(n-1)}$ </p>
<p>整个流水线的效率$ \eta = \frac {\eta _0 + \eta _1 + … + \eta _m}{m} =  \frac{m\eta _0}{m}=\frac{mn\Delta t_0}{mT}$ </p>
<p>式中分母$mT$ 是时空图中m个段和流水总时间T所围成的面积，分子$mn\Delta t_0$是时空图中n个任务实际使用的面积。从时空图看，效率实际上就是n个任务占用的时空区面积和m个段总的时空区面积之比</p>
<h5 id="P117"><a href="#P117" class="headerlink" title="P117"></a>P117</h5><h4 id="标量流水机的相关处理和控制机构"><a href="#标量流水机的相关处理和控制机构" class="headerlink" title="标量流水机的相关处理和控制机构"></a>标量流水机的相关处理和控制机构</h4><p>流水线只有<strong>连续不断地流动</strong>，不出现断流，才能获得高效率。如果处理不恰当，就会使流水效率显著下降</p>
<p>造成断流的原因：</p>
<ul>
<li>编译形成的目标程序不能发挥流水结构作用</li>
<li>存储系统提供不上连续流动所需的指令/操作数</li>
<li>相关</li>
<li>中断</li>
<li>非线性流水线引起的冲突</li>
</ul>
<h5 id="局部相关的处理"><a href="#局部相关的处理" class="headerlink" title="局部相关的处理"></a>局部相关的处理</h5><p>指令相关、主存操作数相关、通用寄存器组相关、基址值或变址值相关</p>
<p>在机器同时解释多条指令之间出现了对同一主存单元或寄存器要求“先读后写“而产生的。</p>
<ul>
<li>推后后续指令对相关单元的读，直至在先的指令写入完成</li>
<li>设置相关通路，将运算结果经过相关直接通路直接送入所需部件</li>
</ul>
<h5 id="全局相关的处理（-）"><a href="#全局相关的处理（-）" class="headerlink" title="全局相关的处理（**）"></a>全局相关的处理（**）</h5><p>转移指令和其后的指令之间存在关联</p>
<ul>
<li><p>猜测法</p>
<p>条件转移指令占20%，其中转移成功的概率有约占其中的60%。如果概率相近，则宜选择转移不成功分支；如果转移的两个分支概率不均等，宜猜高概率分支</p>
</li>
<li><p>加快和提前形成条件码</p>
<p>加快单条指令内部条件码的形成，不等指令执行完就提前形成反映运算结果的条件码。例如乘除结果可以在实际运算前完成</p>
</li>
<li><p>采取延迟转移</p>
<p>采用软件方法进行静态指令调度。在编译时，将转移指令与其前面不相关的<strong>一条或多条指令交换位置</strong>，让成功转移总是延迟到这一条或多条指令执行之后再进行</p>
</li>
<li><p>加快短循环程序的处理</p>
<p>将长度小于指缓容量的<strong>短循环程序</strong>整个一次性放入指缓内，并暂停预取指令，避免循环执行过程中由于指令预取操作将需要循环执行的指令冲掉，减少主存重复读取次数。</p>
</li>
</ul>
<h5 id="流水机器的中断处理"><a href="#流水机器的中断处理" class="headerlink" title="流水机器的中断处理"></a>流水机器的中断处理</h5><p>中断会引起流水线断流，但是其出现概率比条件转移的概率要低得多，且又是随机发生的。所以，对流水机器的中断，主要应考虑如何<strong>处理好断点现场的保护和恢复</strong>，而不是如何缩短流水线的断流时间。</p>
<h5 id="非线性流水线调度"><a href="#非线性流水线调度" class="headerlink" title="非线性流水线调度"></a>非线性流水线调度</h5><ul>
<li><p>由于非线性流水线有反馈回路，在流入新任务时，可能会出现几个任务争用同一功能段的冲突现象。</p>
</li>
<li><p>流水线任务调度：相邻任务间隔多少拍进入流水线的调度问题</p>
<ul>
<li>不冲突</li>
<li>平均延迟最短</li>
<li>尽可能提高的吞吐率与效率</li>
</ul>
</li>
<li><p>对非线性流水线，采用<strong>二维预约表</strong>来实现任务优化调度与优化</p>
</li>
<li><p>K段单功能非线性流水线，<strong>每个任务通过流水线需要N拍</strong></p>
</li>
<li><p>拍号：任务经过流水线的时钟节拍号</p>
</li>
<li><p>向一条非线性流水线的输入端连续输入两个任务之间间隔称为<strong>非线性流水线的启动距离</strong>或<strong>等待时间</strong>。</p>
</li>
<li><p>延迟禁止表：将流水线中<strong>所有各段</strong>对一个任务流过时会争用同一段的<strong><em>节拍间隔数</em></strong>汇集在一起。</p>
</li>
<li><p>冲突向量：用$N-1$ 位的位向量来表示后续新任务间隔各种不同拍数送入流水线时，是否会发生功能段使用的冲突</p>
<p>$（C_{n-1},…,C_i,…,C_2,C_1)$ 中第 $i$ 位的状态用以表示与当时相隔 $i$ 拍给流水线送入后继任务是否会发生功能段的使用冲突。发生1，不发生0</p>
</li>
<li><p>由初始冲突向量$C_0$ 形成状态转换图</p>
<p>$C_0 $每过一拍逻辑右移一位，若移除0，则允许后续指令进入流水线，再与$C_0$按位“或”，形成新的冲突向量$C_i$</p>
</li>
</ul>
<h4 id="P185计算-冲突向量"><a href="#P185计算-冲突向量" class="headerlink" title="P185计算 冲突向量"></a>P185计算 冲突向量</h4><h3 id="指令级高度并行的超出处理机"><a href="#指令级高度并行的超出处理机" class="headerlink" title="指令级高度并行的超出处理机"></a>指令级高度并行的超出处理机</h3><ul>
<li><p>超标量处理机：<strong>多条指令流水线</strong>，每个$\Delta t$同时流出m条指令（称为度m），靠编译程序优化指令执行顺序。</p>
<p>组成：冗余设置，多套部件，多部件并发工作</p>
</li>
<li><p>超流水线处理机：每个$\Delta t$只流出一条指令，但$\Delta t$很小，同<strong>超标量相比</strong>(度为m)，是其节拍(单位时间)的$1/m$。</p>
<p>超流水线是<strong>单流水线</strong>，$\Delta t’$非常小，相当于原流水线的$\Delta t’$=$\Delta t/m$ 。</p>
</li>
<li><p>超长指令字处理机：编译时找出潜在并行性，进行单指令，多操作码，多数据压缩，形成超长指令。执行时不检测并行性与相关性，直接执行。</p>
</li>
</ul>
<h4 id="超标量处理机基本结构"><a href="#超标量处理机基本结构" class="headerlink" title="超标量处理机基本结构"></a>超标量处理机基本结构</h4><ul>
<li><p>一般流水线处理机：</p>
<ul>
<li>一条指令流水线</li>
<li>一个多功能操作部件，每个时钟周期平均执行指令的条数小于1。</li>
</ul>
</li>
<li><p>多操作部件处理机：</p>
<ul>
<li>一条指令流水线</li>
<li>多个独立的操作部件，操作部件可以采用流水线，也可以不流水</li>
<li>多操作部件处理机的指令级并行度小于1</li>
</ul>
</li>
<li><p>超标量处理机典型结构：</p>
<ul>
<li>多条指令流水线</li>
<li>进的超标量处理机有:定点处理部件CPU，浮点处理部件FPU,图形加速部件GPU</li>
</ul>
</li>
</ul>
<ul>
<li>大量的通用寄存器，两个一级高速Cache</li>
<li>超标量处理机的指令级并行度大于1</li>
</ul>
<h4 id="超流水线处理机"><a href="#超流水线处理机" class="headerlink" title="超流水线处理机"></a>超流水线处理机</h4><p>两种定义：</p>
<ul>
<li>一个周期内能够<strong>分时</strong>发射多条指令的处理机称为超流水线处理机</li>
<li>指令流水线有<strong>8个或更多功能段</strong>的流水线处理机称为超流水线处理机</li>
</ul>
<p>提高处理机性能的不同方法：</p>
<ul>
<li>超标量处理机是通过<strong>增加硬件资源</strong>为代价来换取处理机性能的。</li>
<li>超流水线处理机则通过<strong>各硬件部件充分重叠工作</strong>来提高处理机性能。</li>
</ul>
<p>两种不同并行性：</p>
<ul>
<li>超标量处理机采用的是<strong>空间</strong>并行性</li>
<li>超流水线处理机采用的是<strong>时间</strong>并行性</li>
</ul>
<h4 id="超标量超流水线处理机"><a href="#超标量超流水线处理机" class="headerlink" title="超标量超流水线处理机"></a>超标量超流水线处理机</h4><ul>
<li><p>把超标量与超流水线技术结合在一起，就称为<strong>超标量超流水线处理机</strong></p>
</li>
<li><p>指令执行时序</p>
<p>超标量超流水线处理机在一个Δ𝑡′ = Δ𝑡/𝑛时钟周期内分时发射𝑘条指令，相当于每个时钟周期Δ𝑡总共发射指令𝑛𝑘条。</p>
</li>
</ul>
<p>  ​<br>  ​<br>  ​        </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/计算机图形学专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/19/计算机图形学专题复习/" itemprop="url">
                  计算机图形学复习要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T21:10:20+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机图形学复习要点"><a href="#计算机图形学复习要点" class="headerlink" title="计算机图形学复习要点"></a>计算机图形学复习要点</h1><h2 id="第一章-计算机图形学概述"><a href="#第一章-计算机图形学概述" class="headerlink" title="第一章 计算机图形学概述"></a>第一章 计算机图形学概述</h2><h4 id="计算机图形的概念与研究的内容"><a href="#计算机图形的概念与研究的内容" class="headerlink" title="计算机图形的概念与研究的内容"></a>计算机图形的概念与研究的内容</h4><ol>
<li><p>图形的概念</p>
<ul>
<li><p>广义的图形概念 </p>
<p>凡是能够在人的视觉系统中形成视觉印象的客观对象都称为图形。如：</p>
<ul>
<li>自然景物</li>
<li>照片和图片</li>
<li>工程图、设计图和方框图</li>
<li>人工美术绘画、雕塑品</li>
<li>用数学方法描述的图形（包括几何图形、代数方程、分析表达式或列表所确定的图形</li>
</ul>
</li>
<li><p>计算机图形学中的图形概念</p>
<p>是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色彩等非几何要素构成的，从现实世界中抽象出来的带有灰度、色彩及形状的图或形。</p>
</li>
</ul>
</li>
<li><p>计算机图形学的研究内容</p>
<p>用计算机生成景物的数字模型，并将它显示在计算机屏幕上，或者绘制在纸张或胶片上。它是<strong>研究如何在计算机环境下生成、处理和显示图形的一门学科</strong>。</p>
<p>主要研究对象：</p>
<ul>
<li><strong>景物的几何建模</strong>方法(modeling)对模型的处理方法</li>
<li><strong>几何模型的绘制技术</strong>(rendering)</li>
<li>图形输<strong>入和控制的人机交互界面</strong>(userinterface)。</li>
</ul>
</li>
</ol>
<h4 id="图形学发展史"><a href="#图形学发展史" class="headerlink" title="图形学发展史"></a>图形学发展史</h4><h4 id="计算机图形的应用"><a href="#计算机图形的应用" class="headerlink" title="计算机图形的应用"></a>计算机图形的应用</h4><ol>
<li>计算机<strong>辅助设计与制造</strong></li>
<li>地理信息系统</li>
<li>科学计算可视化</li>
<li>计算机动画和艺术</li>
<li>计算机模拟和仿真</li>
<li>虚拟现实</li>
</ol>
<h2 id="第二章-计算机绘图初步认识"><a href="#第二章-计算机绘图初步认识" class="headerlink" title="第二章 计算机绘图初步认识"></a>第二章 计算机绘图初步认识</h2><h4 id="如何在计算机上绘图"><a href="#如何在计算机上绘图" class="headerlink" title="如何在计算机上绘图"></a>如何在计算机上绘图</h4><ol>
<li><p>计算机绘图的一般方法</p>
</li>
<li><p>一般图形的显示流程</p>
<p>分为三个阶段：图形的数字化，图形操作，图形输出</p>
<p>模型坐标系（局部坐标系）：在图形处理过程中每个图形都有自己的坐标系</p>
<p>世界坐标系：一个图形场景往往由多个图组成，为了描述它们之间的空间关系，要把它们置于统一的坐标系中</p>
<p>设备坐标系：要输出经过处理后的数字化图形，需要在输出设备上建立一个坐标系</p>
<p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B.png" alt="图片显示流程"></p>
</li>
</ol>
<p>OpenGL图形软件包简介</p>
<h2 id="第三章-计算机图形系统及硬件"><a href="#第三章-计算机图形系统及硬件" class="headerlink" title="第三章 计算机图形系统及硬件"></a>第三章 计算机图形系统及硬件</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>计算机系统中的图形设备</li>
<li>图形的输入输出处理流程</li>
<li>图形工作站与PC机</li>
</ol>
<h4 id="计算机系统中的图形设备"><a href="#计算机系统中的图形设备" class="headerlink" title="计算机系统中的图形设备"></a>计算机系统中的图形设备</h4><p>计算机图形系统用来生成、处理和显示图形，通常由<strong>中央处理机</strong>、<strong>图形输出设备</strong>和<strong>图形输入设备</strong>构成。</p>
<p>计算功能、存储功能、输入功能、输入功能交互功能</p>
<h4 id="图形显示原理"><a href="#图形显示原理" class="headerlink" title="图形显示原理"></a>图形显示原理</h4><ol>
<li><p>CRT显示器</p>
<ul>
<li><p>CRT显示原理</p>
</li>
<li><p>彩色CRT的显示原理</p>
</li>
<li><p>光栅扫描式的图形显示器</p>
<ul>
<li><strong>是画点设备，可看成一个点阵单元发生器，并可控制每个点阵单元的亮度</strong>。</li>
<li>发出的电于束的偏转方式是固定的，<strong>自上而下，从左到右扫描在荧光屏上形成光栅形状</strong>。</li>
<li>图形是通过电子束扫描到光栅上的图形象素点时呈现的亮度或颜色与光栅背景的亮度或颜色不同而衬托出的，可形成多级灰度或颜色的实面积自然图像。</li>
<li>由于图像是由像素阵列组成，<strong>显示一幅图像所需要的时间等于显示整个光栅所需的时间，而与图像的复杂程度无关</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>随机扫描的图形显示器</p>
<p>随机扫描显示器和存储式管理的显示器都是画线设备，在屏幕上显示一条直线是从屏幕上的一个可编址点直接画到另一个可编址的点</p>
</li>
<li><p>液晶显示器</p>
<p>液晶，即液态晶体。是具有线状结晶结构的分子，可像液体一样流动。如果把它加热会呈现透明的液体状态，冷却成固体状态。</p>
</li>
<li><p>等离子显示器</p>
<p>由密封在玻璃膜夹层中的晶格矩阵（光栅）组成，每个晶格充满低压气体。在高压作用下，气体会电离解，即电子从原子中游离出来。</p>
</li>
</ol>
<h4 id="图形绘制设备"><a href="#图形绘制设备" class="headerlink" title="图形绘制设备"></a>图形绘制设备</h4><p>输出设备：喷墨绘图机、激光打印机、笔试绘图机</p>
<p>输入设备：鼠标、键盘、光笔、数字化仪、触摸板、图形扫描仪、手写输入板</p>
<h2 id="第四章-基本光栅图形算法"><a href="#第四章-基本光栅图形算法" class="headerlink" title="第四章 基本光栅图形算法"></a>第四章 基本光栅图形算法</h2><h4 id="直线生成算法"><a href="#直线生成算法" class="headerlink" title="直线生成算法"></a>直线生成算法</h4><p>理想的直线是没有宽度的，是由无数个点构成的集合 </p>
<p>在光栅的有限像素点阵中，确定最佳逼近于该直线的一组像素，用这些像素表示该直线。</p>
<ol>
<li><p>DDA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dda</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> k,i;</div><div class="line">  <span class="comment">//k 即起点和中的横纵坐标距离较大者的距离</span></div><div class="line">  <span class="comment">//即 将距离大者分为k段</span></div><div class="line">  <span class="keyword">float</span> x,y,dx,dy;</div><div class="line">  k=<span class="built_in">abs</span>(x2-x1);</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">abs</span>(y2-y1)&gt;k) k=<span class="built_in">abs</span>(y2-y1);</div><div class="line">  dx=<span class="keyword">float</span>(x2-x1)/k;  <span class="comment">//增量，每次横坐标增量</span></div><div class="line">  dy=<span class="keyword">float</span>(y2-y1)/k;  <span class="comment">//每次纵坐标增量 </span></div><div class="line">  <span class="comment">//有一个的增量&lt;1，另一个增量=1</span></div><div class="line">  x=<span class="keyword">float</span>(x1);</div><div class="line">  y=<span class="keyword">float</span>(y1);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">    gl_Point(<span class="keyword">int</span>(x+<span class="number">0.5</span>),<span class="keyword">int</span>(y+<span class="number">0.5</span>));	<span class="comment">//取整</span></div><div class="line">    x=x+dx;</div><div class="line">    y=y+dy;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该算法计算量大，产生一个象素需要两次加法，两次取整。还需要除法，增加硬件难度。</p>
</li>
<li><p>正负法</p>
<p>假设 $P=(x,y)$ 是直线上的一点，与P最近的像素为$(x_i,y_i)$(  表示)，那么下一个与直线最近的像素只能是正右方的$P_B$或右上方的$P_T$两者之一。以M表示$P_B$和$P_T$的中点，Q是直线与垂线 $x=x_i+1$的交点。</p>
<p>显然，若M在Q的下方，则$P_T$离直线近，应取 为下一个像素，否则应取$P_B$</p>
</li>
<li><p>Bresenham算法</p>
<p>axc</p>
</li>
</ol>
<h4 id="圆弧生成算法"><a href="#圆弧生成算法" class="headerlink" title="圆弧生成算法"></a>圆弧生成算法</h4><ol>
<li>正负法</li>
<li>Bresenham算法</li>
<li>圆弧的离散生成</li>
</ol>
<h4 id="多边形填充（P51）"><a href="#多边形填充（P51）" class="headerlink" title="多边形填充（P51）"></a>多边形填充（P51）</h4><ol>
<li><p>多边形表示方法</p>
<ul>
<li><strong>顶点表示</strong>：是用<strong>多边形的顶点的序列来描述多边形</strong>，该表示<strong>几何意义强</strong>、占内存少，但它不能直观地说明哪些像素在多边形内。</li>
<li><strong>点阵表示</strong>：是用位于<strong>多边形内的象素的集合来刻划多边形</strong>，该方法虽然没有多边形的几何信息，是<strong>面着色所需要的图像表示形式</strong>。</li>
<li><strong>多边形填充就是把多边形的顶点表示转换为点阵表示</strong>。即从多边形的给定边界出发，求出位于其内部的各个像素，并将帧缓冲器内的各个对应元素设置相应的灰度或颜色。</li>
</ul>
</li>
<li><p>多边形填充的扫描线算法</p>
<p>扫描线算法是效率较高的多边形填充算法，充分利用了<strong>相邻象素之间的连续性</strong>，避免反复求交。</p>
<ul>
<li><p>区域的连续性</p>
<ul>
<li>梯形的两底边分别在$y= y_{i<em>k} $和$y=y</em>{i_{k+1}}$ 两条扫描线上，腰在多边形P的边上或在显示屏幕的边界上。</li>
<li>梯形可分为两类：一类位于多边形P的内部；另一类在多边形P的外部。</li>
<li>两类梯形在长方形区域${ y_{i<em>k} ，y</em>{i_{k+1}}}$内相间的排列。</li>
</ul>
</li>
<li><p>扫描线的连续性</p>
<ul>
<li>交点个数 $l$ 是偶数</li>
<li>扫描线上的一些点位于多边形P内，其余区间都在P外。</li>
<li>在该扫描线上，只有区段$(x_{ei<em>k}，x</em>{ei_{k+1}})$其中 $k=1,3,5,…,l–1$位于多边形P内</li>
</ul>
</li>
<li><p>边的连续性</p>
<ul>
<li>$d=e-1$</li>
<li>两序列元素的个数相等</li>
<li>点$( x_{ei<em>r},e)$与$(x</em>{di<em>r},d)$位于多边形P的同一边上，即 $x</em>{ei<em>r} = x</em>{di<em>r}+\frac {1}{m</em>{i_r}}$</li>
</ul>
</li>
<li><p>奇点处理</p>
<ul>
<li>为了使交点个数保持为偶数，<strong>规定当奇点是P的极值点时，该点按两个交点计算</strong>；否则按一个交点计算</li>
<li>若 $P<em>i$ 是非极值点，则将$(P</em>{i-1},P_i),(P<em>i,P</em>{i+1})$  两边中位于扫描线$y=y_i$<strong>方的那条边在$P_i$点处截去一单位长</strong> </li>
</ul>
</li>
<li><p>扫描线算法的数据结构域实现步骤</p>
<ul>
<li><p>边 y. 筒ET</p>
<p>按边下端点的纵坐标$y$对非水平边进行分类的指针数组。下端点的纵坐标 $y$ 等于 $i$ 的边归入第$i$类。同一类中按$x$值进行排序。</p>
<p>生成方式：从低端向上扫描</p>
</li>
<li><p>边的活化链表AEL</p>
<p>由与当前扫描线相交的所有多边形组成，记录多边形边沿扫描线的交点序列</p>
</li>
<li><p>四个域组成</p>
<p>| $y_{max}$ | $x$                          | $\Delta x$ | $next$    |<br>| ——— | —————————- | ———- | ——— |<br>| 边的上端点y坐标  | 边y筒中表示下端点x坐标；AEL中边与扫描线的交点x坐标 | 边斜率的倒数     | 指向下一条边的指针 |</p>
</li>
<li><p>算法步骤</p>
<ul>
<li>（AEL初始化）将边的活化链表AEL置空</li>
<li>（y初始化）取扫描线纵坐标y的初始值为<strong>ET中</strong>非空元素的最小序号</li>
<li>按从下到上的顺序对纵坐标值为y的扫描线（当前扫描线）执行下列步骤直到边的活化链表为空<ul>
<li>如边ET中的第y类元素非空，则从ET中将第y类的所有边取出，按照x值（x值相等时，按$\Delta x$值）递增方向插入到活化链表AEL中</li>
<li>若AEL非空，将AEL中的边亮亮依次配对，填充所有线段对$（x_1,y）$和$（x_2,y）$，$（x_3,y）$和$（x_4,y）$，……</li>
<li>将AEL中满足y=y_max的边删去</li>
<li>将AEL剩下的每条边的X域累加$\Delta x$ ，即 $x = x + \Delta x$</li>
<li>将当前扫描线的纵坐标值y累加1，即$y=y+1$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>边缘填充算法</p>
<p>多边形填充的扫描线算法中，建立ET筒和AEL活化链表时<strong>需要对多边形的边进行排序</strong>，该算法采用<strong>对图像进行逐位求反</strong>的方法可以免去对边排序的工作量。</p>
<ul>
<li>算法实现：对多边形P的每一非水平边$P<em>iP</em>{i+1}$上的各象素做向右求反运算即可。</li>
<li>优势：数据结构和程序简单，对单值图像比较有用</li>
<li>劣势：需要对帧缓冲器中的<strong>大批元素反复赋值</strong>，速度不比扫描线快。</li>
</ul>
</li>
</ol>
<ol>
<li><p>边界标志</p>
<p>首先用特殊颜色在帧缓冲器中将多边形边界（水平边的部分边界除外）勾画出来，然后再把位于多边形内的各个象素着色。</p>
<ul>
<li>算法实现：<ul>
<li>步骤1：以值为boundary-color 的特殊颜色勾画多边形P的边界。设多边形顶点为$P_i= (x_i, y_i) $$0≤i≤n， x_i, y<em>i$均为整数；置 $P</em>{n+1}=P_0$ 每一条扫描线上着上这种特殊颜色的点的个数必定是偶数(包括零)</li>
<li>步骤2：设<strong>interior_point</strong>是一布尔变量。对每一条扫描线从左到右进行搜索，如果当前是像素位于多边形P内，则interior_point=true，需要填上值为polygon_color的颜色；否则该像素在多边形P外，需要填上值为background_color的颜色</li>
</ul>
</li>
</ul>
<p><strong>避免了对帧缓冲器中的大量元素的多次赋值</strong>，但需要逐条扫描线对帧缓冲器中的元素进行搜索和比较。</p>
</li>
</ol>
<h4 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h4><ol>
<li><p>区域概念</p>
<p>指先将区域内的<strong>一点</strong>(常称种子点)赋予给定颜色，然后将这种颜色扩展到整个区域内的过程。</p>
<p>区域是指已经表示成点阵形式的象素集合。光栅图形中，区域可采用内点表示和边界表示。</p>
<ul>
<li><p>内点表示</p>
<p>把位于给定<strong>区域内的所有象素</strong>一一列举出来的方法</p>
</li>
<li><p>边界表示法</p>
<p>把位于给定区域的<strong>边界上的象素</strong>一一列举出来的方法.它将区域边界上的象素都着上同一种颜色(常称为边界色)。</p>
</li>
<li><p>区域的连通性</p>
<ul>
<li><p>四连通区域</p>
<p>取区域内任意两点，在该区域内若从其中一点出发通过<strong>上、下、左、右</strong>四种运动可到达另一点。</p>
</li>
<li><p>八连通区域</p>
<p>取区域内任意两点，若从其中任一点出发，在该区域内通过沿水平方向、垂直方向和对角线方向的八种运动可到达另一点。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>简单的种子填充算法</p>
<p>给定区域G一种子点（x,y），首先<strong>判断该点是否是区域内的一点</strong>，<strong>是则将该点填充为新的颜色</strong>，然后将该点周围的四个点（四连通）或八个点（八连通）作为新的种子点进行相同处理，通过这种扩散完成对整个区域填充。</p>
</li>
<li><p>扫描线种子填充算法</p>
<p>区域填充的递归算法程序简单、表达清楚。但是由于多层递归，需要反复进行费时、费内存的堆栈操作，一般用于细小的区域进行填充。</p>
<p><strong>扫描线种子算法，从给定的种子点开始，填充当前扫描线上种子点所在的区间，然后确定与这一区间相邻的上下两条扫面线上需要填充的区间</strong>，从这些区间上各取一个种子点并以此把它们保存起来，作为下次填充的种子点，反复进行直到所保存的各区间都填充完毕</p>
<p>算法步骤：</p>
<ol>
<li>将算法设置的堆栈置为空，将给定种子点（x,y）压入堆栈</li>
<li>如果堆栈为空，算法结束；否则取栈顶元素（x,y）作为种子点</li>
<li>从种子点开始，沿纵坐标为y的当前扫描线<strong>向左右两个方向</strong>逐个用新的颜色值进行填充，直到边界为止。设区间的横纵坐标分别为$x<em>{left}$和$x</em>{right}$。</li>
<li>在与当前扫描线相邻的上下两条扫描线上，以区间$[x<em>{left},x</em>{right}]$为搜索范围，求出需要填充的各小区间，把各小区间中<strong>最右边的点</strong>作为种子点压入堆栈，移向2</li>
</ol>
<p>流程的图</p>
</li>
</ol>
<h4 id="光栅图形的反走样算法（不考）"><a href="#光栅图形的反走样算法（不考）" class="headerlink" title="光栅图形的反走样算法（不考）"></a>光栅图形的反走样算法（不考）</h4><ol>
<li><p>光栅图形的走样现象</p>
<p>图形的边界一般都呈阶梯形</p>
<p>图形的细节失真、狭小图形遗失图形的细节失真、狭小图形遗失</p>
</li>
<li><p>提高分辨率的反走样算法</p>
<p>采用硬件：采用高分辨率的光栅图形显示器，花费的代价大。</p>
<p>采用软件：花费的代价小，也容易实现。 （高分辨率计算，低分辨率显示）</p>
<p>高分辨率计算：将低分辨的图形显示象素划分为许多子象素，如2×2划分，3×3划分等，然后按通常的算法计算出各个子象素的颜色值或灰度值。</p>
<p>低分辨率显示：将一象素内的各个子象素的颜色值或灰度值的平均值作为该象素的颜色值或灰度值。求平均值时可取算术平均，也可取加权平均。</p>
</li>
<li><p>线段反走样算法</p>
<p>把线段看作是有宽度的狭长的矩形如图4.28</p>
<p>线段具有一定的面积，当线段通过某象素时，可以求出两者面积的交</p>
<p>根据每一象素与线段相交部分的面积值决定该象素的颜色值或灰度值</p>
</li>
<li><p>多边形反走样算法</p>
</li>
</ol>
<h2 id="第五章-变换和裁剪"><a href="#第五章-变换和裁剪" class="headerlink" title="第五章 变换和裁剪"></a>第五章 变换和裁剪</h2><h4 id="变换的数学基础"><a href="#变换的数学基础" class="headerlink" title="变换的数学基础"></a>变换的数学基础</h4><h4 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h4><h5 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h5><p>世界坐标系（world coordinate）:一个图形场景往往由多个对象组成，为了描述它们之间的空间关系，需要把它们置于一个统一的坐标系中，该坐标系称为<strong>世界坐标系</strong>。</p>
<p>模型坐标系（modeling coordinate）或局部坐标系（local coordinate）：当构造单个对象的数字模型时，为了方便可以将其置于一个特定的坐标系下，即<strong>模型坐标系</strong>或<strong>局部坐标系</strong>。</p>
<p>设备坐标系（device coordinate）：图形输出时，则应在输出设备上建立一个坐标系，这个坐标系称为<strong>设备坐标系</strong>。设备坐标系依据设备的种类有不同的形式，如二维的屏幕坐标系，描述机械手运动轨迹的三维坐标系。</p>
<p>标准化设备坐标系（normalized device coordinate）：有些图形系统，对设备坐标系进行了规范化，将坐标范围限定在区间{x,y,z | 0≤x≤1, 0≤y≤1, 0≤z≤1}内，称为<strong>标准化设备坐标系</strong>。</p>
<p>每一图形的模型都有自己的坐标系，此坐标系为模型坐标系或局部坐标系。图形场景由多个图形组成，它们被放置在一个统一的坐标系中，称为世界坐标系</p>
<ol>
<li>基本变换<ul>
<li>平移变换</li>
<li>缩放变换<ul>
<li>原点为相似中心</li>
<li>定义其他点为相似中心</li>
<li>为使缩放后的图形仍在原来位置附近，定义相似中心$(x_p,y_p,z_p)$ ，把整个图形沿x,<br>y和z方向平移$-x_p,-y_p$和$-z_p$,使相似中心移到坐标原点；然后对每一点作缩放变换；最 后再沿x, y和z方向平移$x_p,y_p$和$z_p$,把经过放缩的图形移回原处，这样就以$(x_p,y_p,z_p)$ 为中心进行缩放变换</li>
</ul>
</li>
<li>旋转变换<ul>
<li>x、y、z点左边经旋转后的坐标。（y有差别）</li>
<li>绕过原点的任意轴旋转（不懂）</li>
<li>void glRotate(Type angle, x , y , z) ，以angle为旋转角度，以从原点到指定（x,y,z）向量为旋转中心轴，逆时针旋转。</li>
</ul>
</li>
<li>错切变换</li>
</ul>
</li>
<li>齐次坐标与变换的矩阵表示<ul>
<li>为了将平移变换合并，使用齐次坐标系</li>
<li>用n+1维向量表示n维向量</li>
</ul>
</li>
<li>变换模式<ul>
<li>图形软件包提供两种图形变换模式—— 图形模式和空间模式，从而可以方便地控制变换的次序</li>
<li>图形模式<ul>
<li>矩阵的乘法不符合交换律</li>
<li>每一次变换均可看成相对于<strong>原始坐标系</strong>中执行的，先调用的变换矩阵放在右边，后调用的矩阵放在左边。 固定坐标系模式</li>
<li>个人理解：都是相对于初始坐标系进行变换</li>
</ul>
</li>
<li>空间模式<ul>
<li>又称<strong>活动坐标系模式</strong>。连续执行几个变换时，变换矩阵的合并方式和图形模式相反，即后调用的变换矩阵要乘在右边</li>
<li>空间模式的特点是在连续执行几次变换时，每一次变换均可看成是<strong>上一次变换所形成的新坐标系中进行的</strong>。</li>
<li>对变换后的坐标系进行变换</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ol>
<li><p>Sutherland-Cohen算法</p>
<p>思想：</p>
<ul>
<li>判断直线是否完全在窗口内或窗口外</li>
</ul>
</li>
</ol>
<ul>
<li><p>计算出直线段和窗口边界直线的一个交点，此交点把原线段分成两段，去掉显然在窗口外的一段，对另一段进行重新判断。</p>
<p> 实现：</p>
</li>
<li><p>用窗口的四条边把整个平面分成九个区域，对于窗口某一边界外侧的三个区域的四位编码中有一位全是1。</p>
</li>
<li>对线段两端进行编码，如果两端编码都是0000，则完全在窗口内；如果逻辑与不为0000，即某一位为1，表明两端点位于窗口同一条边界外侧，显然在窗口外。<ul>
<li>如果上述两条不能断定，就与分割线求交，抛弃完全在外侧的</li>
</ul>
</li>
</ul>
<ol>
<li><p>Cyrus-Beck算法和梁友东-Barsky算法</p>
<p>Cyrus—Beck算法基本思想</p>
<p><strong>对于线段$P_1P_2$的参数方程表示，如果能判断出线段进入多边形时候的参数$t_s$和线段退出多边形时的参数$t_e$，则$t_st_e$之间的线段为裁剪完毕后的结果</strong>。</p>
<p>梁友栋—Barsky算法基本步骤</p>
<p>上述终点组和起点组的特征分别表现为$r_k&gt;0$和$r_k&lt;0$，其中k对应于相应的裁剪边界(k=L、R、B、T,分别对应于左、右、下、上边界)沿    方向前进。</p>
<p>$r_k&gt;0$时，将进入k边界的外侧；$r_k&lt;0$时，将进入k边界的内侧。若$r_k=0$时$s_k&lt;0$,线段完全不可见，算法结束,否则就继续处理其他边。</p>
<ul>
<li>初始化线段在边界内的端点参数为ts=0、te=1。</li>
<li>计算出各个裁剪边界的r、s值。</li>
<li>当r=0且s&lt;0时，舍弃该线段；否则计算线段与边界的交点参数t。<ul>
<li>当r&lt;0时，参数t用于更新ts</li>
<li>当r&gt;0时，参数t用于更新te</li>
</ul>
</li>
<li>如果更新了ts或te后，使ts&gt;te，则舍弃该线段。</li>
</ul>
</li>
<li><p>多边形剪裁</p>
</li>
<li><p>字符剪裁</p>
</li>
</ol>
<h4 id="OpenGL中简单变换实例"><a href="#OpenGL中简单变换实例" class="headerlink" title="OpenGL中简单变换实例"></a>OpenGL中简单变换实例</h4><h2 id="第六章-三维空间的观察"><a href="#第六章-三维空间的观察" class="headerlink" title="第六章 三维空间的观察"></a>第六章 三维空间的观察</h2><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>把n维坐标系中的电变换成小于n维坐标系中的点。只讨论三维到二维的投影。</p>
<p>在三维空间中选择一个点作为视点，定义一个不经过视点的平面（投影平面），从视点向投影平面引出任意条射线（投影线）。穿过物体的投影线将与投影平面相交，在投影平面上形成物体的像，此像即为三维物体在二维投影平面上的投影。</p>
<p>投影变换分为透视投影和平行投影，区别是透视投影的投影中心和投影面之间的距离有限，而平行投影的投影中心和投影平面之间的距离是无限的</p>
<ol>
<li><p>透视投影</p>
<ul>
<li>投影中心和投影面之间的距离是有限的</li>
</ul>
</li>
</ol>
<ul>
<li>透视投影的计算公式</li>
</ul>
<ol>
<li><p>平行投影</p>
<ul>
<li>正投影：投影方向与投影平面法向相同。常见的正投影类型有：正视图、俯视图、侧视图、等轴测投影</li>
<li>斜投影：常见斜投影类型：斜等测投影、斜二测投影</li>
<li>平行投影的计算公式</li>
</ul>
</li>
<li><p>任意坐标系到观察坐标系中的变换</p>
<ul>
<li>灭点：一组不平行于投影平面的平行线，经过透视投影后相交于一点。灭点可以看作是三维空间的无穷远点在投影平面上的投影点。如果这组平行线平行与坐标轴，这时的灭点称为<strong>主灭点</strong>。</li>
</ul>
</li>
<li><p>射影变换</p>
</li>
</ol>
<h4 id="视见体到规范视见体的变换"><a href="#视见体到规范视见体的变换" class="headerlink" title="视见体到规范视见体的变换"></a>视见体到规范视见体的变换</h4><p>视见体中的内容要投影到投影平面上，然后显示在输出设备上的视口中。投影之前，三维空间中的物体要被三维视见体裁剪</p>
<ol>
<li>平行投影视见体的规范化</li>
<li>透视投影视见体的规范化</li>
</ol>
<h4 id="窗口到视口的变换"><a href="#窗口到视口的变换" class="headerlink" title="窗口到视口的变换"></a>窗口到视口的变换</h4><p>显示一幅图时，首先要在投影平面上定义一个窗口，同时还要在屏幕或绘图机上定义一个视口，窗口的内容要显示在视口中。</p>
<p>通常视见体的宽高比和视口的宽高比应该相同</p>
<h4 id="连续变换的处理"><a href="#连续变换的处理" class="headerlink" title="连续变换的处理"></a>连续变换的处理</h4><h2 id="第七章-人机交互绘图技术"><a href="#第七章-人机交互绘图技术" class="headerlink" title="第七章 人机交互绘图技术"></a>第七章 人机交互绘图技术</h2><p>人机交互：用户与计算机系统之间的通信，它是<strong>人与计算机之间各种符号和动作的双向信息交换</strong></p>
<h4 id="基本的图形输入设备和基本交互任务"><a href="#基本的图形输入设备和基本交互任务" class="headerlink" title="基本的图形输入设备和基本交互任务"></a>基本的图形输入设备和基本交互任务</h4><ol>
<li>基本的图形输入设备<ul>
<li>定位设备</li>
<li>笔画设备</li>
<li>定值设备</li>
<li>选择设备</li>
<li>拾取设备</li>
<li>字符串设备</li>
</ul>
</li>
<li>基本交互任务<ul>
<li>定位</li>
<li>笔画</li>
<li>定值</li>
<li>选择</li>
<li>拾取</li>
<li>字符串</li>
</ul>
</li>
</ol>
<h4 id="人机交互输入模式（重点）"><a href="#人机交互输入模式（重点）" class="headerlink" title="人机交互输入模式（重点）"></a>人机交互输入模式（重点）</h4><ol>
<li><p>请求模式</p>
<p>请求模式下，输入设备的初始化是在应用程序中设置的，即只有输入设置命令（或语句）对<strong>相应的设备设置</strong>所需要的输入模式后，该设备才能作相应的输入处理。在这种请求的命令中要指定由哪一个应用程序调用及调用哪一个输入设备。</p>
<p>在请求方式下，<strong>程序和输入设备轮流处于工作状态和等待状态</strong>，由程序支配输入设备的启动。</p>
</li>
<li><p>样本模式</p>
<p>把一台或多台输入设备定义为样本模式后，这些<strong>设备会连续不断地把信息输入进来</strong>，而不必等待应用程序的输入语句，即<strong>信息的输入和应用程序中的输入命令无关</strong>。当应用程序遇到<strong>取样命令</strong>时，就把<strong>相应的物理设备的值作为取样数值</strong>。</p>
<p>优点：不像请求模式那样要求用户有一明显的动作，它对<strong>连续的信息流输入比较方便</strong>，也可同时处理多个输入设备的输入信息。</p>
<p>缺点：当处理某一种输入的时间较长时，可能会失掉某些输入信息。程序和输入设备同时运行输入设备不断地产生数据，并把数据输入数据缓存区，从而不断刷新数据缓存区的内容。程序在运行时若遇到采样语句，就到数据缓存区中去取数据。这样，程序取的是<strong>最新刷新的输入数据</strong>。</p>
</li>
<li><p>事件模式</p>
<p>当设备设置成事件模式后，输入设备和程序并行工作。所有被<strong>设置成事件方式的输入数据</strong>（或事件）都被存放在一个<strong>事件队列</strong>中，该队列是以事件发生的时间排序的。</p>
<p>用户在输入设备上完成一个输入动作（如按一下按钮等）便产生一个事件，输入信息及该设备编号等便存放到一个事件队列中。不同的应用程序可<strong>到队列中来查询和提取与该应用程序有关的事件</strong>。</p>
<p>事件模式下的程序流程不同于样本模式，用户输入的信息是不会遗失。</p>
</li>
<li><p>混合使用</p>
<p>现代的计算机图形输入系统往往不是单一地使用一种输入方式，多种输入方式常常混合使用，即一个应用程序可以在集中输入控制方式下操作几种不同的设备输入器。</p>
</li>
</ol>
<h4 id="常见辅助交互技术"><a href="#常见辅助交互技术" class="headerlink" title="常见辅助交互技术"></a>常见辅助交互技术</h4><ol>
<li>几何约束</li>
<li>拖拽</li>
<li>在三维视图上做三维输入</li>
</ol>
<h2 id="第八章-隐藏线和隐藏面的消除"><a href="#第八章-隐藏线和隐藏面的消除" class="headerlink" title="第八章 隐藏线和隐藏面的消除"></a>第八章 隐藏线和隐藏面的消除</h2><p>计算机生成三维图形，首先确定三维场景中的物体哪些部分是可见的，生成三维图形时只绘制可见的部分。</p>
<p>三维场景中物体的可见性对透视投影是相对于投影中心，平行投影是相对于投影方向。</p>
<p>场景可见部分的判断过程称为可见线判断或可见面判定，也称为隐藏线消除或隐藏面消除。</p>
<p>两种基本算法：</p>
<ol>
<li>以<strong>构成图像的每一个象素</strong>为处理单元，对场景中所有表面，确定对于观察点是可见的表面，用该表面颜色填充该象素。<strong>多用于面消隐</strong></li>
<li>以<strong>三维场景中的物体对象</strong>为处理单元，在所有对象之间进行比较，除去完全不可见的物体和物体上不可见的部分。<strong>多用于线消隐，也可用于面消隐</strong></li>
</ol>
<h4 id="可见面判断的有效技术"><a href="#可见面判断的有效技术" class="headerlink" title="可见面判断的有效技术"></a>可见面判断的有效技术</h4><p>可见面或可见线的判定是一个计算量很大的工作，如何减少可见面的判定非常重要。</p>
<ol>
<li><p>边界盒（*）</p>
<p>在裁剪和消隐处理中，采用边界盒可避免不必要的裁剪运算，避免在物体或它们的投影之间进行不必要的计算。所谓物体的边界盒是指<strong><u>一个能够包含该物体的一个几何形状，该形状有较简单的边界</u></strong></p>
</li>
<li><p>后向面消除（*）</p>
<p>把显然不可见的面去掉，从而减少消隐过程中的直线求交数目。</p>
<p><strong>后向面</strong>：表面的法向指向与观察者相背离的方向，这些多边形完全被多面体其他多边形遮挡。</p>
<p>判断方法：设多边形F的顶点为 $v_1,v_2,…,v_L$ ，顶点的次序要求这样排列，使观察者在多边形外沿着$v_1 \rightarrow v_2 \rightarrow v_3 … \rightarrow v_L$ 走时，多边形的内部始终在他的右侧</p>
<p>$sp  \ge 0$ 后向面</p>
</li>
<li><p>非垂直投影转换成垂直投影</p>
<p>判断两个多边形是否相交的方法之一是把它们投影到oxy平面上，然后判断它们的边界盒是否相交。投影到oxy，忽略了z坐标的顶点计算，大大减少计算量</p>
<p>垂直投影比非垂直投影容易实现，并且计算量小。因此在进行消隐工作之前，首先应将非垂直投影转换成垂直投影，从而降低算法复杂性，提高运算速度</p>
</li>
</ol>
<h4 id="多面体隐藏线消除算法（˚¬˚）"><a href="#多面体隐藏线消除算法（˚¬˚）" class="headerlink" title="多面体隐藏线消除算法（˚¬˚）"></a>多面体隐藏线消除算法（˚¬˚）</h4><ol>
<li><p>算法基本思想</p>
<p>预处理：</p>
<ul>
<li>使用后向面消除技术把多面体后向面去掉</li>
<li>使用边界盒技术排除不相交的线段的求交运算</li>
</ul>
</li>
<li><p>确定边L和多边形E关系的技术</p>
</li>
</ol>
<h4 id="基于窗口的子分算法"><a href="#基于窗口的子分算法" class="headerlink" title="基于窗口的子分算法"></a>基于窗口的子分算法</h4><p>是一种分而治之的算法</p>
<p>整个屏幕可以称为窗口，窗口子分算法是一个<strong>递归的四等分</strong>过程，每一次把矩形的窗口等分成四个相等的小矩形，分成的矩形也可以称为窗口，每一次子分，均对要显示的<strong>多边形和窗口</strong>的关系作判断</p>
<p>存在关系：</p>
<ol>
<li>多边形包含了窗口</li>
<li>多边形和窗口相交</li>
<li>窗口包围了多边形</li>
<li>窗口和多边形分离</li>
</ol>
<p>处理方式：</p>
<ol>
<li>所有多边形均与窗口分离，这时只要把窗口所有的像素填上背景色</li>
<li>只有一个多边形和窗口相交，或这个多边形包含在窗口内。先对窗口内的每一像素填上背景颜色，再对窗口内多边形用<strong>扫面线算法填充</strong></li>
<li>只有一个保卫窗口的多边形，则窗口用包围多边形的颜色填充</li>
<li>如果有一个多边形盖在最上面，整个窗口填充为最上面的多边形颜色</li>
</ol>
<h4 id="基于多边形的子分算法"><a href="#基于多边形的子分算法" class="headerlink" title="基于多边形的子分算法"></a>基于多边形的子分算法</h4><p>用<strong>多边形的边界</strong>对区域进行划分，目的是尽量减少对区域划分的次数</p>
<h4 id="Z缓冲器算法和扫描线算法"><a href="#Z缓冲器算法和扫描线算法" class="headerlink" title="Z缓冲器算法和扫描线算法"></a>Z缓冲器算法和扫描线算法</h4><ol>
<li><p>Z缓冲器算法</p>
<p>z缓冲器算法是<strong>最简单的隐藏面消除算法之一</strong>。对屏幕上每一个像素点，找到此像素投影线与所有多边形交点中<strong>离观察者最近的点</strong>，此点的属性（颜色或灰度）值即为这一屏幕<strong>像素点的属性值</strong>。</p>
<p>实现此算法需要两个缓冲器数组，即z缓冲器数组和帧缓冲器数组，$Zdepth[\ ][\ ]$与$Frame[\ ][\ ]$，算法如下</p>
<ol>
<li>对屏幕上的每个点$(x,y)$，令Zdepth[x][y]为z的极小值，Frame[x][y]为背景颜色</li>
<li>对所有多边形做如下工作：对多边形上每一点(x,y)，计算其z值。若z&gt;Zdepth[x][y]，则Zdepth[x][y]=z，并将此属性值赋给Frame[x][y]，否则说明此点离观察者较远，两个数组的值都可以不用改变</li>
</ol>
<p>优点：简单、可靠，不需要对显示物体的面预先进行排序，有利于硬件实现</p>
<p>缺点：需要额外的z缓冲器，将全屏幕的像素保存</p>
</li>
<li><p>扫描线z缓冲器算法</p>
<p>为了克服缺点，将整个屏幕平面划分为若干个区域。如果把整个区域取成屏幕上的一行，就得到了<strong>扫面线z缓冲器算法</strong>。z缓冲器的单元数和一条扫描线上的像素数目相同。从最上面的扫描线开始，向下对每一条扫面线进行处理。</p>
<p>处理工作</p>
<ol>
<li>把相应的帧缓冲器单元设置成<strong>底色</strong>，在<strong>z缓冲器</strong>中存放z的极小值。</li>
<li>对每个多边形检查它在oxy平面上的投影和当前的扫描线是否相交<ul>
<li>若不相交，则不考虑该多边形</li>
<li>若相交，则扫描线和多边形边界的交点是成对出现的。</li>
</ul>
</li>
<li>对<strong><u>每对交点中间的像素</u></strong>计算多边形所在平面对应点的深度（z值），并和z缓冲器中相对应单元存放间的深度值做比较。<ul>
<li>若前者大于后者，则z缓冲器的相应单元内容要被求得的平面深度代替，帧缓冲器相应单元的内容也要换成该平面的属性。</li>
</ul>
</li>
<li>对所有的多边形都做上述处理后，帧缓冲器中这一行的值边反映了消隐后的图形。对帧缓冲器每一行都处理完后，就得到了整个消隐后的图形</li>
</ol>
<p>实现方式</p>
<p>采用数据结构：一个多边形Y筒，一个边Y筒，一个多边形活化表盒一个边活化表。</p>
<ul>
<li><p>多边形Y筒和边Y筒各是一个记录，记录的<strong>个数</strong>和<strong>扫描线的行数相同</strong>。</p>
</li>
<li><p>根据多边形顶点<strong>y坐标最大值</strong>来决定放入<strong><em>多边形y筒</em></strong>的行数</p>
</li>
<li><p>根据边两端点的<strong>较大y坐标值</strong>来决定放入<strong>边y筒</strong>的相应行数</p>
</li>
<li><p>多边形Y筒：</p>
<ul>
<li>多边形所在平面方程： $ax+by+cz+d=0$的系数     <strong>a,b,c和d</strong></li>
<li>和该多边形在$oxy$平面上的投影相交的扫描线的条数      $\Delta y =8$</li>
<li>多边形的属性   <strong>color</strong></li>
<li>编号 <strong>IP</strong></li>
</ul>
</li>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%A4%9A%E8%BE%B9%E5%BD%A2y%E7%AD%92.png" alt="多边形Y筒"></p>
</li>
<li><p>边Y筒</p>
<ul>
<li>边<strong>上端点x坐标</strong>的值</li>
<li>在$oxy$平面上的投影和相邻两条扫面线的交点的<strong>x坐标的差</strong>$\Delta x$（斜率负倒数）</li>
<li>边在oxy平面上的投影所覆盖的<strong>扫面线条数</strong> $\Delta y$</li>
<li>边所属多边形的编号  <strong>IP</strong></li>
</ul>
</li>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E8%BE%B9y%E7%AD%92.png" alt="边y筒"></p>
</li>
<li><p>多边形活化表，记录在$oxy$平面投影<strong>和当前考虑的扫描线相交的多边形</strong></p>
</li>
<li><p>边活化表，存放多边形的边和当前扫描线相交的边对。边对保存如下信息：</p>
<ul>
<li>$x_l$      左边的x坐标值</li>
<li>$\Delta x_l$   左边和两相邻扫描线交点的x坐标差</li>
<li>$\Delta y_l$   以左边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1</li>
<li>$x_r$      右边交点的x坐标值</li>
<li>$\Delta x_r$  右边和两相邻扫描线交点的x坐标差  </li>
<li>$\Delta y_r$   以右边的投影所覆盖的扫描线条数为初值，以后没处理一条扫描线-1</li>
<li>$z_l $       多边形平面在左交点处的深度值</li>
<li>$\Delta z_x$  沿扫描线向右走过一个像素时，多边形所在平面深度的增量</li>
<li>$ \Delta z_y $  沿y方向向下移过一根扫描线时，多边形所在平面深度的增量</li>
<li>IP      边所在多边形编号</li>
</ul>
</li>
<li><p>建立多边形Y筒和边Y筒，初始化多边形和边的活化表为空</p>
</li>
<li><p>以<strong>最上面的扫描线</strong>为当前扫描线</p>
</li>
<li><p>对当前扫描线y，把<strong>帧缓冲器相应行置成底色</strong>，<strong>z缓冲器的各单元放z的极小值</strong></p>
</li>
<li><p>检查多边形Y筒</p>
<p>若有新的<strong>多边形</strong>涉及当前扫描线，则把它放入<strong>多边形活化表</strong>中。若有新的多边形加入多边形活化表，则要把该多边形在平面上的投影和<strong>扫描线相交的边对</strong>加入<strong>边活化表</strong>中。</p>
</li>
<li><p><strong>对边活化表中的每个边对</strong>，令$Z_x = Z_l$，对每一个满足$x_l \le x \le x_r$ 的坐标为 $(x,y)$ 的像素从左到右依次进行处理。</p>
<ul>
<li>计算 $z_x = z<em>x + \Delta z</em>{x}$ 这就是对应像素所在平面的深度。如果比z缓冲器相应单元的值大，则要用它来替代原来的值，并把帧缓冲器相应单元内容改成多边形的属性</li>
</ul>
</li>
<li><p>若所有扫描线都已经处理完，则算法结束，否则选下一条扫描线为当前扫描线，转步骤3</p>
</li>
<li><p>每条扫描线处理完后要做如下处理</p>
<ul>
<li><p>修改边活化表，对每一边做如下计算 $y_l = y_l -1 , y_r = y_r-1$ 。若$y_l$ 或$y_r$小于0，则相应边从活化表中去掉，并从边y筒找合适的边来替代。若这两条边同时结束于某一点，则去掉这一边对。</p>
</li>
<li><p>若 y_l 和 y_r都不小于0，则修改 $x_r , x_l , z_l $为</p>
<p>$x_r = x_r + \Delta x_r$  , $x_l = x_l + \Delta x_l$</p>
<p>$z_l = z_l + \Delta z_x \Delta x_l + \Delta z_y$</p>
</li>
<li><p>修改多边形活化表。令 $\Delta y = \Delta y -1$ ，若$\Delta y &lt;0$ ，则将该多边形从多边形活化表中删除</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="优先级排序表算法"><a href="#优先级排序表算法" class="headerlink" title="优先级排序表算法"></a>优先级排序表算法</h4><p>按多边形离观察者的<strong>远近</strong>来建立一个多边形排序表，距离观察着<strong>远的优先级低，近的优先级高</strong>。</p>
<p>多边形排序表建立后，<strong>从优先级低的多边形开始，依次把多边形的颜色填入帧缓冲存储器中</strong>。</p>
<p>表中距观察者近的元素覆盖帧缓冲存储器中原有内容，当优先级最高的多边形送入缓冲器后，整幅图形就形成了。</p>
<p>算法：</p>
<ol>
<li>根据每个多边形顶点z坐标的极小值 $z_{min}$的大小，按由小到大对它们做初步排序，并把它们组成一个链表</li>
<li>若链表中只有一个多边形，则结束算法，否则取表头多边形为P</li>
<li>设Q为链表中P之外的任一多边形。若对所有Q都有$Qz<em>{min}&gt;Pz</em>{min}$，则P不会遮挡其他多边形，为优先级最低的多边形，去除P，转2；否则，若所有Q都满足下面四项条件中的一项，则在链表中去除P，转2。若不满足此四项条件中任何一个的Q，交换P和Q转3。<ol>
<li>P 和Q在oxy平面上投影的边界盒在x或y方向上不相交</li>
<li>P的各顶点均在Q的远离视点一侧</li>
<li>Q的各顶点均在P的靠近视点一侧</li>
<li>P和Q在oxy平面是的投影不相交</li>
</ol>
</li>
</ol>
<h4 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h4><p>光学投射建立在几何光学的基础上，<strong>沿光线的路径追踪可见面</strong>，是一种有效的可见性判别技术。</p>
<p>具体做法：由视点出发穿过观察平面上一像素向场景发射一条射线，求出<strong>射线与场景中各物体表面的交点</strong>，离视点<strong>最近的交点的颜</strong>色即为像素要填的颜色。光线投射算法对于包含<strong>曲面</strong>，特别式包含<strong>球面的场景</strong>有很高的效率。</p>
<h2 id="第九章-简单光照明模型"><a href="#第九章-简单光照明模型" class="headerlink" title="第九章 简单光照明模型"></a>第九章 简单光照明模型</h2><h4 id="简单光照明模型"><a href="#简单光照明模型" class="headerlink" title="简单光照明模型"></a>简单光照明模型</h4><p>光照模型是生成真实感图形的基础。用计算机在图形设备上生成连续色调的真实感图形必须完成四个基本的任务。第一，用数学方法建立所构造三维场景的几何描述，并将其输入计算机。第二，将三维几何转换为二维透视图。通过对场景的透视变换来完成。第三，确定场景中所有可见面。第四，计算场景中可见面的颜色。</p>
<ol>
<li><p>光源</p>
<p>将光源称为<strong>发光体</strong>，反射表面称为<strong>反射光源</strong></p>
<p>光源可分为四类：点光源、线光源、面光源和体光源</p>
</li>
<li><p>材质</p>
<p><strong>材质本身有自己的颜色</strong>。材质的颜色是<strong>由它所反射的光的波长决定的</strong></p>
<ul>
<li>如果光线被投射至一个不透明的物体表面，则<strong>部分光线被反射，部分被吸收</strong>。<ul>
<li>物体表面的材质类型决定了反射光线的强弱。表面光滑较亮的材质将反射较多的入射光，而较暗的表面则吸收较多的入射光。  </li>
</ul>
</li>
<li>同样对于一个<strong>半透明物体的表面，部分入射光会被反射，而另一部分则被折射</strong>。</li>
</ul>
</li>
<li><p>简单光照明模型</p>
<p>简单光照明模型只考虑被照明物体的几何形状对<strong>反射和透射光的影响</strong>，在简单光照模型中，环境假设为由白色照明，且反射光和透射光由用户选定</p>
<ol>
<li><p>环境反射光</p>
<p>环境反射光是由环境光在邻近物体上经过多次反射所产生的。</p>
<p>亮度表示为： $I_a=k<em>aI</em>{pa}$，其中 $I<em>a$是物体的<strong>环境反射光亮度</strong>，$I</em>{pa}$为<strong>环境光亮度</strong>，$k_a$为<strong>物体表面光反射系数</strong></p>
</li>
<li><p>漫反射光</p>
<p>一个<strong>比较粗糙</strong>的，<strong>无光照的物体表面对光的反射</strong>表现为漫反射。</p>
<p>郎伯定律指出：对于一个漫反射体，表面的反射光亮度和光源入射角的余弦成正比：$I_d =k<em>dI</em>{pd}\cos i$，其中$I<em>d$为物体表面漫反射光的光亮度，$I</em>{pd}$为光源垂直入射时反射光的光亮度，$i$为光源入射角，$k_d$为漫反射系数</p>
<p>当观察漫反射物体时，人眼接受到光亮度和观察者的位置无关</p>
<p>对漫反射物体，它的表面除受特定光源照射之外，还受到从环境来的反射光的照射</p>
</li>
<li><p>镜面反射光</p>
<p>镜面反射光为朝一定方向的反射光。根据光的反射定律，反射光和入射光对称地分布于表面法向的两侧。</p>
</li>
<li><p>综和</p>
<p>物体表面上任意一点射向视点的光亮度I应该为环境光、漫反射光和镜面反射光的总和。$k_a, k_d , k_s$分别表示环境反射，漫反射和镜面反射分量的比例系数，简单光照明模型为：</p>
<p> $$I=k<em>aI</em>{pa}+k<em>dI</em>{pd}\cos i+k<em>sI</em>{ps}\cos ^n \theta$$</p>
<p>当光源有多个时，则上式可写为$$I=k<em>aI</em>{pa}+\sum( k<em>dI</em>{pd}\cos i+k<em>sI</em>{ps}\cos ^n \theta)  $$</p>
<p>其中$k_d+k_s=1$，该模型也称为Phong模型。Phong模型实际上是纯几何模型</p>
</li>
</ol>
</li>
</ol>
<h4 id="光滑明暗处理技术"><a href="#光滑明暗处理技术" class="headerlink" title="光滑明暗处理技术"></a>光滑明暗处理技术</h4><p>通常的多边形扫描线算法来绘制这种近似表示的物体，<strong>生成的图形将失去原有曲面的光滑性</strong>，呈现多面体形状。</p>
<p>由于不同平面片之间不存在不连续的法向量，导致多个平面篇表示的物体表面光亮度呈现不连续跃变。</p>
<ol>
<li><p>Gouraud明暗处理技术</p>
<p>将曲面表面某一点的光亮度做近似表示，近似值为该曲面的各多边形顶点光亮度的<strong>双线性插值</strong>。</p>
<p>步骤：</p>
<p>线性插值</p>
<p>在Gouraud明暗处理中，计算多边形顶点的光亮度可以通过简单光照明模型计算。</p>
<p><strong>Gouraud明暗处理不能正确地模拟高光</strong>，因为采用光亮度插值后将使多边形内的高光丢失</p>
<p><strong>Gouraud明暗处理所绘制画面会诱发马赫带效应</strong>，光亮度双线性插值保证了由多边形近似表示的曲面上各处光亮度的连续变化，但在相邻多边形的公共边界上光亮度的一阶导数并不连续，由于人眼光学错觉，光亮度变化一阶不连续的边界处会呈现亮带或黑带</p>
</li>
<li><p>Phong明暗处理技术</p>
<p>法向量插值明暗处理。增加一定计算量客服了Gouraud明暗处理的缺点。</p>
<p>基本思想：<strong>对多边形顶点处法向量做双线性插值，在多边形内构造一个连续变化的法向量函数，依据函数计算多边形内各采用点的法向量带入光亮度计算公式</strong></p>
</li>
</ol>
<h2 id="第十章-Bezier曲线曲面"><a href="#第十章-Bezier曲线曲面" class="headerlink" title="第十章 Bezier曲线曲面"></a>第十章 Bezier曲线曲面</h2><p>在计算机图形学中，常用的曲线曲面的类型有Bezier曲线曲面、B样条曲线曲面、孔斯曲面，这些曲线曲面采用分段和分片参数多项式的形式。曲线曲面的形状不依赖于坐标系的选择，<strong>人机交互直观，易于计算，易于拼接，造型灵活等</strong></p>
<h4 id="曲线曲面的基础知识"><a href="#曲线曲面的基础知识" class="headerlink" title="曲线曲面的基础知识"></a>曲线曲面的基础知识</h4><ol>
<li><p>曲线的表示</p>
<ol>
<li><p>显示表示</p>
<p>对于一条曲线，一个坐标变量显示地表示为另一个变量的函数。在平面曲线的显示表示中，每一个x只对应一个y值，所以显示方程不能表示封闭或多值曲线，例如圆。</p>
</li>
<li><p>隐式表示</p>
<p>平面曲线隐式表示的一半形式为$f(x,y)=0$。</p>
<p>存在问题：1. 与坐标系相关 2.会出现斜率为无穷大的情况 3.非平面曲线难用常系数的非参数化函数表示 4.不利于计算和编程</p>
</li>
<li><p>参数表示</p>
<p>将曲线上各点的坐标显示地表示成参数的函数形式，若去参数为t，曲线的参数表示为</p>
<p>$$P(t) = (x(t),y(t),z(t)) , t \in [0,1]$$</p>
<p>其中，$x(t),y(t)$和$z(t)$分别为t的显示函数，即每一个t对应空间一个点$(x(t),y(t),z(t))$</p>
<p>在曲线曲面的表示上，参数表示比非参数表示具有更大的优越：</p>
<ul>
<li>参数方程形式不依赖于坐标系的选取，具有形状不变性</li>
<li>在参数表示中，变化率以切实量来表示，不会出现无穷大的情况</li>
<li>对参数表示的曲线、曲面进行平移、缩放和旋转等几何变换比较容易</li>
<li>用参数表示的曲线曲面的交能力强，参数表示式中系数的几何意义明确，并提高了自由度，以便控制形状</li>
</ul>
</li>
</ol>
</li>
<li><p>参数曲线的切矢量、弧长、法矢量和曲率</p>
<ol>
<li><p>位置矢量</p>
<p>曲线上任一点的位置矢量可表示为  $P(t) = (x(t),y(t),z(t)) , t \in [0,1]$</p>
</li>
<li><p>切矢量</p>
</li>
<li><p>弧长</p>
</li>
<li><p>曲率</p>
</li>
<li><p>主法矢量和副法矢量</p>
</li>
</ol>
</li>
</ol>
<h4 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h4><p>Bezier曲线是一段n次多项式曲线，是构造<strong>自由曲线曲面</strong>的重要和基本方法之一。它有许多优点，如果保凸性，凸包性，曲线形状不依赖于坐标系选择，人机交互灵活</p>
<ol>
<li><p>曲线的定义</p>
<p>在空间给定n+1个点$P_0,P_1,…,P_n$，称下列参数多项式曲线为n次Bezier曲线</p>
<p>$$P(t)=\sum ^n_{i=0} P<em>iJ</em>{i,n}(t)$$</p>
<p>其中$ J_{i,n}$是Bernstein基函数</p>
<p> $$J_{i,n}(t)=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i} $$</p>
<p>折现$P_0,P_1,…,P_n$称为P(t)的<strong>控制多边形</strong>，$P_0,P_1,…,P_n$个各点成为P(t)的<strong>控制顶点</strong>。控制多边形是对Bezier曲线P(t)的大致勾画，P(t)是对控制多边形的逼近。</p>
</li>
<li><p>曲线的性质</p>
<ol>
<li>非负性    $ J_{i,n}(t) \ge 0$</li>
<li>权性    $\sum ^n<em>{i=0} J</em>{i,n}(t) \equiv 1$</li>
<li>对称性   $J<em>{i,n}(t) = J</em>{n-i,n}(1-t) ,i=0,1,…,n$</li>
<li>导函数   </li>
<li>最大值</li>
<li>地推公式</li>
<li>升阶</li>
</ol>
<p>例子</p>
</li>
<li><p>Bezier曲线的性质</p>
<ol>
<li><p>端点的位置</p>
<p>Bezier曲线的起点为$P_0$，终点为$P_n$，即 $P(0) = P_0 , P(1)=P_n$</p>
</li>
<li><p>端点的切线</p>
<p>Bezier曲线$P(t)$在起点$P_0$处与边 $\overline {P_0P_1}$相切，在终点P<em>n点处与边$\overline {P</em>{n-1}P_n}$相切，即 $P’(0) = n(P_1-P_0)，P’(1)=n(P<em>n-P</em>{n-1})$</p>
</li>
<li><p>端点的曲率 </p>
</li>
<li><p>仿射不变形</p>
<p>Bezier曲线的形状和位置仅与它的控制顶点的位置有关，与仿射坐标系无关。</p>
</li>
<li><p>凸包性</p>
<p>点集的凸包是指包含这些点的最小凸集。由于权性，对某个值t，点P(t)是各个控制顶点$P_i$的凸线性组合。</p>
</li>
<li><p>交互能力</p>
<p>可以通过改变控制多边形的形状来改变$P(t)$的形状</p>
</li>
<li><p>变差缩减性</p>
<p>平面内一直线与$P(t)$的交点个数不多于该直线与控制多边形的交点个数</p>
</li>
<li><p>保凸性</p>
<p>如果控制多边形是个封闭的平面凸多边形，则Bezier曲线是一段凸的平面曲线</p>
</li>
</ol>
</li>
<li><p>Bezier曲线性质进一步讨论</p>
</li>
</ol>
<h2 id="考试题型："><a href="#考试题型：" class="headerlink" title="考试题型："></a>考试题型：</h2><p>简答题（5个）</p>
<p>综合题（4个）</p>
<ul>
<li><p>填充</p>
</li>
<li><p>变换</p>
</li>
<li><p>裁剪</p>
</li>
<li><p>投影</p>
<p>强调联系的内容</p>
</li>
</ul>
<p>计算题（2个）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/信息检索专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/IMG_7853.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/05/信息检索专题复习/" itemprop="url">
                  信息检索专题复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T19:27:51+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h1><p>Made by ® Isaac. Ty </p>
<p>信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型</p>
<h4 id="IR新课题"><a href="#IR新课题" class="headerlink" title="IR新课题"></a>IR新课题</h4><ul>
<li>自然语言理解</li>
<li>多媒体检索</li>
<li>垂直检索技术</li>
<li>移动搜索</li>
<li>对社会媒体信息检索</li>
<li>问答</li>
<li>知识发现</li>
<li>行为分析、舆情控制</li>
<li>自动对话</li>
</ul>
<h2 id="2-布尔检索"><a href="#2-布尔检索" class="headerlink" title="2.布尔检索"></a>2.布尔检索</h2><h3 id="信息检索模型概述"><a href="#信息检索模型概述" class="headerlink" title="信息检索模型概述"></a>信息检索模型概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="文档表示"><a href="#文档表示" class="headerlink" title="文档表示"></a>文档表示</h5><p>一个文档被表示为<strong><u>关键词</u></strong>(bag of words)的集合</p>
<h5 id="查询表示"><a href="#查询表示" class="headerlink" title="查询表示"></a>查询表示</h5><p>查询式（Queries）被表示为<strong><u>关键词的布尔组合</u></strong>，用“与、或、非”连接起来（主析取范式）</p>
<h5 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h5><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是二值匹配</li>
</ul>
<h5 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h5><p>没有清晰和明显的语义结构的数据，计算机不易处理这些数据</p>
<h5 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h5><p>最典型的时关系数据库，用来保存公司的产品清单和人事记录</p>
<h5 id="聚类（clustering）"><a href="#聚类（clustering）" class="headerlink" title="聚类（clustering）"></a>聚类（clustering）</h5><p>基于文档内容进行自动聚团的任务。很像在书架上将一系列书按照它们所属的主题重新摆放的过程。</p>
<h5 id="分类（classification）"><a href="#分类（classification）" class="headerlink" title="分类（classification）"></a>分类（classification）</h5><p>根据<strong><u>给定的主题</u></strong>、固定的信息需求或者其他类别体系，将每一个文档分到一个或多个类别的任务。</p>
<h4 id="布尔模型：优缺点"><a href="#布尔模型：优缺点" class="headerlink" title="布尔模型：优缺点"></a>布尔模型：优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>查询<strong>简单</strong>，容易理解</li>
<li>通过使用复杂的布尔表达式，可方便地控制查询结果</li>
<li>相当有效的实现方法</li>
<li>经过某种训练的用户可以容易地写出布尔查询式</li>
<li>布尔模型可以通过扩展来包含排序的功能</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><strong>弱</strong>，不支持部分匹配，完全匹配会导致结果太多或太少</li>
<li>非常<strong>刚性</strong>：“与”意味着全部；“或”意味着任何一个，所有匹配文档都将被返回</li>
<li>不考虑索引词的权重，所有文档都以相同的方式和查询相匹配</li>
<li>很难进行自动的相关反馈</li>
</ul>
<h4 id="信息检索的基本假设"><a href="#信息检索的基本假设" class="headerlink" title="信息检索的基本假设"></a>信息检索的基本假设</h4><ul>
<li>集合：固定数量的文档</li>
<li>目标：找到与用户信息需求相关的含有信息量的文档，帮助用户完成一个任务。</li>
</ul>
<h4 id="典型的搜索模型"><a href="#典型的搜索模型" class="headerlink" title="典型的搜索模型"></a>典型的搜索模型</h4><ul>
<li><strong>构造矩阵→信息需求→文字形式→查询→查询优化→结果</strong></li>
</ul>
<h4 id="返回文档的好坏"><a href="#返回文档的好坏" class="headerlink" title="返回文档的好坏"></a>返回文档的好坏</h4><h5 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h5><p>返回的能满足用户信息需求的文档占<strong>总的返回文档</strong>的百分比</p>
<h5 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h5><p>返回的能满足用户信息需求的文档占<strong>总的能满足用户信息需求的文档</strong>的百分比</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><ul>
<li>对于每一个词项，存储所有包含这个词项的文档的一个<u><strong>列表</strong></u>。一个文档用一个<strong><u>序列号</u></strong>docID来表示</li>
<li>应当使用可变长度的记录表<ul>
<li>在硬盘上，一串连续的记录是正常的，也是最好的</li>
<li>在内存里，可以使用链表，或者可变长度的数组</li>
</ul>
</li>
</ul>
<h4 id="倒排索引建立步骤"><a href="#倒排索引建立步骤" class="headerlink" title="倒排索引建立步骤"></a>倒排索引建立步骤</h4><ol>
<li>收集需要建立索引的文档</li>
<li>将每篇文档转换成一个个词条（token）的列表，此个过程称为词条化（tokenization)</li>
<li>进行语言预处理，产生归一化的词条来作为词项</li>
<li>对所有文档按照其中出现的词项来建立倒排索引，索引中包括一部分词典和一个全体倒排索引表</li>
</ol>
<ul>
<li>词条序列Token Sequence</li>
</ul>
<p>（修改过的词条，文档ID）对序列</p>
<ul>
<li><p>排序</p>
<p>先按照词条排序，再按照docID排序</p>
</li>
<li><p>词典和倒排表</p>
<ul>
<li>同一篇文档中多次出现的词被合并</li>
<li>分割成<strong>词典</strong>和<strong>倒排表</strong></li>
<li>词汇的<strong><u>文档频率</u></strong>也被记录</li>
</ul>
</li>
<li><p>查询的处理:AND</p>
<ul>
<li>考虑这样的查询： Brutus AND Caesar<ul>
<li>在字典中找到Brutus，得到它的倒排记录表</li>
<li>在字典中找到Caesar，得到它的倒排记录表</li>
<li>合并两个倒排列表</li>
<li>同时扫描两个倒排记录表求交集，所需时间和倒排记录的数量呈线性关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="布尔检索模型"><a href="#布尔检索模型" class="headerlink" title="布尔检索模型"></a>布尔检索模型</h3><h4 id="文档表示-1"><a href="#文档表示-1" class="headerlink" title="文档表示"></a>文档表示</h4><p>一个文档被表示为关键词的集合</p>
<h4 id="查询表示-1"><a href="#查询表示-1" class="headerlink" title="查询表示"></a>查询表示</h4><p>查询式(Queries)被表示为<strong>关键词的布尔组合</strong>，用“与、或、非”连接起来(主析取范式DNF)</p>
<h4 id="相关度计算-1"><a href="#相关度计算-1" class="headerlink" title="相关度计算"></a>相关度计算</h4><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是<strong>二值匹配</strong>{0,1}</li>
</ul>
<h4 id="形式化表示"><a href="#形式化表示" class="headerlink" title="形式化表示"></a>形式化表示</h4><ol>
<li>定义：用q~dnf~ 表示查询q的析取范式，q~cc~表示q~dnf~的任意合取分量</li>
<li>文献d~j~与查询q的相似度为</li>
</ol>
<h4 id="布尔检索模型：布尔代数"><a href="#布尔检索模型：布尔代数" class="headerlink" title="布尔检索模型：布尔代数"></a>布尔检索模型：布尔代数</h4><h5 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h5><ul>
<li>只有“真”、“假”取值的变量</li>
</ul>
<h5 id="布尔操作（关系）"><a href="#布尔操作（关系）" class="headerlink" title="布尔操作（关系）"></a>布尔操作（关系）</h5><h5 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h5><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>布尔模型可以用来处理布尔表达式形式的查询</p>
<ul>
<li>布尔查询使用AND,OR和NOT来连接查询词汇<ul>
<li>将文档看作词汇的集合</li>
<li>精确：匹配或不匹配</li>
</ul>
</li>
<li>布尔模型式IR系统中最简单的模型</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul>
<li>按照文档频率的顺序进行处理。先处理文档频率小的，再处理大的。</li>
</ul>
<h2 id="3-词项词典和倒排记录表"><a href="#3-词项词典和倒排记录表" class="headerlink" title="3.词项词典和倒排记录表"></a>3.词项词典和倒排记录表</h2><h3 id="建立词项词典"><a href="#建立词项词典" class="headerlink" title="建立词项词典"></a>建立词项词典</h3><h4 id="文档解析"><a href="#文档解析" class="headerlink" title="文档解析"></a>文档解析</h4><ul>
<li>文档格式</li>
<li>文档中的语言</li>
<li>文档的编码方式</li>
</ul>
<h4 id="词条化"><a href="#词条化" class="headerlink" title="词条化"></a>词条化</h4><ul>
<li><p>将给定的字符序列拆分成一系列子序列的过程，其中每一个子序列称之为一个“词</p>
<p>条”Token。</p>
</li>
<li><p>词条(Tokens)、词项(Terms)</p>
</li>
<li><p>针对不同的语言，采用不同策略的词条化方法</p>
</li>
<li><p>分词的基本方法：</p>
<ul>
<li>基于词典的最大匹配法</li>
<li>机器学习方法</li>
</ul>
</li>
</ul>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><ul>
<li>停用词表：将词项按照<strong>文档集频率</strong>，从高到低排列。选取与文档意义不大，<strong>高频</strong>出现的词，例如a ,an , the , and, ….</li>
<li>优点：停用词消除可以减少term的个数</li>
<li>缺点：有时消除的停用词对检索有意义的 。 的士 ， to be or not to be</li>
<li>消除方法：查表法，基于文档频率</li>
</ul>
<h4 id="词项归一化"><a href="#词项归一化" class="headerlink" title="词项归一化"></a>词项归一化</h4><ul>
<li>将不完全一致的多个词条归纳成一个等价类，以便在它们之间进行匹配。</li>
<li>归一化结果：在IR系统的词项词典中，形成多个<strong>近似词项的一个等价类</strong></li>
<li>归一化策略：建立同义词扩展表</li>
</ul>
<h4 id="词干还原"><a href="#词干还原" class="headerlink" title="词干还原"></a>词干还原</h4><ul>
<li><strong>很粗略的去除单词两端的词缀的启发式过程</strong></li>
<li>能提高召回率，但是会降低准确率</li>
<li>porter算法</li>
</ul>
<h4 id="词形归并"><a href="#词形归并" class="headerlink" title="词形归并"></a>词形归并</h4><ul>
<li>利用词汇表和词形分析来减少曲折变化的形式，将其转变为基本形式 </li>
<li>词形归并可以减少词项词典中的词项数量</li>
</ul>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>词干还原在一般情况下会将多个派生相关词合并在一起</li>
<li>词形归并通常只将同一词元的不同曲折形式进行合并</li>
</ul>
<h3 id="实现倒排记录表"><a href="#实现倒排记录表" class="headerlink" title="实现倒排记录表"></a>实现倒排记录表</h3><h4 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h4><ul>
<li>通过在两个倒排表之间同时移动指针来实现合并，此时的操作与线性表的总数成线性关系。</li>
</ul>
<h4 id="基于调表的倒排记录表快速合并算法"><a href="#基于调表的倒排记录表快速合并算法" class="headerlink" title="基于调表的倒排记录表快速合并算法"></a>基于调表的倒排记录表快速合并算法</h4><ul>
<li>跳表指针能够跳过那些不可能出现在检索结果中的记录项</li>
<li>如果倒排表的长度是L，那么在每个$\sqrt L$处均放置跳表指针</li>
<li>跳表指针只对AND类型查询有用，对OR类型查询不起作用</li>
</ul>
<h4 id="短语查询"><a href="#短语查询" class="headerlink" title="短语查询"></a>短语查询</h4><h5 id="二元词索引"><a href="#二元词索引" class="headerlink" title="二元词索引"></a>二元词索引</h5><ul>
<li>将文档中每个连续词对看成一个短语，其中的每个二元词对豆浆作为词典中的词项。</li>
</ul>
<h5 id="扩展的二元词索引"><a href="#扩展的二元词索引" class="headerlink" title="扩展的二元词索引"></a>扩展的二元词索引</h5><h5 id="位置信息索引"><a href="#位置信息索引" class="headerlink" title="位置信息索引"></a>位置信息索引</h5><ul>
<li><p>在此索引中，对每个词项，都采取以下方式存储倒排表记录：</p>
<p> &lt;词项，词项频率;</p>
<p>   文档1：位置1，位置2，……</p>
<p>   文档2：位置1，位置2，……</p>
</li>
</ul>
<h2 id="4-索引构建"><a href="#4-索引构建" class="headerlink" title="4.索引构建"></a>4.索引构建</h2><h3 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h3><h3 id="语资料库"><a href="#语资料库" class="headerlink" title="语资料库"></a>语资料库</h3><h3 id="索引构建算法"><a href="#索引构建算法" class="headerlink" title="索引构建算法"></a>索引构建算法</h3><h4 id="基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）"><a href="#基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）" class="headerlink" title="基于块的排序索引算法（BSBI：Blocked sort-based Indexing）"></a>基于块的排序索引算法（BSBI：Blocked sort-based Indexing）</h4><ul>
<li>在索引构建过程中需要依次分析所有的文档，不能很容易利用压缩技巧。只有分析完所有文档，最终的倒排记录表才会完整。</li>
</ul>
<ul>
<li>基本思想：对每一个<strong>块</strong>都生成倒排记录，并排序，写入硬盘。然后将这些块<strong>合并</strong>成一个长的排好序的倒排记录。</li>
<li>每条数据占用12字节（4+4+4）（词项，文档，频数）</li>
<li>在内存中处理，累积放满固定的块，排序后写入硬盘f~i~ ，合并所有索引文件成一个</li>
</ul>
<h5 id="基于BSBI排序算法存在的问题"><a href="#基于BSBI排序算法存在的问题" class="headerlink" title="基于BSBI排序算法存在的问题"></a>基于BSBI排序算法存在的问题</h5><ul>
<li>假设能够将<strong><u>词典存入内存</u></strong>中</li>
<li>需要该词典动态增长去查找任一词项和词项ID之间的对应关系。</li>
<li>（一个可扩展的，但效率非常低的构建索引算法）</li>
</ul>
<h4 id="内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing"><a href="#内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing" class="headerlink" title="内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)"></a>内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)</h4><ul>
<li><p>核心思想：为每个块<strong>单独</strong>生成一个词典—— （不需要维护全局的&lt;词项,词项ID&gt;映射表）</p>
</li>
<li><p><strong>不进行排序</strong>。有新的&lt;词项,文档ID&gt;对时直接在倒排记录表中增加一项。</p>
<ul>
<li>可以为每个块生成一个完整的倒排索引，然后将这些单独的索引合并为一个大的索引</li>
</ul>
</li>
<li>压缩技术将会使SPIMI算法更加高效<ul>
<li>压缩词项</li>
<li>压缩倒排记录表</li>
</ul>
</li>
</ul>
<h4 id="分布式索引构建（Distributed-indexing）"><a href="#分布式索引构建（Distributed-indexing）" class="headerlink" title="分布式索引构建（Distributed indexing）"></a>分布式索引构建（Distributed indexing）</h4><ul>
<li><p>Web规模的索引构建</p>
<p>必须使用一个分布式的计算机集群</p>
</li>
<li><p>计算机都是故障频发的</p>
<ul>
<li>可能会在任意时刻失效</li>
</ul>
</li>
<li><p>利用集群中的主控节点来指挥索引构建工作</p>
<ul>
<li>认为主控节点是“安全的”</li>
</ul>
</li>
<li><p>将索引构建过程<strong>分解</strong>成一组并行的任务</p>
</li>
<li><p>主控计算机从集群中选取一台空闲的机器并将<strong>任务分配</strong>给它</p>
</li>
<li><p>采用两组不同的并行任务</p>
<ul>
<li><p>Parsers分析器</p>
<ol>
<li><p>主节点将一个数据片分配给一台空闲的分析服务器</p>
</li>
<li><p>分析器依次读取文档并生成&lt;词项,文档&gt;对。</p>
</li>
<li><p>分析器将这些&lt;词项,文档&gt;按照<em><strong>词项对</strong></em>分成$j$个段</p>
</li>
<li><p>每一段是按照词项首字母划分的一个区间。</p>
<p>例如：a-f,g-p,q-z 这里j=3</p>
</li>
<li><p>然后进行索引的倒排</p>
</li>
</ol>
</li>
<li>Inverters倒排器<ol>
<li><strong><em>对于一个词项分区</em></strong>，倒排器收集所有的&lt;词项,文档&gt;对（倒排记录）。</li>
<li>排序，并写入最终的倒排记录表。</li>
</ol>
</li>
</ul>
</li>
<li><p>首先，将输入文档集分割成n个数据片</p>
<ul>
<li>每个数据片就是一个文档子集（与BSBI/SPIMI算法中的数据块相对应）</li>
<li>两种分割方法<ul>
<li>基于词项的分割</li>
<li>基于文档的分割</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="数据流图"></p>
</li>
</ul>
<h3 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h3><h4 id="动态索引构建方法"><a href="#动态索引构建方法" class="headerlink" title="动态索引构建方法"></a>动态索引构建方法</h4><p>文档集通常不是静态的</p>
<ul>
<li>文档会不断的加入进来</li>
<li>文档也会被删除或者被修改</li>
</ul>
<p>词典和倒排记录表需要修改</p>
<ul>
<li>对于已在词典中的词项更新倒排记录</li>
<li>新的词项加入到词典中</li>
</ul>
<ol>
<li>周期性索引重构</li>
</ol>
<ul>
<li>建立索引的同时，旧索引继续工作</li>
<li>条件<ul>
<li>更新次数不是很多</li>
<li>能够接受对新文档检索的一定延迟（重构之前新文档检索不到）</li>
<li>有足够的资源进行重构</li>
</ul>
</li>
</ul>
<ol>
<li>维护一个大的主索引<ul>
<li>新文档信息存储在一个小的<strong>辅助索引</strong>中（位于内存）</li>
<li>检索可以同时遍历两个索引并将结果<strong>合并</strong></li>
<li>删除<ul>
<li>文档的删除记录在一个<strong>无效位向量</strong>中</li>
<li>在返回结果前利用它过滤掉已删除文档</li>
</ul>
</li>
<li>定期地将辅助索引合并到主索引中</li>
<li>文档更新通过先删除后插入的方式实现</li>
</ul>
</li>
</ol>
<h4 id="主索引与辅助索引存在的问题"><a href="#主索引与辅助索引存在的问题" class="headerlink" title="主索引与辅助索引存在的问题"></a>主索引与辅助索引存在的问题</h4><ul>
<li>频繁的合并带来很大开销</li>
<li>合并过程效率低<ul>
<li>如果每个词项的倒排记录表都单独成一个文件，那么合并主索引和辅助索引将会很高效。</li>
<li>合并是一个简单的添加操作</li>
<li>需要使用很多倒排文件—— 对文件系统来说是低效的</li>
</ul>
</li>
</ul>
<h4 id="对数合并"><a href="#对数合并" class="headerlink" title="对数合并"></a>对数合并</h4><ul>
<li>维护一系列索引$I_0, I_1 , I_2, … ,$每个都是前一个的两倍大小</li>
<li>辅助索引$Z_0$存储在内存中，而较大的（$I_0, I_1 , I_2, … ,$）存储在磁盘中</li>
<li>当$Z_0$达到上限时，将它写入磁盘$I_0$中，当下一次达到上限时，它会和$I_0$合并，生成$Z_1$<ul>
<li>此时，如果$I1$不存在，存储到$I1$中</li>
<li>如果$I1$已存在，则$Z1$与$I1$合并成$Z2 $(大小$2^{2*n}$)</li>
<li>此时，如果$I2$不存在，存储到$I2$中</li>
<li>如果$I2$已存在，则$Z2$与$I2$合并成Z3 (大小$2^{2*n}$)</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="4-索引压缩"><a href="#4-索引压缩" class="headerlink" title="4.索引压缩"></a>4.索引压缩</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>节省磁盘空间</li>
<li>提高内存的利用率（加快速度）</li>
<li>加快数据从磁盘到内存的传输速度<ul>
<li>[读取压缩数据][解压缩] 比直接 [读取未压缩的数据]快</li>
<li>前提：解压缩算法要很快</li>
</ul>
</li>
</ul>
<h4 id="压缩倒排索引的原因"><a href="#压缩倒排索引的原因" class="headerlink" title="压缩倒排索引的原因"></a>压缩倒排索引的原因</h4><ul>
<li>词典<ul>
<li>压缩的足够小以便放入内存中</li>
<li>当词典足够小时，也可以在内存中存储一部分倒排索引记录表</li>
</ul>
</li>
<li>倒排记录文件<ul>
<li>减少所需要的磁盘空间</li>
<li>减少从磁盘读取倒排记录文件所需的时间</li>
<li>大的搜索引擎在内存中存储了很大一部分倒排记录表<ul>
<li>压缩可以在内存中存储的更多</li>
</ul>
</li>
</ul>
</li>
<li>将涉及各种基于IR系统的压缩架构</li>
</ul>
<h3 id="词项统计量"><a href="#词项统计量" class="headerlink" title="词项统计量"></a>词项统计量</h3><h3 id="词典压缩"><a href="#词典压缩" class="headerlink" title="词典压缩"></a>词典压缩</h3><h4 id="有损压缩和无损压缩"><a href="#有损压缩和无损压缩" class="headerlink" title="有损压缩和无损压缩"></a>有损压缩和无损压缩</h4><ul>
<li>无损压缩：压缩之后所有原始信息都被保留<ul>
<li>在IR系统中常采用无损压缩</li>
</ul>
</li>
<li>有损压缩：丢掉一些信息</li>
<li>一些<strong>预处理步骤可以看成是有损压缩</strong>：大小写转化，停用词剔除，词干还原，数字去除等</li>
<li>有损还是无损与需求相关</li>
</ul>
<h4 id="Heaps定律：M-kT-b"><a href="#Heaps定律：M-kT-b" class="headerlink" title="Heaps定律：M=kT^b^"></a>Heaps定律：M=kT^b^</h4><ul>
<li>M是<strong>词项</strong>的数目，T是文档集中<strong>词条</strong>的个数</li>
<li>词汇量大小M和文档集大小T在对数空间存在斜率为1/2的线性关系。</li>
<li><strong>不同单词的数目与文本篇幅之间存在幂函数的关系</strong>，其幂指数小于1</li>
<li><strong>提供了对文档集中词汇量的估计</strong></li>
</ul>
<h4 id="Zipf定律"><a href="#Zipf定律" class="headerlink" title="Zipf定律"></a>Zipf定律</h4><ul>
<li><strong>词项在文档中的分布情况</strong></li>
</ul>
<ul>
<li>排名<strong>第i多</strong>的词项的文档集频率与1/i成正比</li>
<li>词项t~i~在文档集中出现的次数</li>
<li><strong>高频词项很少，低频罕见词项很多</strong></li>
</ul>
<h4 id="为什么要压缩词典"><a href="#为什么要压缩词典" class="headerlink" title="为什么要压缩词典"></a>为什么要压缩词典</h4><ul>
<li>搜索从词典开始</li>
<li>想将词典放入内存中和其他应用程序共享内存资源</li>
<li>手机或者嵌入式设备通常只有很小的内存</li>
<li>即使不在内存中，也希望足够小以便搜索能够快速启动</li>
</ul>
<h4 id="压缩词项列表：将词典看成单一字符串"><a href="#压缩词项列表：将词典看成单一字符串" class="headerlink" title="压缩词项列表：将词典看成单一字符串"></a>压缩词项列表：将词典看成单一字符串</h4><ul>
<li>将所有词项存储为一个长字符串<ul>
<li>指向下一词项的指针同时也标识着当前词项的结束</li>
<li>期望节省60%词典空间</li>
</ul>
</li>
</ul>
<h4 id="按块存储（Blocking）"><a href="#按块存储（Blocking）" class="headerlink" title="按块存储（Blocking）"></a>按块存储（Blocking）</h4><ul>
<li>每k个词项分词一块，只保留第一个指针</li>
<li>需要存储词项长度（额外一字节）</li>
</ul>
<h4 id="前端编码"><a href="#前端编码" class="headerlink" title="前端编码"></a>前端编码</h4><ul>
<li>按照词典顺序排列的连续词项之间往往具有<strong>公共前缀</strong></li>
<li>（块内k个词项的最后k-1个）</li>
</ul>
<h3 id="倒排记录表压缩"><a href="#倒排记录表压缩" class="headerlink" title="倒排记录表压缩"></a>倒排记录表压缩</h3><ul>
<li>倒排记录表远大于词典，至少10倍</li>
<li>紧密地存储每一个倒排记录表</li>
<li>每个倒排记录用<strong>文档ID</strong>来定义</li>
</ul>
<h4 id="倒排记录表：相反的两点"><a href="#倒排记录表：相反的两点" class="headerlink" title="倒排记录表：相反的两点"></a>倒排记录表：相反的两点</h4><ul>
<li>像“arachnocentric”这样的词项可能在一百万 个文档中才会出现一次 可以用log21M ≈ 20 bits来存储这一倒排记录。</li>
<li>像“the”这样的词项在每个文档中都会出现， 所以对它采用20bit/倒排记录太浪费了。<ul>
<li>这种情况更希望是0/1的bit向量<h4 id="倒排记录表项中文档ID的间距（GAP）"><a href="#倒排记录表项中文档ID的间距（GAP）" class="headerlink" title="倒排记录表项中文档ID的间距（GAP）"></a>倒排记录表项中文档ID的间距（GAP）</h4></li>
</ul>
</li>
<li>按照文档ID的递增顺序来存储一个词项的倒排列表<ul>
<li>Computer： 33，47，154，159，202，…</li>
</ul>
</li>
<li>可以存储间距<ul>
<li>33，14，107，5，43，…</li>
</ul>
</li>
<li>期望：绝大多数间距存储空间都远小于20bit</li>
</ul>
<h4 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h4><ul>
<li>目标：<ul>
<li>对于arachnocentric，使用20bit/间距项</li>
<li>对于the，使用1 bit/间距项</li>
</ul>
</li>
<li>如果词项的评价间距为G，我们想使用log2Gbit/间距项</li>
<li>关键问题：需要利用整个字节对每个间距编码<ul>
<li>可变长度编码：对一些小数字用短码来实现</li>
</ul>
</li>
<li>可变字节码：<ul>
<li>用一个字节来存储G，并分配1bit作为延续位</li>
<li>G$\le$127 对7位有效码采用二进制编码并设置延续位c=1（结束)</li>
<li>G$&gt;$127 则先对G低阶的7位编码，然后采用相同的算法用额外字节对高阶bit位进行编码</li>
<li>设置最后一个字节的延续位为1（c=1)，其他字节的c=0（未结束）</li>
</ul>
</li>
</ul>
<h2 id="5-Web搜索"><a href="#5-Web搜索" class="headerlink" title="5.Web搜索"></a>5.Web搜索</h2><h3 id="Web搜索基础"><a href="#Web搜索基础" class="headerlink" title="Web搜索基础"></a>Web搜索基础</h3><h4 id="重复文档"><a href="#重复文档" class="headerlink" title="重复文档"></a>重复文档</h4><ul>
<li>完全复制Duplication ： 可以通过指纹（fingerprints）来检测精确匹配</li>
<li>近似重复Near-Duplication：通过编辑距离计算语法上的相似性</li>
</ul>
<h4 id="相似性计算"><a href="#相似性计算" class="headerlink" title="相似性计算"></a>相似性计算</h4><ul>
<li>搭叠Shingles（N元词N-Grams）<ul>
<li>给定正整数K及文档d的一个词项序列可以定义文档d的k-shingle为d中所有k个连续词项构成的序列</li>
</ul>
</li>
<li>Jaccard系数：衡量重复度<ul>
<li>表示公式： 交集 / 并集</li>
<li>计算所有文档对之间搭叠的<strong>精确交集</strong>非常费时而且难以处理</li>
<li>使用冲Shingles中选出一个<strong>子集</strong>（素描sketch）来近似计算（抽样Sample）</li>
</ul>
</li>
</ul>
<h4 id="小结：近似重复检测"><a href="#小结：近似重复检测" class="headerlink" title="小结：近似重复检测"></a>小结：近似重复检测</h4><ul>
<li>Shingle算法的核心思想是将<strong>文件相似性</strong>问题转换为<strong>集合的相似</strong>性问题</li>
<li>数量较大时，对Shingle集合进行<strong>抽样</strong>，以降低空间和时间计算复杂性</li>
<li>shingle取样三种方法：Min-Wise,Modm,Mins</li>
</ul>
<h3 id="Web采集"><a href="#Web采集" class="headerlink" title="Web采集"></a>Web采集</h3><h4 id="采集器"><a href="#采集器" class="headerlink" title="采集器"></a>采集器</h4><ol>
<li>从已知种子URL开始</li>
<li>获取页面并解析<ol>
<li>提取页面中包含的链接</li>
<li>将链接放入URL队列</li>
</ol>
</li>
<li>对队列中的URL转2</li>
</ol>
<h5 id="采集器必须具有的功能"><a href="#采集器必须具有的功能" class="headerlink" title="采集器必须具有的功能"></a>采集器必须具有的功能</h5><ul>
<li>礼貌性：Web服务器有显示或隐式的策略控制采集器的访问</li>
<li>鲁棒性：能从采集器陷阱中跳出，能处理Web服务器的其他恶意行为</li>
<li>分布式：可以在多台机器上分布运行</li>
<li>可扩展性：添加更多机器后采集效率应该提高</li>
<li>性能和效率：充分利用不同的系统资源，包括处理器、存储器和网络带宽</li>
<li>新鲜度：对原来爬取的网页进行更新</li>
<li>功能可扩展性：支持多方面的功能扩展，例如处理新的数据格式、抓取新的协议。</li>
</ul>
<h4 id="采集器基本架构"><a href="#采集器基本架构" class="headerlink" title="采集器基本架构"></a>采集器基本架构</h4><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E9%87%87%E9%9B%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="采集器"></p>
<h4 id="Web-图"><a href="#Web-图" class="headerlink" title="Web 图"></a>Web 图</h4><h5 id="Web-→Web图"><a href="#Web-→Web图" class="headerlink" title="Web →Web图"></a>Web →Web图</h5><ul>
<li>将静态Web看成静态HTML网页通过超链接互相连接而成的有向图，其中每个<strong>网页</strong>是<strong>图的顶点</strong>，而每个超链接式图的<strong>有向边</strong>。</li>
<li>该有向图可能不是一个强连通图，即从一个网页出发，沿着超链接前进，有可能永远不会到达另外某个网页</li>
<li><strong>指向</strong>某个网页的链接称为 <strong><u>入链接</u></strong>（in-link)，而从某个网页指出去的链接称为<strong><u>出链接</u></strong>（out-link）。</li>
<li>入度：网页的入链数目。  出度：网页的出链数目</li>
</ul>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><ul>
<li>每个网页都用唯一的整数来表示</li>
<li>建立一个<strong>类似于倒排索引</strong>的邻接表，每行对应一个网页，按照其对应的整数大小排序。</li>
<li>任一网页P对应的行中包含的也是一系列整数的排序结构，每个整数对应<strong><u>链向P</u></strong>的网页编号。（那些网页指向P）</li>
</ul>
<h4 id="链接分析"><a href="#链接分析" class="headerlink" title="链接分析"></a>链接分析</h4><h5 id="Web是有向图"><a href="#Web是有向图" class="headerlink" title="Web是有向图"></a>Web是有向图</h5><ul>
<li>假设1：A到B的超链接表示A的作者对B的认可</li>
<li>假设2：指向页面B的锚文本式对B一个很好的描述</li>
</ul>
<h5 id="索引锚文本"><a href="#索引锚文本" class="headerlink" title="索引锚文本"></a>索引锚文本</h5><ul>
<li>索引文档D的时候，也索引指向文档D的锚文本</li>
<li>可以根据锚文本<strong><u>所在页面的权威性</u></strong>来确定锚文本的权重</li>
</ul>
<h5 id="小结：锚文本"><a href="#小结：锚文本" class="headerlink" title="小结：锚文本"></a>小结：锚文本</h5><ul>
<li>Web上很多网页的内容并不包含对自身的精确描述</li>
<li>Web搜索者不一定要使用网页中的词项来对网页进行查询，而使用锚文本。</li>
<li>锚文本周围窗口中的文本也可以当成锚文本一样来使用。</li>
</ul>
<h4 id="链接分析：PageRank"><a href="#链接分析：PageRank" class="headerlink" title="链接分析：PageRank"></a>链接分析：PageRank</h4><h5 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h5><ul>
<li>对Web图中的每个节点赋一个0~1间的分值，这个分值为PageRank</li>
<li><strong>查询词无关</strong>的排序</li>
<li>第一代版本：使用<strong>链接的数目</strong>作为流行程度的最简单度量</li>
<li>两个改进：<ul>
<li>无向流行度：赋予每个页面一个分：出链数+入链数</li>
<li>有向流行度：页面分数 = <strong>入链数</strong></li>
</ul>
</li>
</ul>
<h5 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h5><ul>
<li>检索出所有满足文本查询词的页面，然后把这些页面按照链接的流行的排序。</li>
<li>更复杂：把链接按流行度当作静态得分，结合文本匹配的分数进行综合排序</li>
</ul>
<h5 id="PageRank打分"><a href="#PageRank打分" class="headerlink" title="PageRank打分"></a>PageRank打分</h5><ul>
<li>假设一个浏览者在网络上随机行走<ul>
<li>从一个随机页面开始，每一步从当前页等概率地选择一个链接，进入链接所在页面</li>
</ul>
</li>
<li>在稳定状态下，每个页面都有一个访问概率——用这个概率作为页面的分数</li>
<li>当浏览者在Web上进行节点间的随机游走时，某些节点的访问次数会比其他的节点更多</li>
<li>访问频繁的节点具有很多从其它频繁访问节点中指向的入链接</li>
<li>PageRank思路：<strong>在随机游走过程中越频繁访问的网页越重要</strong></li>
</ul>
<h5 id="随机跳转（Teleporting）"><a href="#随机跳转（Teleporting）" class="headerlink" title="随机跳转（Teleporting）"></a>随机跳转（Teleporting）</h5><ul>
<li>遇到dead end时，随机跳转到一个页面，如果页面总数总是N，那么随机跳转的概率式1/N</li>
<li>非dead end， 以$a$(值较小)的概率跳转到一个随机页面；以剩余1-a的概率从页面的出链中选择一个</li>
<li>随机跳转结果：不会再困在一个地，将会有比率表示所有网页长期被访问的概率</li>
</ul>
<h5 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h5><ul>
<li>一个Markov链有<strong>N个状态</strong>，以及一个NxN的<strong>转移概率矩阵P</strong>。每一步只能处在一个状态</li>
<li>$1 \le i,j\le N$，转移概率矩阵P~ij~给出了从状态i到下一个状态j的条件转移概率</li>
<li>P中每一行的元素之和为1，从该页面跳转道其所有出链的概率之和为1</li>
<li>满足上述性质的非负矩阵被成为随机矩阵。最大特征值是1，与该特征值对应的有一个<strong>左特征向量</strong></li>
<li>马尔科夫链中下一个状态的分布仅仅依赖于当前的状态，与如何到达当前状态无关。</li>
<li>马尔科夫链的状态概率分布可以看成一个概率向量，每个元素都在[0,1]，且所有元素的和为1（行）</li>
</ul>
<h5 id="邻接矩阵A→概率转移矩阵P"><a href="#邻接矩阵A→概率转移矩阵P" class="headerlink" title="邻接矩阵A→概率转移矩阵P"></a>邻接矩阵A→概率转移矩阵P</h5><ul>
<li>如果一行没有1（没有出链），用1/N代替每个元素</li>
<li>否则<ul>
<li>每行中用1的个数除每个1。（归一化） 若某行3个1，每个1用1/3表示</li>
<li>上面处理的结果矩阵乘以1-a</li>
<li>上面结果矩阵元素加上  a/N </li>
</ul>
</li>
</ul>
<h5 id="概率向量的变化"><a href="#概率向量的变化" class="headerlink" title="概率向量的变化"></a>概率向量的变化</h5><ul>
<li>最终访问频率收敛与固定的、稳态概率π</li>
<li>算法： 给 <strong><em>X</em></strong> 乘上P的k次方，k不断增加，直到乘积稳定</li>
<li><strong><em>π</em></strong>P = <strong><em>π</em></strong>  <ul>
<li>解矩阵等式得到<strong><em>π</em></strong></li>
<li><strong><em>π</em></strong>是P的主左特征向量，<strong><em>π~i~</em></strong>是页面i的PageRank</li>
</ul>
</li>
</ul>
<h3 id="链接分析：HITS"><a href="#链接分析：HITS" class="headerlink" title="链接分析：HITS"></a>链接分析：HITS</h3><ul>
<li>对每个网页给出两个得分 hub值（导航） ，authority值（权威）</li>
<li>确定基本集</li>
<li>精选出Hub页和Authority页</li>
<li>迭代跟新h(x),a(x)<ul>
<li>输出h(x)最高作为Top Hub页，a(x)最高作为Top Authority页</li>
</ul>
</li>
<li>大概5次迭代就会稳定</li>
<li>h是$AA^t$的特征向量，a是$A^tA$的特征向量</li>
</ul>
<h2 id="6-向量模型"><a href="#6-向量模型" class="headerlink" title="6.向量模型"></a>6.向量模型</h2><h3 id="排序式检索"><a href="#排序式检索" class="headerlink" title="排序式检索"></a>排序式检索</h3><p>布尔检索：文档要么匹配要么不匹配。对自身需求和文档集性质非常了解的专家而言，布尔查询式不错的选择。然而对大多数用户来说不方便</p>
<ul>
<li>布尔查询的结果不是太多就是太少</li>
<li>需要花费很多精力去<strong>构造一个合适的query</strong>才可以获得一个在数量上可以接受的查询结果。</li>
</ul>
<h4 id="排序检索模型"><a href="#排序检索模型" class="headerlink" title="排序检索模型"></a>排序检索模型</h4><ul>
<li>在排序检索模型中，系统根据<strong>文档与query的相关性排序</strong>返回文档集合中的文档，而不是简单地返回所有满足query描述的文档集合。</li>
<li>自由文本查询：用户query是自然语言的一个或多个词语而不是由查询语言构造的表达式。</li>
<li>总体上，排序检索模型中有布尔查询和自由文本查询两种方式，但是实际中排序检索模型总是与自由文本查询联系在一起，反之亦然。</li>
</ul>
<h4 id="过多、过少不再是问题"><a href="#过多、过少不再是问题" class="headerlink" title="过多、过少不再是问题"></a>过多、过少不再是问题</h4><ul>
<li>当系统给出的式有序的查询结果，查询结果数目多不再是问题。只需要给出<strong>top K</strong>（10个左右）个结果，为用户减轻负担。</li>
<li>前提是有<strong>合适的排序算法</strong></li>
</ul>
<h4 id="排序检索的基本—-评分"><a href="#排序检索的基本—-评分" class="headerlink" title="排序检索的基本—-评分"></a>排序检索的基本—-评分</h4><p>希望根据文档对查询者的有用性大小顺序将文档返回给查询者</p>
<ul>
<li>给每个“查询—文档”对进行评分，在[0,1]之间</li>
<li><strong><em><em>这个评分值衡量文档与query的匹配程度</em></em></strong></li>
<li>以单个单词组成的query为例<ul>
<li>如果单词不出现在文档中，该文档得分为0</li>
<li>该词项在文档中出现的频率越高，则评分越高</li>
</ul>
</li>
</ul>
<h5 id="评分方案一—-Jaccard系数"><a href="#评分方案一—-Jaccard系数" class="headerlink" title="评分方案一—-Jaccard系数"></a>评分方案一—-Jaccard系数</h5><p>一种常用的衡量<strong>两个集合A,B重叠度</strong>的方法</p>
<ul>
<li>$Jaccard(A,B) = |A \cap B| / |A \cup B|$</li>
<li>$Jaccard(A,A) = 1$</li>
<li>$Jaccard(A,B) = 0 \ if\  A \cap B=0$</li>
<li>集合A和B不需要具有同样的规模</li>
<li>Jaccard(A,B)的取值在[0,1]</li>
</ul>
<p>用Jaccard系数评分的问题</p>
<ul>
<li>没有考虑<strong><em>词项频率</em></strong>（词项在文档中出现的次数）</li>
<li>没有考虑<strong><em>罕见词比高频词的信息量更大，更具区分度</em></strong></li>
</ul>
<h3 id="词项频率"><a href="#词项频率" class="headerlink" title="词项频率"></a>词项频率</h3><h4 id="词项–文档二值关联矩阵"><a href="#词项–文档二值关联矩阵" class="headerlink" title="词项–文档二值关联矩阵"></a>词项–文档二值关联矩阵</h4><ul>
<li>每个文档用一个二值向量表示 $\in {0,1}^{|v|}$  。每个词项是否属于某个文档</li>
</ul>
<h4 id="词项—文档词频关联矩阵"><a href="#词项—文档词频关联矩阵" class="headerlink" title="词项—文档词频关联矩阵"></a>词项—文档词频关联矩阵</h4><ul>
<li>考虑词项在文档中出现的频率，将每个文档看成是一个<strong><em>词频向量</em></strong>：矩阵中的一列</li>
</ul>
<h4 id="词袋模型（Bag-of-words）"><a href="#词袋模型（Bag-of-words）" class="headerlink" title="词袋模型（Bag of words）"></a>词袋模型（Bag of words）</h4><ul>
<li><p><strong>不考虑词在文档中出现的顺序</strong></p>
<p>“John is quicker than Mary” 和 “Mary is quicker than John” 的表示结果一样</p>
</li>
</ul>
<h5 id="词项频率tf（Term-frequency）"><a href="#词项频率tf（Term-frequency）" class="headerlink" title="词项频率tf（Term frequency）"></a>词项频率tf（Term frequency）</h5><p>词项频率：词项t在文档d中出现的次数，记为$tf_{t,d}$</p>
<ol>
<li>采用原始tf值（raw tf）<ul>
<li>某个词项在A文档中出现10次，即tf=10，在B文档中tf=1，那么A比B更相关，但是相关度不会相差10倍</li>
<li><strong><em>相关性不会正比于词项频率</em></strong></li>
</ul>
</li>
<li>对数词频<ul>
<li>词项t在文档d中的对数频率权重</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%AF%B9%E6%95%B0%E9%A2%91%E7%8E%87.png" alt="对数词频"><ul>
<li>文档——词项的<strong><em>匹配得分</em></strong>是所有<strong>同时出现</strong>在<u>query</u>和<u>文档d</u>中的词项的词频的对数之和</li>
<li>$Score(q,d) = \sum<em>{t\in q\cap d} (1+log^{tf</em>{t,d}})$</li>
<li>评分为0，表示文档和query没有<strong><em>公共词项</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="tf-idf权重计算"><a href="#tf-idf权重计算" class="headerlink" title="tf-idf权重计算"></a>tf-idf权重计算</h3><p>除词项频率tf之外，利用<strong>词项在整个文档集中</strong>的频率进行权重和评分计算</p>
<h4 id="罕见词所期望的权重"><a href="#罕见词所期望的权重" class="headerlink" title="罕见词所期望的权重"></a>罕见词所期望的权重</h4><ul>
<li><strong>罕见词比常见词所蕴含的信息更多</strong></li>
<li>考虑查询中某个词项，它会在整个文档集中非常罕见</li>
<li><strong>某篇包含该词项的文档很可能相关</strong>，故罕见词项将有较高权重</li>
</ul>
<h4 id="常见词项所期望的权重"><a href="#常见词项所期望的权重" class="headerlink" title="常见词项所期望的权重"></a>常见词项所期望的权重</h4><ul>
<li>常见词项的<strong>信息量</strong>不如罕见词</li>
<li>考虑一个查询此项，它频繁出现在文档集中</li>
<li>一篇包含该词项的文档当然比不包含该词项的文档的相关度要高</li>
<li>但是，这些词对于相关度而言并<strong><em><em>不是非常强的指示词</em></em></strong>，故<strong><em><em>给一个正的权重，但是整个权重小于罕见词权重</em></em></strong></li>
</ul>
<h4 id="文档频率（Document-frequency，df）"><a href="#文档频率（Document-frequency，df）" class="headerlink" title="文档频率（Document frequency，df）"></a>文档频率（Document frequency，df）</h4><ul>
<li>罕见词项赋予高权重</li>
<li>常见词项赋予正的低权重</li>
<li>文档频率$df$因子来计算 查询–文档的匹配得分</li>
<li><strong><em>文档频率</em></strong>：出现词项的文档数目</li>
</ul>
<h4 id="idf（inverse-document-frequency）逆文档频率"><a href="#idf（inverse-document-frequency）逆文档频率" class="headerlink" title="idf（inverse document frequency）逆文档频率"></a>idf（inverse document frequency）逆文档频率</h4><ul>
<li>$df_t$是词项t的<strong>文档频率</strong>：<strong>文档集合中包含t的文档数目</strong><ul>
<li>$df_t$与词项t包含的<strong>信息量</strong>成<strong>反比</strong>（出现文档数目越多，该词项的信息量相对较小）</li>
<li>$df_t \le N$ (N是文档的总数)</li>
</ul>
</li>
<li><p>定义t的<strong>逆文档频率</strong>为$idf$</p>
<p>  $idf<em>t = log</em>{10}(N/df_t)$</p>
</li>
<li>$idf_t$是反应<strong>词项t的信息量</strong>的一个指标</li>
<li>用$log_{10}(N/df_t)$来代替$\frac{N}{df_t}$来抑制idf的作用</li>
</ul>
<h4 id="idf对排序的影响"><a href="#idf对排序的影响" class="headerlink" title="idf对排序的影响"></a>idf对排序的影响</h4><ul>
<li>对于含有<strong>两个以上查询词的query</strong>，$idf$才会影响排序结果；只有一个查询词的query，idf对排序结果没有影响</li>
<li>例如 Query: arachnocentric line ， idf会提高 arachnocentric的相对权重，同时减低line的相对权重</li>
</ul>
<h4 id="文档集频率和文档频率"><a href="#文档集频率和文档频率" class="headerlink" title="文档集频率和文档频率"></a>文档集频率和文档频率</h4><ul>
<li>文档集频率（collection frequency,cf）是<u>指t在整个文档集合中出现的<strong><em><em>词的次数</em></em></strong></u>。</li>
<li>文档频率（document frequency，df）<u>包含该词项的<strong><em><em>文档数目</em></em></strong></u></li>
<li>df比cf更适合权重计算</li>
</ul>
<h4 id="tf–idf文档-逆文档频率（单个词）"><a href="#tf–idf文档-逆文档频率（单个词）" class="headerlink" title="tf–idf文档-逆文档频率（单个词）"></a>tf–idf文档-逆文档频率（单个词）</h4><ul>
<li>tf-idf是信息检索中最著名的权重计算方法</li>
<li>词项t的tf-idf式由它的tf和idf组合而成</li>
<li>$w<em>{t,d} = (1+logtf</em>{t,d})\times\log_{10}(N/df_t)$</li>
<li>tf-idf值随着<strong><em>词项在单个文档中出现次数(tf)增加而增加</em></strong>，随着<strong><em>词项在文档集中数目(df)增加而减小</em></strong></li>
</ul>
<h4 id="Query-最终文档排序"><a href="#Query-最终文档排序" class="headerlink" title="Query 最终文档排序"></a>Query 最终文档排序</h4><p>$Score(q,d) = \sum<em>{t\in q \cap d}tf*idf</em>{t,d}$</p>
<h3 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h3><ul>
<li>二值关联矩阵：每个文档用一个二值向量表示 $\in {0,1}^{|v|}$</li>
<li>词频矩阵：每篇文档表示成一个词频向量 $\in N^{|v|}$</li>
<li>tf-idf矩阵：每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$</li>
</ul>
<h4 id="文档表示成向量"><a href="#文档表示成向量" class="headerlink" title="文档表示成向量"></a>文档表示成向量</h4><ul>
<li>每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$(V式词项集合，|v|表示词项个数)</li>
<li>|v|维实向量空间<ul>
<li>空间每一维都对应<strong>词项</strong></li>
<li><strong>文档</strong>是空间的点或者向量</li>
<li>维度非常高：特别是互联网搜索引擎，空间可达千万维或更高</li>
<li>向量空间非常<strong>稀疏</strong>：对每个向量来说大部分都是0</li>
</ul>
</li>
</ul>
<h4 id="Queries表示成向量"><a href="#Queries表示成向量" class="headerlink" title="Queries表示成向量"></a>Queries表示成向量</h4><ol>
<li>对于查询做同样的处理，即将查询表示成统一高维空间的向量</li>
<li>在向量空间内根据query与<strong>文档相量间的距离</strong>来排序</li>
</ol>
<h4 id="利用夹角代替距离"><a href="#利用夹角代替距离" class="headerlink" title="利用夹角代替距离"></a>利用夹角代替距离</h4><ul>
<li>按query与文档夹角递减给文档排序，按余弦递增给文档排序 是的等价的。</li>
<li>按余弦cosine(query,document)递减给文档排序，只考虑相对顺序</li>
</ul>
<h4 id="文档长度归一化"><a href="#文档长度归一化" class="headerlink" title="文档长度归一化"></a>文档长度归一化</h4><ul>
<li>利用二范数对文档长度进行归一化，一个文档向量除以它的L~2~范数就是给这个文档进行长度归一化</li>
</ul>
<h2 id="6-检索系统"><a href="#6-检索系统" class="headerlink" title="6.检索系统"></a>6.检索系统</h2><h3 id="排序的重要性"><a href="#排序的重要性" class="headerlink" title="排序的重要性"></a>排序的重要性</h3><ul>
<li>用户只希望看到一些而不是成千上万的结果</li>
<li>很难构造只产生一些结果的查询，即使是专家也很难</li>
<li>→排序能够将成千上万条结果缩减至几条结果，因此非常重要</li>
<li>实际上大部分用户只看到1-3条结果</li>
</ul>
<h4 id="摘要阅读"><a href="#摘要阅读" class="headerlink" title="摘要阅读"></a>摘要阅读</h4><p>用户更可能阅读前几页(1, 2, 3, 4)的结果的摘要</p>
<h4 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h4><p>点击的分布甚至更有偏向性</p>
<ul>
<li>一半情况下，用户点击排名最高的页面<ul>
<li>即使排名最高的页面不相关，仍然有30%的用户会点击它            </li>
</ul>
</li>
<li>正确排序相当重要，把相关的页面放在首页非常重要</li>
</ul>
<h3 id="结果排序的实现"><a href="#结果排序的实现" class="headerlink" title="结果排序的实现"></a>结果排序的实现</h3><h4 id="tf和idf的存储"><a href="#tf和idf的存储" class="headerlink" title="tf和idf的存储"></a>tf和idf的存储</h4><ul>
<li><p>词典中保存每个词的idf</p>
</li>
<li><p>词项频率tf存入倒排索引</p>
<p>term|idf    →  d1,tf , \<p1,p2,…> d5, tf, \<p1,p2,…></p1,p2,…></p1,p2,…></p>
</li>
</ul>
<h4 id="精确top-K检索机器加速办法"><a href="#精确top-K检索机器加速办法" class="headerlink" title="精确top K检索机器加速办法"></a>精确top K检索机器加速办法</h4><ul>
<li>从文档集所有文档中找出K个离查询最近的文档</li>
<li>步骤：对每个文档频繁（余弦相似度），按评分高低排序，选出前K个结果</li>
<li>如何加速：<ul>
<li>加快每个余弦相似度的计算</li>
<li>不对所有文档的评分结果排序而直接选出top K篇</li>
<li>能否不需要计算所有N篇文档的得分</li>
</ul>
</li>
</ul>
<h4 id="快速计算余弦相似度"><a href="#快速计算余弦相似度" class="headerlink" title="快速计算余弦相似度"></a>快速计算余弦相似度</h4><ul>
<li>检索排序就是找查询的k临近</li>
<li>如果查询很短，可以加速<ul>
<li>查询的多个词项无权重</li>
<li>排序只需要相对得分</li>
</ul>
</li>
</ul>
<h4 id="堆排序法N中选K"><a href="#堆排序法N中选K" class="headerlink" title="堆排序法N中选K"></a>堆排序法N中选K</h4><ul>
<li>检索时，通常只需要返回前K条结果</li>
<li>令J=具有非零余弦相似度值的文档数目，利用对结构从J中选K个最大的</li>
</ul>
<h4 id="提前终止计算"><a href="#提前终止计算" class="headerlink" title="提前终止计算"></a>提前终止计算</h4><h4 id="非精确top-K检索的可行性"><a href="#非精确top-K检索的可行性" class="headerlink" title="非精确top K检索的可行性"></a>非精确top K检索的可行性</h4><ul>
<li>索引去除：<ul>
<li>对于一个包含多个词项的查询来说，可以只考虑<strong>至少包含一个查询词项的文档</strong></li>
<li>只考虑那些词项的<strong>idf值</strong>超过一定阈值的文档</li>
<li>只考虑包含<strong>多个查询词项</strong></li>
</ul>
</li>
<li>胜者表<ul>
<li>对于词典中的每个词项t，预先计算出r个最高权重的文档<ul>
<li>词项t所对应的tf值最高的r篇文档构成t的胜者表，r值<strong>在索引建立时给定</strong>可能r&lt;k</li>
</ul>
</li>
<li>根据给定查询q，对查询q中所有词项的胜者表求并集生成集合A。根据余弦相似度大小从A中选取前top K个文档</li>
</ul>
</li>
<li>静态得分<ul>
<li>希望排序考前的文档既相关又是权威的<ul>
<li>相关性通过余弦相似度得分来判断</li>
<li>权威性由文档本身的属性决定</li>
</ul>
</li>
<li>​</li>
</ul>
</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>信息检索的目标式<strong><em><em>较少消耗情况下尽快、全面返回准确的结果。</em></em></strong></p>
<h3 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h3><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><ul>
<li>时间开销</li>
<li>空间开销</li>
<li>响应速度<h4 id="效果（Effectiveness）"><a href="#效果（Effectiveness）" class="headerlink" title="效果（Effectiveness）"></a>效果（Effectiveness）</h4></li>
<li>返回的文档中有多少相关文档</li>
<li>所有相关文档中反回了多少</li>
<li>返回得靠不靠前<h4 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h4></li>
<li>覆盖率（Coverage）</li>
<li>访问量</li>
<li>数据更新速度</li>
</ul>
<h4 id="评价效果"><a href="#评价效果" class="headerlink" title="评价效果"></a>评价效果</h4><ul>
<li><strong>相同的文档</strong>集合，<strong>相同的查询</strong>主题集合，<strong>相同的评价指标</strong>，<strong>不同</strong>的检索系统进行比较。</li>
</ul>
<h3 id="无序检索结果的评价"><a href="#无序检索结果的评价" class="headerlink" title="无序检索结果的评价"></a>无序检索结果的评价</h3><h4 id="对单个查询进行评估的指标"><a href="#对单个查询进行评估的指标" class="headerlink" title="对单个查询进行评估的指标"></a>对单个查询进行评估的指标</h4><h5 id="对整个文档集合的划分"><a href="#对整个文档集合的划分" class="headerlink" title="对整个文档集合的划分"></a>对整个文档集合的划分</h5><ul>
<li>未检索出（Not Retrieved）<ul>
<li>未检索出的相关文档(NR)</li>
<li>未检索出的不相关文档 (NN)</li>
</ul>
</li>
<li>检索出（Retrieved）<ul>
<li>检索出的相关文档(RR)</li>
<li>检索出的不相关文档(RN)<h5 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h5></li>
</ul>
</li>
<li>召回率(Recall):RR/(RR+NR),返回的相关结果数占实际相关结果总数的比率，也称为查全率，$R\in[0,1]$</li>
<li>正确率(Precision):RR/(RR+RN),返回的结果中真正相关的比率，也称查准率，$P\in[0,1]$</li>
<li>两个指标分别度量检索效果的某个方面，忽略任何一个方面都有偏失。</li>
<li>两个极端情况<ol>
<li>返回有把握的1篇，P=100%，但R极低</li>
<li>全部文档都返回，R=1，但P极低</li>
</ol>
</li>
<li>虽然Precision和Recall都很重要，但是不同的应用、不同的用户对两者的要求不一样。</li>
</ul>
<h4 id="正确率和召回率的问题"><a href="#正确率和召回率的问题" class="headerlink" title="正确率和召回率的问题"></a>正确率和召回率的问题</h4><ul>
<li>应用领域<ul>
<li>拼写校对、中文分词、文本分类、人脸识别、…… </li>
</ul>
</li>
</ul>
<ul>
<li>召回率难以计算<ul>
<li>Pooling方法，或则不考虑召回率</li>
</ul>
</li>
<li>两个指标分别衡量了系统的某个方面，但是如何评价哪个系统好<ul>
<li>将两个指标融成一个指标</li>
</ul>
</li>
<li>两个指标都是基于<strong><em>集合（无序）进行</em></strong>计算，并没有考虑序的作用<ul>
<li>引入序的作用</li>
</ul>
</li>
</ul>
<h5 id="召回率的计算"><a href="#召回率的计算" class="headerlink" title="召回率的计算"></a>召回率的计算</h5><p>对于大规模语料集合，列举每个查询的所有相关文档不可能，因此不可能准确地计算召回率</p>
<ul>
<li>缓冲池（Pooling）方法：对多个检索系统的TopN个结果组成的集合进行人工标注，标注相关文档集合作为整个相关文档集合</li>
</ul>
<h5 id="使用查准率-查全率的问题"><a href="#使用查准率-查全率的问题" class="headerlink" title="使用查准率/查全率的问题"></a>使用查准率/查全率的问题</h5><ul>
<li>需要在<strong>大规模</strong>的文档集合和查询集合上进行计算</li>
<li><p>需要<strong>人工</strong>对返回的文档进行评价</p>
<ul>
<li>由于人的主观因素，人工评价往往不可靠</li>
</ul>
</li>
<li><p>评价是二值的</p>
<ul>
<li>无法体现细微的差别</li>
</ul>
</li>
<li>文档结合和数据来源不同，结果也不同，有严重的偏差<ul>
<li>评价结果只适用于某个范围，很难引申到其他范围</li>
</ul>
</li>
</ul>
<h4 id="综合评价准则-F-P和R融合"><a href="#综合评价准则-F-P和R融合" class="headerlink" title="综合评价准则 F=P和R融合"></a>综合评价准则 F=P和R融合</h4><ul>
<li>F值（F-measure):召回率R和查准率的加权调和平均值</li>
<li>$F = \frac{1}{\alpha^\frac{1}{p}+(1-\alpha)^\frac{1}{R}}=\frac{(\beta^2+1)PR}{\beta^2P+R}$</li>
<li>$F_\beta$ ：表示召回率的重要程度是查准率的$\beta(&gt;=0)$倍<ul>
<li>$\beta&gt;1$ 更重视召回率，$\beta&lt;1$更重视查准率</li>
<li>取等权重</li>
<li>$F_{\beta=1} = \frac{2PR}{P+R}$</li>
</ul>
</li>
<li>调和平均比较保守</li>
</ul>
<h4 id="精确率不适合IR的原因"><a href="#精确率不适合IR的原因" class="headerlink" title="精确率不适合IR的原因"></a>精确率不适合IR的原因</h4><ul>
<li>和查询相关的文档占文档集的极少数，即使什么都不返回也会得到很高的精确率</li>
<li>用户希望找到某些文档并且能够容忍结果中有一定的不相关性</li>
<li>返回一些即使不好的文档也比不反回任何文档好</li>
</ul>
<h3 id="有序检索结果的评价"><a href="#有序检索结果的评价" class="headerlink" title="有序检索结果的评价"></a>有序检索结果的评价</h3><h4 id="评价排序后的结果"><a href="#评价排序后的结果" class="headerlink" title="评价排序后的结果"></a>评价排序后的结果</h4><ul>
<li>P、R、F值都是基于集合的评价方法，它们都是利用无序的文档集合进行计算。如果搜索引擎输出为有序的检索结果时，需要扩展</li>
<li>对于特定检索词的有序检测结果<ul>
<li>系统可能返回任意数量的结果（=N）</li>
<li>考虑Top k返回的情形</li>
<li>则每个k的取值对应一个R和P</li>
</ul>
</li>
<li>计算得到查准率-查全率曲线</li>
</ul>
<h4 id="P-R的优缺点"><a href="#P-R的优缺点" class="headerlink" title="P-R的优缺点"></a>P-R的优缺点</h4><ul>
<li>优点：<ul>
<li>简单直观</li>
<li>既考虑了检索结果的覆盖度，又考虑了检索结果的排序情况</li>
</ul>
</li>
<li>缺点:<ul>
<li>单个查询的P-R曲线虽然直观，但是难以明确表示两个查询的检索结果的优劣</li>
</ul>
</li>
</ul>
<h4 id="基于P-R曲线的单一指标"><a href="#基于P-R曲线的单一指标" class="headerlink" title="基于P-R曲线的单一指标"></a>基于P-R曲线的单一指标</h4><ul>
<li>固定检索等级的查准率<ul>
<li>Precision@k：前k个结果的查准率</li>
<li>对大多数的web搜索适合，因为用户看重在前几页中有多少好结果</li>
<li>平均的方式不好，通常所用指标中最不稳定的</li>
</ul>
</li>
<li>11点平均正确率<ul>
<li>对每个信息需求，插值的<strong>正确率</strong>定义在0,0.1,0.2,…,0.9,1共11个召回率水平上</li>
<li>对每个召回率水平，对测试集中<strong>多个查询</strong>在该点的插值正确率<strong>求算术平均</strong></li>
</ul>
</li>
</ul>
<h4 id="更多的评价准则：AP"><a href="#更多的评价准则：AP" class="headerlink" title="更多的评价准则：AP"></a>更多的评价准则：AP</h4><ul>
<li><p>平均查准率(Average Precision,AP)：对不同召回率点上的正确率进行平均</p>
<ul>
<li><p><strong>未插值AP</strong>：某个查询Q共有6个相关结果，某系统排序反回了5篇相关文档，其位置分别为 第1，第2，第5，第10，第20位。</p>
<ul>
<li>$AP = (\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20}+0)/6$，等价于6点平均</li>
</ul>
</li>
<li><p><strong>插值的AP</strong>：在召回率分别为0, 0.1, 0.2, … ,1.0的十一个点上的正确率求平均，等价于11点平均</p>
<ul>
<li><p><strong>只对返回的相关文档</strong>进行计算的AP</p>
<p>$AP =(\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20})/5$，倾向返回那些快速返回结果的系统，<strong>没有考虑召回率</strong>，等价于5点平均</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="不考虑召回率"><a href="#不考虑召回率" class="headerlink" title="不考虑召回率"></a>不考虑召回率</h4><ul>
<li>Precision@N：在第N个位置上的正确率<ul>
<li>对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页结果。因此P@10、P@20对大规模搜索引擎来说是很好的指标</li>
</ul>
</li>
</ul>
<h4 id="宏平均vs微平均"><a href="#宏平均vs微平均" class="headerlink" title="宏平均vs微平均"></a>宏平均vs微平均</h4><ul>
<li>平均的求法：<ul>
<li>宏平均（Macro Average）：对<strong>每个查询</strong>求出某个指标，然后对这些指标进行算术平均</li>
<li>微平均（Micro Average）：将所有查询视为<strong>一个查询</strong>，将各种情况的文档总数求和，然后进行指标运算。（一个系统的所有查询）<ul>
<li>Eg： $ Micro Precision = \frac{对所有检验出的相关文档总数} {对所有查询检出的文档总数}$</li>
<li>宏平均对所有<strong>查询一视同仁</strong>，微平均受返回相关文档数目比较大的查询影响（宏平均保护弱者）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="平均查准率均值-Mean-Average-Precision-MAP"><a href="#平均查准率均值-Mean-Average-Precision-MAP" class="headerlink" title="平均查准率均值 Mean Average Precision(MAP)"></a>平均查准率均值 Mean Average Precision(MAP)</h4><ul>
<li>每个<strong><u><em>相关文档位置上</em></u></strong>查准率的平均值，被称为<strong>平均查准率</strong>（AP）</li>
<li>对所有查询求宏平均，就得到平均查准率均值（MAP）</li>
<li>$Map(Q)= \frac{1}{|Q|}\sum_{j=1}^{|Q|}\frac{1}{m<em>j}\sum</em>{k=1}^{m<em>j}Precision(R</em>{jk})$</li>
<li>Q为信息需求，$q_j \in Q$所对应的所有相关文档集合为${d_1,d<em>2,…,d</em>{mj}}$ ，$R_{ij}$是查询$q<em>j$的返回结果，该结果中包含而不含有$d</em>{k+1}$及以后的相关文档</li>
</ul>
<h4 id="面向用户的评价指标"><a href="#面向用户的评价指标" class="headerlink" title="面向用户的评价指标"></a>面向用户的评价指标</h4><ul>
<li>假定用户<strong>已知的相关文档集合为U</strong>，检索结果和U的交集为$R_u$，则<strong>覆盖率</strong><ul>
<li>$C=\frac{R_u}{U}$，<strong>检索系统找到的用户已知的相关文档比例</strong></li>
</ul>
</li>
<li>假定检索结果中返回一些用户<strong>以前未知的相关文档$R_k$</strong>，则可以定义<strong>新颖率</strong><ul>
<li>$N=\frac{|R_k|}{|R_u|+|R_k|}$，表示系统返回的新相关文档的比例</li>
</ul>
</li>
</ul>
<h4 id="GMAP"><a href="#GMAP" class="headerlink" title="GMAP"></a>GMAP</h4><ul>
<li>AP的集合平均值（更能体现细微差别）</li>
</ul>
<h4 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h4><ul>
<li>每个文段不仅仅只有相关和不相关，而是有相关级别<ul>
<li>相关度级别越高的结果越多越好</li>
<li>相关度级别越高的结果越靠前越好</li>
</ul>
</li>
</ul>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><ul>
<li>标题通常是从文档的元数据中自动抽取出来的<ul>
<li>用户根据描述信息来判断这个文档是否相关</li>
</ul>
</li>
<li>两种基本类型<ul>
<li>静态：不论输入什么查询，文档的静态摘要都是不变的</li>
<li>动态：动态摘要<strong>依赖于查询</strong>，试图解释当前文档返回的原因</li>
</ul>
</li>
</ul>
<h4 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>信息检索的评价方法<ul>
<li>不考虑序的检索评价指标：P、R、F</li>
<li>考虑序的评价指标：P/R曲线、MAP、NDCG</li>
</ul>
</li>
<li>检索结果的摘要</li>
</ul>
<h2 id="相关反馈及查询扩展"><a href="#相关反馈及查询扩展" class="headerlink" title="相关反馈及查询扩展"></a>相关反馈及查询扩展</h2><ul>
<li>交互式相关反馈：在初始检索结果基础上，通过用户指定哪些文档相关或不相关，然后改进检索的结果。Rocchio相关反馈</li>
<li>查询扩展（Query expansion）：通过在查询中加入同义或者相关的词项来提供检索结果。人工编辑的同义词辞典、自动构造的同义词词典、查询日志</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h4 id="搜索中提高召回率的方法"><a href="#搜索中提高召回率的方法" class="headerlink" title="搜索中提高召回率的方法"></a>搜索中提高召回率的方法</h4><ul>
<li>提高召回率的方法—— 相关反馈及查询扩展</li>
<li>返回不包含查询词项的相关文档</li>
</ul>
<h4 id="关于召回率Recall"><a href="#关于召回率Recall" class="headerlink" title="关于召回率Recall"></a>关于召回率Recall</h4><ul>
<li>放松召回率的定义，给用户返回更多的相关文档</li>
</ul>
<h4 id="提高召回率的方法"><a href="#提高召回率的方法" class="headerlink" title="提高召回率的方法"></a>提高召回率的方法</h4><ul>
<li>局部（local）方法：对用户查询进行局部的实时分析<ul>
<li>主要局部方法：<strong>相关反馈</strong>（relevance feedback）</li>
</ul>
</li>
<li>全局（global）方法：进行一次性的全局分析产生同/近义词词典(thesaurus)<ul>
<li>利用该词典进行查询扩展</li>
</ul>
</li>
</ul>
<h3 id="相关反馈基础"><a href="#相关反馈基础" class="headerlink" title="相关反馈基础"></a>相关反馈基础</h3><h4 id="相关反馈的基本思想"><a href="#相关反馈的基本思想" class="headerlink" title="相关反馈的基本思想"></a>相关反馈的基本思想</h4><ul>
<li>用户提交一个（简短的）查询</li>
<li>搜索引擎返回一系列文档</li>
<li>用户将部分返回文档标记为<strong>相关</strong>的，将部分文档标记为<strong>不相关</strong>的</li>
<li>搜索引擎根据标记结果计算得到信息需求的一个<strong>新查询表示</strong>。（希望好于初始查询）</li>
<li>对新查询进行处理，返回新结果。</li>
<li>新结果渴望有更高的<strong>召回率</strong></li>
</ul>
<h4 id="相关反馈分类"><a href="#相关反馈分类" class="headerlink" title="相关反馈分类"></a>相关反馈分类</h4><ul>
<li>用户相关反馈或显示相关反馈（User Feedback or Explicit Feedback）：用户显示参加交互过程</li>
<li>隐式相关反馈（Implicit Feedback）：系统跟踪用户的行为来推测返回文档的相关性，从而进行反馈</li>
<li>伪相关反馈或盲目相关反馈：（Pseduo Feedback or Blind Feedback）：没有用户参与，系统直接假设返回文档的前K篇相关的，然后进行反馈。</li>
</ul>
<h3 id="相关反馈详细介绍"><a href="#相关反馈详细介绍" class="headerlink" title="相关反馈详细介绍"></a>相关反馈详细介绍</h3><h4 id="相关反馈中的核心概念：质心"><a href="#相关反馈中的核心概念：质心" class="headerlink" title="相关反馈中的核心概念：质心"></a>相关反馈中的核心概念：质心</h4><ul>
<li>质心是一系列点的中心</li>
<li>前面将文档表示成高维空间中的点</li>
<li>计算文档质心的公式：</li>
</ul>
<h4 id="相关反馈基本理论"><a href="#相关反馈基本理论" class="headerlink" title="相关反馈基本理论"></a>相关反馈基本理论</h4><ul>
<li>基本理论：假定要找一个最有查询向量q，它与相关文档之间的相似度最大且同时又和不相关文档之间的相似度最小。</li>
<li><strong><em>q~opt~</em></strong>是将相关文档与不相关文档区分开的向量</li>
<li>当sim()函数采用余弦相似度计算时，能够将相关文档与不相关文档区分开的最有查询向量为：</li>
<li>最优查询向量等于<strong>相关文档的质心向量和不相关文档的质心向量的差</strong></li>
</ul>
<h4 id="Rocchio算法"><a href="#Rocchio算法" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>假定有一个用户查询，并知道部分相关文档和不相关文档的信息，最优查询向量为</li>
<li>q-</li>
<li>修改后的新查询从q~0~开始，向相关文档质心靠近，同时与不相关文档质心远离。</li>
<li>将<strong>相关文档</strong>的质心移动一个量，该量为相关文档质心和不相关文档质心的差异量</li>
<li>修改后的新查询，向着相关文档的质心向量靠近了一段距离，与不相关文档的质心向量远离了一段距离。</li>
</ul>
<h4 id="相关反馈策略的评价"><a href="#相关反馈策略的评价" class="headerlink" title="相关反馈策略的评价"></a>相关反馈策略的评价</h4><ul>
<li>使用初始查询q~0~ ，计算”查准率-查全率“曲线</li>
<li>使用相关反馈后修改查询q~m~，然后计算”查准率-查全率“曲线<ul>
<li>方案1：在<strong>整个文档集合</strong>上评价<ul>
<li>有显著的改善，但是有作弊嫌疑部分原因是会把已知的相关文档排在很前</li>
<li>需要用用户没有看到的文档集合来评价</li>
</ul>
</li>
<li>方案2：使用<strong>剩余的文档</strong>集合来评价（总的文档集合减去评价过的相关性文档）<ul>
<li>评价结果往往<strong>比初始查询的结果差</strong>，但是这种方法更现实</li>
<li>可以用来有效比较不同相关反馈方法之间的相对效果</li>
</ul>
</li>
<li>方案3：使用<strong>两个文档</strong>集合<ul>
<li>在第一个文档集合上使用初始查询q~0~，并进行相关反馈</li>
<li>在第二个文档集合上使用初始查询q~0~和修改过的查询q~m~进行评价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="评价的误区"><a href="#评价的误区" class="headerlink" title="评价的误区"></a>评价的误区</h4><ul>
<li>评价不同相关反馈的效用的时候，必须考虑消耗时间的要素。</li>
<li>代替相关反馈的方法：用户修改并重新提交查询</li>
<li>相对于判断文档的相关性，用户可能更愿意修改并重新提交查询</li>
<li>没有证据能表明相关反馈占用了用户的时间就能给用户带来最大的效用。</li>
</ul>
<h4 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h4><ul>
<li>提高召回率</li>
<li>查询重构的全局方法。在全局查询扩展中，查询基于一些<strong>全局的资源</strong>进行修改。</li>
<li>主要使用 同义词或近义词词典（人工构建和自动构建）</li>
</ul>
<h2 id="概率检索模型"><a href="#概率检索模型" class="headerlink" title="概率检索模型"></a>概率检索模型</h2><h3 id="向量空间模型回顾"><a href="#向量空间模型回顾" class="headerlink" title="向量空间模型回顾"></a>向量空间模型回顾</h3><h4 id="向量空间模型-1"><a href="#向量空间模型-1" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>文档表示成向量</li>
<li>查询也表示成向量</li>
<li>计算两个向量之间的相似度：余弦相似度、内积相似度</li>
<li>向量表示中的词项权重计算方法主要是tf-idf公式，实际考虑<strong>tf、idf及文档长度</strong>3个因素</li>
</ul>
<h4 id="向量空间模型优缺点"><a href="#向量空间模型优缺点" class="headerlink" title="向量空间模型优缺点"></a>向量空间模型优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>简洁直观，可以应用到很多其他领域(文本分类、生物信息学)</li>
<li>支持部分匹配和近似匹配，结果可以排序</li>
<li>检索效果不错</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>理论上不够：基于直觉的经验性公式</li>
<li>索引项之间的独立性假设与实际不符：实际上，term的出现之间是有关系的，不是完全独立。</li>
</ul>
<h3 id="基本概率统计知识"><a href="#基本概率统计知识" class="headerlink" title="基本概率统计知识"></a>基本概率统计知识</h3><h4 id="随机试验和随机事件"><a href="#随机试验和随机事件" class="headerlink" title="随机试验和随机事件"></a>随机试验和随机事件</h4><h4 id="概率和条件概率"><a href="#概率和条件概率" class="headerlink" title="概率和条件概率"></a>概率和条件概率</h4><h4 id="乘法公式、全概率公式和贝叶斯公式"><a href="#乘法公式、全概率公式和贝叶斯公式" class="headerlink" title="乘法公式、全概率公式和贝叶斯公式"></a>乘法公式、全概率公式和贝叶斯公式</h4><h4 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h4><h4 id="概率检索模型-1"><a href="#概率检索模型-1" class="headerlink" title="概率检索模型"></a>概率检索模型</h4><ul>
<li>概率检索模型：通过<strong>概率的方法</strong>将查询和文档联系起来<ul>
<li>定义3个随机变量R、Q、D：<strong>相关度R</strong>={0，1}，<strong>查询Q</strong>={q1,q2,…}，<strong>文档D</strong>={d1,d2,…}</li>
<li>通过计算<strong>条件概率$P(R=1|Q=q,D=d)$</strong>来度量文档和查询的相关度</li>
</ul>
</li>
</ul>
<h4 id="概率排序原理PRP"><a href="#概率排序原理PRP" class="headerlink" title="概率排序原理PRP"></a>概率排序原理PRP</h4><ul>
<li>利用概率模型来估计每篇文档和需求的<strong><em>相关概率P(R=1|d,q)</em></strong>，然后对结果进行排序</li>
<li>最简单的PRP情况<ul>
<li>检索没有任何迭代因子，或者说不会对不同行为或错误采用不同的权重因子。</li>
<li>在返回一篇不想管文档或者返回一篇相关文档不成功的情况下，将失去1分</li>
<li>而检索的目标是对于用户给定的k值，返回可能性最高的文档前k篇作为结果输出。即RPR希望可以按照$P(R=1|d,q)$值的<strong>降序</strong>来排列所有文档</li>
</ul>
</li>
<li>公式的理解</li>
</ul>
<h4 id="基于检索代价的概率排序原理"><a href="#基于检索代价的概率排序原理" class="headerlink" title="基于检索代价的概率排序原理"></a>基于检索代价的概率排序原理</h4><ul>
<li>C~1~表示一篇<strong>相关文档未返回</strong>所发生的代价</li>
<li>C~0~表示<strong>返回一篇不相关文档</strong>所发生的代价</li>
<li>PRP认为，如果对于一篇特定的文档d及其所有其他未返回的文档d’都满足：</li>
<li>$C_0\cdot P(R=1|d)-C_1\cdot P(R=0|d) \le C_0\cdot P(R=1|d’)-C_1\cdot P(R=0|d’)$<ul>
<li>$C_0\cdot P(R=1|d)$：当d不相关时却返回的代价（判为相关）</li>
<li>$C_1\cdot P(R=0|d)$：当d相关却没有返回的代价</li>
<li>两者相减表示返回文档d的<strong>代价函数</strong>，即此时前者越低越好，后者越高越好</li>
</ul>
</li>
<li>那么d就应该是下一篇被返回的文档</li>
</ul>
<h4 id="二值独立概率模型BIM"><a href="#二值独立概率模型BIM" class="headerlink" title="二值独立概率模型BIM"></a>二值独立概率模型BIM</h4><ul>
<li>为了对概率函数P(R|q,d)进行估计，引入了一些简单假设。<ul>
<li>”二值“等价于布尔值：文档和查询都表示为<strong><u>词项出现与否的布尔向量</u></strong></li>
<li>类似，查询q表示成词项出现向量q</li>
<li>”独立性“指的式词项在文档中的出现是相互独立的，BIM不识别词项之间的关联。</li>
</ul>
</li>
</ul>
<h4 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h4><ul>
<li>在减少出现事件的概率估计值的同时提高未出现事件的概率估计值的方法</li>
</ul>
<h4 id="BIM模型的优缺点"><a href="#BIM模型的优缺点" class="headerlink" title="BIM模型的优缺点"></a>BIM模型的优缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>BIM模型建立在数学基础上，理论性较强</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>需要估计参数</li>
<li>原始BIM没有考虑TF、文档长度因素</li>
<li>BIM中同样存在词项独立性假设</li>
</ul>
<h4 id="理论上的概率估计方法"><a href="#理论上的概率估计方法" class="headerlink" title="理论上的概率估计方法"></a>理论上的概率估计方法</h4><ul>
<li>P~t~词项出现在一篇相关文档中的概率</li>
<li>$p_t = P(x_t=1|R=1,q) = s/S$</li>
<li>u~t~词项出现在一片不相关文档中的概率</li>
<li>$u_t=P(x_t=1|R=0, q)= (df_t-s)/(N-S)$</li>
</ul>
<h2 id="基于语言建模的检索模型"><a href="#基于语言建模的检索模型" class="headerlink" title="基于语言建模的检索模型"></a>基于语言建模的检索模型</h2><ul>
<li>传统概率模型<ul>
<li>需要对文档d与查询q的相关概率$P(R=1|q,d)$进行显示建模</li>
</ul>
</li>
<li>概率语言模型<ul>
<li>首先对每篇文档d建模得到文档的<strong>概率语言模型 $M_d$</strong></li>
<li>然后按照<strong>模型生成查询q</strong>的概率$P(q|M_d)$的高低来对文档进行排序</li>
</ul>
</li>
</ul>
<h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><h4 id="最简单的语言生成器模型"><a href="#最简单的语言生成器模型" class="headerlink" title="最简单的语言生成器模型"></a>最简单的语言生成器模型</h4><ul>
<li>一个简单的又穷自动机及其生成语言中的一些字符串<ul>
<li>$\rightarrow$指向的是自动机的初始状态</li>
<li>双圈节点对应的是终止状态</li>
</ul>
</li>
<li>如果每一个节点都有一个生成不同词项的概率分布，便得到一个语言模型，或概率语言模型，或统计语言模型<ul>
<li>语言模型的概念本质上是基于概率的</li>
</ul>
</li>
</ul>
<h4 id="有穷自动机-rightarrow-语言模型"><a href="#有穷自动机-rightarrow-语言模型" class="headerlink" title="有穷自动机$\rightarrow$语言模型"></a>有穷自动机$\rightarrow$语言模型</h4><ul>
<li>一个语言模型（LM）是从某词汇表上抽取的<strong>字符串概率的一个映射函数</strong>。对字母表$\sum$上的语言模型M有：$\sum_{s\in \sum^*}P(s)=1$</li>
<li>最简单的语言模型等价于一个仅仅包含一个节点的概率有穷自动机，只有一个生成不同词项的概率分布，因此有$\sum_{t\in V}P(t)=1$</li>
<li>假定停止概率是固定的，因此不会影响文档的排序。因此可以不考虑停止概率，但形式上得到的结果将不再是概率，而只是概率的部分项</li>
</ul>
<h4 id="语言模型的比较"><a href="#语言模型的比较" class="headerlink" title="语言模型的比较"></a>语言模型的比较</h4><ul>
<li>比较两个模型，可计算似然比，即将其中一个模型的数据生成概率除以另外一个模型数据的生成概率。</li>
</ul>
<h3 id="语言模型的种类"><a href="#语言模型的种类" class="headerlink" title="语言模型的种类"></a>语言模型的种类</h3><h4 id="对于词项序列如何求解其生成的概率值"><a href="#对于词项序列如何求解其生成的概率值" class="headerlink" title="对于词项序列如何求解其生成的概率值"></a>对于词项序列如何求解其生成的概率值</h4><ul>
<li>根据链式规则将一系列事件的概率分解成多个连续事件概率之积，每个概率是每个事件基于其历史事件的条件概率。</li>
<li>$P(t_1t_2t_3t_4)=P(t_1)P(t_2|t_1)P(t3|t_1t_2)P(t_4|t_1t_2t_3)$</li>
</ul>
<h4 id="语言模型的种类n-gram"><a href="#语言模型的种类n-gram" class="headerlink" title="语言模型的种类n-gram"></a>语言模型的种类n-gram</h4><ul>
<li><p>一元语言模型（Unigram LM）：上下文语言无关模型，是最简单的语言模型，去掉所有条件概率中的条件来独立地估计每个词项的概率</p>
<ul>
<li>$P_{uni}(t_1t_2t_3t_4) = P(t_1)P(t_2)P(t_3)P(t_4)$</li>
<li>词袋模型Bag of words</li>
</ul>
</li>
<li><p>二元语言模型（Bigram LM）：即计算条件概率时只考虑前一个词项的出现情况</p>
<ul>
<li>$P_{bi}(t_1t_2t_3t_4) = P(t_1)P(t_2|t_1)P(t_3|t_2)P(t_4|t_3)$</li>
</ul>
</li>
<li><p>三元语言模型（Trigram LM）</p>
</li>
</ul>
<h4 id="词的多项式分布"><a href="#词的多项式分布" class="headerlink" title="词的多项式分布"></a>词的多项式分布</h4><ul>
<li>词的多项式分布</li>
</ul>
<h3 id="语言模型应用到IR"><a href="#语言模型应用到IR" class="headerlink" title="语言模型应用到IR"></a>语言模型应用到IR</h3><h4 id="总体分布-amp-抽样"><a href="#总体分布-amp-抽样" class="headerlink" title="总体分布&amp;抽样"></a>总体分布&amp;抽样</h4><ul>
<li>文档模型实际是某种<strong>总体分布</strong></li>
<li>文档和查询都是该总体分布下的一个<strong>抽样样本示例</strong></li>
<li>根据文档，估计文档的模型，即求出该总体分布，然后计算该总体分布下抽样出查询的概率</li>
<li>文档 $\rightarrow$ 总体分布 $\rightarrow$ 查询</li>
</ul>
<h4 id="查询似然模型"><a href="#查询似然模型" class="headerlink" title="查询似然模型"></a>查询似然模型</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>将文档按照其余查询相关的似然$P(d|q)$排序<ul>
<li>$P(d|q)=P(d|q)\frac{P(d)}{P(q)}$</li>
</ul>
</li>
<li><p>最后会按照$P(d|q)$进行排序，它是在<strong>文档d对应的语言模型$M_d$下生成q的概率</strong></p>
</li>
<li><p>IR中的语言建模方法实际上是在<strong>对查询的过程</strong>进行建模</p>
<ul>
<li>首先每篇文档d对应一个文档模型$M_d$</li>
<li>然后计算查询被视为每个文档模型的随机抽样样本的概率</li>
<li>最后根据这些概率对文档排序<ul>
<li>$P(q|M_d) = K<em>q \prod</em>{t\in V}P(t|M<em>d)^{tf</em>{t,d}}$</li>
<li>$K_q$是查询q的多项式系数，对于某个特定查询，是一个常数可以忽略。</li>
</ul>
</li>
</ul>
</li>
<li>模型的直观意义是，用户脑子里有一篇原型文档，然后按照该文档中的词语用法来生成查询。</li>
</ul>
<h4 id="查询生成的概率估计"><a href="#查询生成的概率估计" class="headerlink" title="查询生成的概率估计"></a>查询生成的概率估计</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>采用最大似然估计：使得观察样本出现概率最大的估计<ul>
<li>$P(q|M<em>d)=\prod</em>{t\in q}P_{mle}(t|M<em>d)=\frac{tf</em>{t,d}}{L_d}$</li>
<li>$L_d$是d中的词条数目</li>
</ul>
</li>
</ul>
<h4 id="线性插值LM示例"><a href="#线性插值LM示例" class="headerlink" title="线性插值LM示例"></a>线性插值LM示例</h4><h4 id="平滑的方法：线性插值LM"><a href="#平滑的方法：线性插值LM" class="headerlink" title="平滑的方法：线性插值LM"></a>平滑的方法：线性插值LM</h4><ul>
<li><p>需要对文档LM的概率进行平滑（Smoothing），即对出现事件的概率结果进行折扣，并对未出现的词的概率赋予一定的值。</p>
</li>
<li><p>将基于<strong>文档的多项式</strong>分布和基于全部<strong>文档集</strong>估计出的多项式分布相混合</p>
</li>
<li>$P(t|d)= \lambda P_{mle}(t|M<em>d)+(1-\lambda)P</em>{mle}(t|M_c)$<ul>
<li>$\lambda \in (0,1)$ , $M_c$是基于全部文档集构造的LM</li>
</ul>
</li>
</ul>
<h4 id="扩展的LM方法"><a href="#扩展的LM方法" class="headerlink" title="扩展的LM方法"></a>扩展的LM方法</h4><ul>
<li>a查询似然类：文档建模，计算查询的似然<ul>
<li>基本QLM模型、翻译模型</li>
</ul>
</li>
<li>b文档似然类：查询建模，计算文档的似然<ul>
<li>BIM模型、相关性模型</li>
</ul>
</li>
<li>c模型比较类：文档建模，查询建模，kl距离模型</li>
</ul>
<h2 id="文本分类及朴素贝叶斯分类器"><a href="#文本分类及朴素贝叶斯分类器" class="headerlink" title="文本分类及朴素贝叶斯分类器"></a>文本分类及朴素贝叶斯分类器</h2><h3 id="本讲要点"><a href="#本讲要点" class="headerlink" title="本讲要点"></a>本讲要点</h3><ul>
<li>什么是文本分类</li>
<li>什么是朴素贝叶斯分类器</li>
<li>朴素贝叶斯分类器的生成模型</li>
<li>朴素贝叶斯分类器的性质<ul>
<li>条件独立假设&amp;位置独立性假设</li>
</ul>
</li>
<li>特征选择：互信息、x2统计量、词项频率</li>
<li>文本分类评价：宏平均和微平均</li>
</ul>
<h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><ul>
<li>给定分类体系，将一篇文本分到其中一个或者多个类别中的过程。</li>
</ul>
<ul>
<li>文本分类中，给定文档$d \in X$ 和一个固定的类别集合 $C={C_1,C_2,…,C_j}$ , 其中X表式文档空间，类别也通常称为类或类标签<ul>
<li>按类别书目：binary vs multi-class</li>
<li>按每篇文档赋予的标签书目： sing label vs multi label</li>
</ul>
</li>
</ul>
<h4 id="分类方法1：-手工方法"><a href="#分类方法1：-手工方法" class="headerlink" title="分类方法1： 手工方法"></a>分类方法1： 手工方法</h4><ul>
<li>使用人工分类方法来分类，如果专家来分类精度会非常高</li>
<li>如果问题规模和分类团队都很小时，能否保持分类结果的一致性</li>
</ul>
<h4 id="分类方法2：规则方法"><a href="#分类方法2：规则方法" class="headerlink" title="分类方法2：规则方法"></a>分类方法2：规则方法</h4><ul>
<li>繁琐，开销大</li>
</ul>
<h4 id="分类方法3：机器学习方法"><a href="#分类方法3：机器学习方法" class="headerlink" title="分类方法3：机器学习方法"></a>分类方法3：机器学习方法</h4><ul>
<li>文本分类被定义为一个学习问题，包括：<ul>
<li>通过有监督的学习，得到分类函数$\gamma$，然后将其应用于对新文档的分类</li>
</ul>
</li>
<li>一系列的分类方法：朴素贝叶斯、Rocchio、KNN、SVM</li>
<li>当学习方法基于统计时，此方法也称为统计文本分类：<ul>
<li>在统计文本分类中，对每个类别需要一些好的文档样例（训练文档）</li>
<li>需要人来标注训练文档，所以对人工分类的需求依然存在</li>
<li>标注（labeling）指对每篇文档赋予类别标签的过程</li>
</ul>
</li>
</ul>
<h4 id="基于学习的文本分类"><a href="#基于学习的文本分类" class="headerlink" title="基于学习的文本分类"></a>基于学习的文本分类</h4><ul>
<li>文档空间X<ul>
<li>文档都在该空间下表示—— 通常都是某种高维空间</li>
</ul>
</li>
<li>固定的类别集合$C={C_1,C_2,…,C_j}$<ul>
<li>类别往往根据应用的需求来人为定义</li>
</ul>
</li>
<li>训练集D，文档d用c来标记，$<d,c> \in X \times C$<ul>
<li>利用学习算法，可以学习一个分类器$\gamma$，它可以将文档映射成类别： $\gamma：X\rightarrow C$</li>
</ul>
</d,c></li>
<li>文档分类的实现<ul>
<li>对于文档空间中文档，$d \in X $,可确定$γ(d) \in C $即确定d最可能属于的类别$c_i = γ(d),c \in C$</li>
</ul>
</li>
</ul>
<h4 id="无监督-有监督的学习"><a href="#无监督-有监督的学习" class="headerlink" title="无监督/有监督的学习"></a>无监督/有监督的学习</h4><ul>
<li>supervised learning 监督学习<ul>
<li>利用一组<strong><u>已知类别的样本</u></strong>调整分类器的参数，使其达到所求性能的过程，也称为监督训练或有教师学习</li>
</ul>
</li>
<li>无监督学习<ul>
<li>若所给的学习样本<strong><em>不带有类别信息</em></strong>，就是无监督学习</li>
</ul>
</li>
</ul>
<h4 id="搜索引擎中的文本分类应用"><a href="#搜索引擎中的文本分类应用" class="headerlink" title="搜索引擎中的文本分类应用"></a>搜索引擎中的文本分类应用</h4><ul>
<li>语言识别</li>
<li>垃圾网页识别</li>
<li>是否包含淫秽内容</li>
<li>领域搜索或垂直搜索—— 搜索对象限制在某个垂直领域</li>
<li>静态查询</li>
<li>情感识别</li>
</ul>
<h4 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h4><ul>
<li>是一个概率分类器</li>
<li>文档d属于类别c的概率计算</li>
<li>$P(c|d)=\frac{P(c)P(d|c)}{P(d)} ∞ P(c)P(d|c)∞P(c)\prod_{1\le K \le n_d}{P(t_k|c)}$</li>
<li>t~k~是d中的词条，n~d~是文档的长度（词条个数）</li>
<li>P(t~k~|c)是此项t~k~出现在类别c中文档的概率，或类别c生成词项t~k~的概率，或是度量的是当c是正确类别时t~k~的贡献</li>
<li>P(c)是类别c的先验概率</li>
<li>如果文档的词项无法提供属于哪个类别的信息，那么直接选择P(c)最高的那个类别</li>
</ul>
<h3 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h3><h4 id="两种模型文本生成过程"><a href="#两种模型文本生成过程" class="headerlink" title="两种模型文本生成过程"></a>两种模型文本生成过程</h4><ul>
<li>给定类别时文档生成的条件概率计算有所不同<ul>
<li>多项式模型$P(d|c)=P(<t_1, …="" ,="" t_k,="" …,="" t_{nd}="">|c)$</t_1,></li>
<li>贝努利模型$P(d|c)=P(<e_1, …="" ,="" e_k,="" …,="" e_m="">|c)$</e_1,></li>
<li>其中 多项式模型是d中出现的词项序列（去掉词）</li>
<li>贝努利模型是一个M维的布尔向量，表示每个词项在文档d中存在与否。</li>
</ul>
</li>
<li>两种不同的文档表示方法<ul>
<li>多项式模型是文档空间X是所有词项序列的集合</li>
<li>贝努利模型是文档空间X是${0,1}^M$</li>
</ul>
</li>
</ul>
<h4 id="具有最大后验概率的类别"><a href="#具有最大后验概率的类别" class="headerlink" title="具有最大后验概率的类别"></a>具有最大后验概率的类别</h4><ul>
<li>朴素贝叶斯分类的目标是寻找“最佳”类别</li>
</ul>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ul>
<li>文本分类中，通常要将文本表示在一个<strong>高维空间</strong>下，<strong>每一维对应一个词项</strong>。特征选择是从训练集合出现的词项中选出一部分子集的过程。在文本分类过程也仅仅使用这个子集作为特征</li>
<li>特征选择有两个主要目的：<ol>
<li>通过减少有效的词汇空间来提高分类器训练和应用的效率。这对除NB之外的其他训练开销较大的分类器来说尤为重要。</li>
<li>特征选择能够去除噪音特征，从而提高分类的精度。</li>
</ol>
</li>
<li><strong>噪音特征</strong>：加入文本表示之后反而会增加新数据上的分类错误率的特征</li>
<li>由于训练集的偶然性导出的不正确的泛化结果称为<strong>过学习</strong></li>
</ul>
<h4 id="特征选择算法"><a href="#特征选择算法" class="headerlink" title="特征选择算法"></a>特征选择算法</h4><ul>
<li>给定类别c，对词汇表中的每个词项t，计算<strong>效用指标A(t,c)</strong>，然后从中选择k个具有最高值的词项作为最后的特征。</li>
</ul>
<h4 id="不同的特征选择方法"><a href="#不同的特征选择方法" class="headerlink" title="不同的特征选择方法"></a>不同的特征选择方法</h4><ul>
<li>特征选择方法主要基于其所使用特征效用指标来定义</li>
<li>特征效用指标<ul>
<li>频率法—— 选择高频词项</li>
<li>互信息—— 选择具有最高互信息的那些词项</li>
<li>卡方x^2^ </li>
</ul>
</li>
</ul>
<h3 id="分类评价"><a href="#分类评价" class="headerlink" title="分类评价"></a>分类评价</h3><ul>
<li>评价必须基于测试数据进行，而且该测试数据与训练数据完全独立。</li>
<li>很容易通过训练可以子训练集上达到很高的性能</li>
<li>常用指标：正确率、召回率、F~1~值、分类精确率等等</li>
<li>宏平均：在类别之间求平均值  微平均：将每篇文档在每个类别上的判定放入一个缓冲池，然后基于这个缓冲池计算效果指标。</li>
</ul>
<h4 id="宏平均"><a href="#宏平均" class="headerlink" title="宏平均"></a>宏平均</h4><ul>
<li>对类别集合C中的每个类都计算一个F~1~值</li>
<li>对C个结果求平均</li>
</ul>
<h4 id="微平均"><a href="#微平均" class="headerlink" title="微平均"></a>微平均</h4><ul>
<li>对类别集合C中的每个类都计算TP、FP和FN</li>
<li>将C中的这些数字累加</li>
<li>基于累加的TP、FP、FN计算P、R和F~1~</li>
</ul>
<h4 id="宏平均和微平均的适用范围"><a href="#宏平均和微平均的适用范围" class="headerlink" title="宏平均和微平均的适用范围"></a>宏平均和微平均的适用范围</h4><ul>
<li>宏平均和微平均的计算结果可能会相差很大。宏平均对每个类等同对待，而微平均则对每篇文档的判定结果等同对待</li>
<li>由于F1值忽略判断正确的负例，所以它的大小主要由判断正确的正例数目所决定，所以在微平均计算中大类起支配作用。</li>
</ul>
<h2 id="基于向量空间模型的文本分类"><a href="#基于向量空间模型的文本分类" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><ul>
<li>Rocchio方法<ul>
<li>基于质心或原型将整个向量空间划分成多个区域</li>
</ul>
</li>
<li>kNN方法<ul>
<li>将K个最邻近文档所属的主类别赋给测试文档</li>
</ul>
</li>
<li>线性分类器<ul>
<li>指基于特征的简单<strong>线性组合</strong>就可以对文档进行分类的分类器</li>
</ul>
</li>
</ul>
<h3 id="基于向量空间的分类方法"><a href="#基于向量空间的分类方法" class="headerlink" title="基于向量空间的分类方法"></a>基于向量空间的分类方法</h3><h4 id="向量空间表示"><a href="#向量空间表示" class="headerlink" title="向量空间表示"></a>向量空间表示</h4><ul>
<li>每个文档表示成一个<strong>向量</strong>，向量的每一维表示一个<strong>term</strong></li>
<li>向量可以归一化成单位长度</li>
<li>高维向量空间<ul>
<li>维度非常高</li>
<li>每个term就是一个坐标轴</li>
<li>文档表示为空间的向量</li>
</ul>
</li>
</ul>
<h4 id="向量空间模型-2"><a href="#向量空间模型-2" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>词项——文档矩阵：二值—&gt; 计数 —&gt; 权重矩阵（tf-idf）</li>
<li><p>相关性 = 向量距离 ： 欧式距离—&gt; 夹角 —&gt; 余弦相似度</p>
</li>
<li><p>利用向量空间模型进行文本分类的思路主要基于<strong>邻近假设</strong>：</p>
<ol>
<li>同一类的文档会构成一个邻近区域</li>
<li>不同类的邻近区域之间互不重叠</li>
</ol>
</li>
<li>如何找到<strong>分类面决策边界</strong>（decision boundary）</li>
</ul>
<h3 id="Rocchio方法"><a href="#Rocchio方法" class="headerlink" title="Rocchio方法"></a>Rocchio方法</h3><h4 id="Rocchio方法进行向量空间分类的思路"><a href="#Rocchio方法进行向量空间分类的思路" class="headerlink" title="Rocchio方法进行向量空间分类的思路"></a>Rocchio方法进行向量空间分类的思路</h4><ul>
<li>利用<strong>质心</strong>来定义分类边界</li>
<li>一个<strong>类别c的质心</strong>可以通过类中文档向量的平均向量或者质心想来来计算</li>
<li>计算公式：</li>
</ul>
<h4 id="Rocchio算法-1"><a href="#Rocchio算法-1" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>计算每个类的中心向量（所有文档向量的算术平均）</li>
<li>将每篇测试文档分到离它最近的那个中心向量</li>
</ul>
<h4 id="Rocchio算法中的决策边界"><a href="#Rocchio算法中的决策边界" class="headerlink" title="Rocchio算法中的决策边界"></a>Rocchio算法中的决策边界</h4><ul>
<li>利用质心来定义分类边界</li>
<li>两类的边界由那些<strong>到两个类质心等距的点集组成</strong>（超平面）</li>
</ul>
<h4 id="Rocchio分类方法的缺陷"><a href="#Rocchio分类方法的缺陷" class="headerlink" title="Rocchio分类方法的缺陷"></a>Rocchio分类方法的缺陷</h4><ul>
<li>为了遵循邻近性的要求，Rocchio 分类中的每个类别一定要近似球形，并且它们之间具有相似球半径。</li>
</ul>
<h3 id="KNN邻近方法"><a href="#KNN邻近方法" class="headerlink" title="KNN邻近方法"></a>KNN邻近方法</h3><h4 id="kNN（k邻近）方法"><a href="#kNN（k邻近）方法" class="headerlink" title="kNN（k邻近）方法"></a>kNN（k邻近）方法</h4><ul>
<li>kNN = k nearnest neighbors， k邻接</li>
<li>k = 1情况下的kNN：将每篇测试文档分给训练集中离它最近的那篇文档所属的类别。</li>
<li>1NN不很鲁棒 —— 一篇文档可能会分错类或者这篇文档本身就返常</li>
<li>k&gt;1情况下的kNN：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>kNN的基本依据<ul>
<li>根据邻近假设，一篇测试文档d将和其邻域中的训练文档应该具有相同的类别。</li>
</ul>
</li>
</ul>
<h4 id="1NN分类器"><a href="#1NN分类器" class="headerlink" title="1NN分类器"></a>1NN分类器</h4><ul>
<li>1NN分类器的判别边界是<strong>Voronoi剖分</strong>形成的多个线段的连接。Voronoi剖分会将整个平面分成|D|个凸多边形，每个多边形仅包含其对应的文档，而每个凸多边形是在二维空间种通过直线围成的凸区域。</li>
</ul>
<h4 id="小结：KNN方法"><a href="#小结：KNN方法" class="headerlink" title="小结：KNN方法"></a>小结：KNN方法</h4><ul>
<li>思路：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>KNN的基本依据：根据邻近假设，一篇测试文档d将和其领域中的训练文档应该具有相同的类别<ul>
<li>当训练集非常大的时候，KNN分类精度很高</li>
<li>当训练集非常小的时候，KNN效果很差</li>
</ul>
</li>
</ul>
<h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><ul>
<li>定义</li>
</ul>
<h2 id="基于向量空间模型的文本分类-1"><a href="#基于向量空间模型的文本分类-1" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><h3 id="二元线性SVM"><a href="#二元线性SVM" class="headerlink" title="二元线性SVM"></a>二元线性SVM</h3><ul>
<li>SVM是最大间隔分类器的一种，它是局域向量空间的机器学习方法，其目标是找到两个类别之间的一个决策边界，使之尽量远离训练集上的任意一点。</li>
<li>SVM定义的准则是<strong><u>寻找一个离数据点最远的决策面</u></strong>。从决策面到最近数据点的距离决定了<strong>分类器的间隔</strong></li>
</ul>
<h4 id="小结：SVM要点"><a href="#小结：SVM要点" class="headerlink" title="小结：SVM要点"></a>小结：SVM要点</h4><ul>
<li>线性SVM的结果分类器为：</li>
<li>SVM基本过程：<ul>
<li>基于给定训练数据集，通过二次优化过程寻找最佳的分类超平面</li>
<li>对于待分类的新数据点，利用分类函数计算该点到超平面的距离</li>
<li>距离的正负（分类函数的符号）决定了该数据点类别的归属</li>
<li>如果该点在分类器的间隔之内，分了器可以在原来的两个类之外，返回“类别未知”</li>
</ul>
</li>
<li>​</li>
</ul>
<h2 id="文本聚类"><a href="#文本聚类" class="headerlink" title="文本聚类"></a>文本聚类</h2><h3 id="聚类介绍"><a href="#聚类介绍" class="headerlink" title="聚类介绍"></a>聚类介绍</h3><h4 id="聚类的定义"><a href="#聚类的定义" class="headerlink" title="聚类的定义"></a>聚类的定义</h4><ul>
<li>文档聚类是将一系列文档按照相似性聚团成子集或者簇的过程</li>
<li>簇内文档之间应该彼此相似，相似度不大</li>
<li>聚类是一种最常见的无监督学习方法<ul>
<li>无监督学习意味着没有已标注好的数据集</li>
</ul>
</li>
</ul>
<h4 id="分类VS聚类"><a href="#分类VS聚类" class="headerlink" title="分类VS聚类"></a>分类VS聚类</h4><ul>
<li>分类：有监督的学习</li>
<li>聚类：无监督的学习</li>
<li>分类：类别事先人工定义好，并且是学习算法的输入的一部分</li>
<li>聚类：簇在没有人工输入的情况下从数据中推理而得<ul>
<li>但是很多因素会影响聚类的输出结果：簇的个数、相似度计算方法、文档的表示方式等。</li>
</ul>
</li>
</ul>
<h3 id="聚类在IR中的应用"><a href="#聚类在IR中的应用" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h3><h4 id="聚类假设"><a href="#聚类假设" class="headerlink" title="聚类假设"></a>聚类假设</h4><ul>
<li>在考虑文档和信息需求之间的相关性式，同一簇中的文档表现互相类似。</li>
<li>聚类在IR中的应用所有应用都直接或间接基于上述聚类假设</li>
</ul>
<h4 id="聚类在IR中的应用-1"><a href="#聚类在IR中的应用-1" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h4><table>
<thead>
<tr>
<th>应用</th>
<th>聚类对象</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>搜索结果聚类</td>
<td>搜索结果</td>
<td>提供面向用户的更有效的展示</td>
</tr>
<tr>
<td>“分散-集中”界面</td>
<td>文档集和文档子集</td>
<td>提供了另一种用户界面，即不需要人工输入关键词的搜索界面</td>
</tr>
<tr>
<td>文档聚类</td>
<td>文档集</td>
<td>提供了一种面向探索式浏览的有效性的信息展示法</td>
</tr>
<tr>
<td>基于语言建模的IR文档集</td>
<td>文档集</td>
<td>提高了正确率和/或召回率</td>
</tr>
<tr>
<td>基于聚类的检索</td>
<td>文档集</td>
<td>加快了搜索的速度</td>
</tr>
</tbody>
</table>
<h4 id="文档聚类用于提高召回率"><a href="#文档聚类用于提高召回率" class="headerlink" title="文档聚类用于提高召回率"></a>文档聚类用于提高召回率</h4><ul>
<li>实现将文档集中的文档进行聚类</li>
<li>当文档和查询匹配时，也返回包含d的簇所包含的其它文档</li>
<li>我们希望通过上述做法，在输入查询“car”时，也能包含“automobile”的文档</li>
<li>由于聚类算法会把包含“car”的文档和包含“automobile”的文档聚在一起</li>
</ul>
<h4 id="聚类的要求"><a href="#聚类的要求" class="headerlink" title="聚类的要求"></a>聚类的要求</h4><ul>
<li>一般目标： 将相关文档放到一个簇中，将不相关文档放到不同的簇中</li>
<li>簇的数目应该合适，以便于聚类的数据集吻合<ul>
<li>一开始，假设给定簇的数目为K</li>
<li>后面介绍K的半自动的方法</li>
</ul>
</li>
<li>其它目标：<ul>
<li>避免非常小和非常大的簇</li>
<li>定义的簇对用户来说很容易理解</li>
<li>其它……</li>
</ul>
</li>
</ul>
<h4 id="扁平聚类vs层次聚类"><a href="#扁平聚类vs层次聚类" class="headerlink" title="扁平聚类vs层次聚类"></a>扁平聚类vs层次聚类</h4><ul>
<li><p>扁平算法：</p>
<ul>
<li>通过一开始将全部或部分文档随机划分为不同的组</li>
<li>通过迭代不断修正</li>
<li>代表算法： K-均值聚类算法</li>
</ul>
</li>
<li><p>层次算法：</p>
<ul>
<li>构建具有层次结果的簇</li>
<li>自底向上（Bottom-up）的算法称为凝聚式算法</li>
<li>自顶向下的（Top-down）算法称为分裂式算法</li>
</ul>
</li>
</ul>
<h4 id="硬聚类vs软聚类"><a href="#硬聚类vs软聚类" class="headerlink" title="硬聚类vs软聚类"></a>硬聚类vs软聚类</h4><ul>
<li>硬聚类：每篇文档仅仅属于一个簇<ul>
<li>很普遍并且相对容易实现</li>
</ul>
</li>
<li>软聚类：一篇文档可以属于多个簇</li>
</ul>
<h4 id="扁平算法"><a href="#扁平算法" class="headerlink" title="扁平算法"></a>扁平算法</h4><ul>
<li>扁平算法将N篇文档划分成K个簇</li>
<li>给定一个文档集合及聚类结果簇的个数K</li>
<li><strong>寻找一个划分将这个文档集合分成K个簇，该结果满足最优划分规则</strong></li>
<li>全局优化：穷举所有的结果划分，从中选择最优的那个划分结果(无法处理)</li>
<li>高效的启发式方法：k-均值聚类算法</li>
</ul>
<h3 id="K-均值聚类算法"><a href="#K-均值聚类算法" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h3><p>最著名的聚类算法，算法十分简单，但是在很多情况下效果不错</p>
<h4 id="聚类中的文档表示"><a href="#聚类中的文档表示" class="headerlink" title="聚类中的文档表示"></a>聚类中的文档表示</h4><ul>
<li>向量空间模型</li>
<li>欧式距离计算向量之间的相关性</li>
</ul>
<h4 id="K-均值聚类算法-1"><a href="#K-均值聚类算法-1" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h4><ul>
<li>K-均值聚类算法中的每个簇都定义为其质心向量</li>
<li>划分准则：<strong>使得所有文档到其所在簇的质心向量的平方和最小</strong></li>
<li>质心向量的定义：</li>
<li>通过下列两部来实现目标优化：<ol>
<li>重分配：将每篇文档分配给离它最近的簇</li>
<li>重计算：重新计算每个簇的质心向量</li>
</ol>
</li>
</ul>
<h4 id="K-均值聚类算法一定会收敛"><a href="#K-均值聚类算法一定会收敛" class="headerlink" title="K-均值聚类算法一定会收敛"></a>K-均值聚类算法一定会收敛</h4><ul>
<li>RSS（Residual Sum of Squares）残差平方和 = 所有簇上的文档向量到质心向量的距离的平方和的总和</li>
<li>每次重新分配之后RSS会下降<ul>
<li>因为每个向量都被移到离它最近的质心向量所代表的簇中</li>
</ul>
</li>
<li>每次重新计算之后RSS也会下降</li>
<li>可能的聚类结果是有穷的，因此一定会收敛到一个固定点</li>
<li>如果出现了等值的情况，算法都采用前后一致的方法来处理</li>
<li>如果不关心少许文档在不同簇之间来回交叉的话，收敛速度通常会很快。但是完全收敛需要很庞大的迭代过程</li>
</ul>
<h4 id="K-均值聚类算法的最优性"><a href="#K-均值聚类算法的最优性" class="headerlink" title="K-均值聚类算法的最优性"></a>K-均值聚类算法的最优性</h4><ul>
<li>收敛并不意味着会达到<strong>全局最优</strong>的聚类结果，这是K-均值聚类算法最大缺点之一。如果开始的种子选择不好，最终的聚类结果可能会非常糟糕。</li>
</ul>
<h4 id="K-均值聚类算法的初始化"><a href="#K-均值聚类算法的初始化" class="headerlink" title="K-均值聚类算法的初始化"></a>K-均值聚类算法的初始化</h4><ul>
<li>种子的随机选择只是K-均值聚类算法的中初始化方法之一</li>
<li>随机选择不太鲁棒：可能会获得一个次优的聚类结果</li>
<li>更好的办法：<ul>
<li>非随机地采用某些启发式方法来选择种子（比如，过滤掉一些离群点，或则寻找具有较好文档空间覆盖度的种子集合）</li>
<li>采用层级聚类算法寻找好的种子</li>
<li>选择$i$次不同的随机种子集合，对每次产生的随机种子集合运行<strong><em>K</em></strong>-均值聚类算法，最后选择具有最小RSS的聚类结果。</li>
</ul>
</li>
</ul>
<h4 id="K-均值聚类算法的时间复杂度"><a href="#K-均值聚类算法的时间复杂度" class="headerlink" title="K-均值聚类算法的时间复杂度"></a>K-均值聚类算法的时间复杂度</h4><p>O(<em>IKNM</em>)-线性</p>
<h3 id="聚类评价"><a href="#聚类评价" class="headerlink" title="聚类评价"></a>聚类评价</h3><h4 id="内部准则"><a href="#内部准则" class="headerlink" title="内部准则"></a>内部准则</h4><p>一个内部准则的例子：K-均值聚类算法的$RSS$值。</p>
<p>但是内部准则往往不能评价聚类在应用中的实际效用</p>
<h4 id="外部准则"><a href="#外部准则" class="headerlink" title="外部准则"></a>外部准则</h4><ul>
<li>按照用户定义的<strong>分类</strong>结果来评价，即对一个分好类的数据集进行聚类，将聚类结果和事先的类别情况进行比照，得到最后的评价结果。</li>
<li>目标：<strong>聚类结果和给定分类结果一致</strong></li>
</ul>
<h4 id="纯度"><a href="#纯度" class="headerlink" title="纯度"></a>纯度</h4><ul>
<li>对每个簇，找到类别$c_j$，该类别包含$w<em>k$中的元素最多，为$n</em>{kj}$个，也就是说$w_k$的元素最多分布在$c_j$中</li>
<li>将所有n_{kj}求和，然后除以所有的文档数目N</li>
</ul>
<h3 id="簇个数确定"><a href="#簇个数确定" class="headerlink" title="簇个数确定"></a>簇个数确定</h3><ul>
<li>基本思路：<ul>
<li>从一个簇开始（K=1）</li>
<li>不断增加簇</li>
<li>对每个新的簇增加一个惩罚项</li>
</ul>
</li>
<li>在惩罚项和RSS之间折中，选择满足最佳折中条件的K</li>
<li>给定聚类结果，定义文档的代价为其到质心向量的距离(失真率)</li>
<li>定义全部失真率RSS(K)为所有文档代价和</li>
<li>对每个簇一个惩罚项$\lambda$ ，对于具有K个簇的聚类结果，总的聚类惩罚项为K$\lambda$。</li>
<li>定义聚类结果的所有开销为失真率和总聚类惩罚项的和：RSS(K)+K$\lambda$</li>
<li>选择使得(RSS(k)+Kℷ)最小的K值</li>
</ul>
<h4 id="本讲小结-1"><a href="#本讲小结-1" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>聚类的概念</li>
<li>聚类在IR中的应用</li>
<li>K-均值聚类算法</li>
<li>聚类评价</li>
<li>簇个数确定</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/IMG_7853.jpg"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a industrious programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
