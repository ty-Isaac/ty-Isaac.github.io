<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="It&apos;s a bolg that belongs to a industrious programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="Ty_Isaac">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Ty_Isaac">
<meta property="og:description" content="It&apos;s a bolg that belongs to a industrious programmer">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ty_Isaac">
<meta name="twitter:description" content="It&apos;s a bolg that belongs to a industrious programmer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> Ty_Isaac </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ty_Isaac</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/05/信息检索专题复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/05/信息检索专题复习/" itemprop="url">
                  信息检索专题复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-05T19:27:51+08:00">
                2017-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h1><p>Made by ® Isaac. Ty </p>
<p>信息检索模型：描述信息检索中的文档、查询和他们之间的关系（匹配函数）的数学模型</p>
<h4 id="IR新课题"><a href="#IR新课题" class="headerlink" title="IR新课题"></a>IR新课题</h4><ul>
<li>自然语言理解</li>
<li>多媒体检索</li>
<li>垂直检索技术</li>
<li>移动搜索</li>
<li>对社会媒体信息检索</li>
<li>问答</li>
<li>知识发现</li>
<li>行为分析、舆情控制</li>
<li>自动对话</li>
</ul>
<h2 id="2-布尔检索"><a href="#2-布尔检索" class="headerlink" title="2.布尔检索"></a>2.布尔检索</h2><h3 id="信息检索模型概述"><a href="#信息检索模型概述" class="headerlink" title="信息检索模型概述"></a>信息检索模型概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="文档表示"><a href="#文档表示" class="headerlink" title="文档表示"></a>文档表示</h5><p>一个文档被表示为<strong><u>关键词</u></strong>(bag of words)的集合</p>
<h5 id="查询表示"><a href="#查询表示" class="headerlink" title="查询表示"></a>查询表示</h5><p>查询式（Queries）被表示为<strong><u>关键词的布尔组合</u></strong>，用“与、或、非”连接起来（主析取范式）</p>
<h5 id="相关度计算"><a href="#相关度计算" class="headerlink" title="相关度计算"></a>相关度计算</h5><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是二值匹配</li>
</ul>
<h5 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h5><p>没有清晰和明显的语义结构的数据，计算机不易处理这些数据</p>
<h5 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h5><p>最典型的时关系数据库，用来保存公司的产品清单和人事记录</p>
<h5 id="聚类（clustering）"><a href="#聚类（clustering）" class="headerlink" title="聚类（clustering）"></a>聚类（clustering）</h5><p>基于文档内容进行自动聚团的任务。很像在书架上将一系列书按照它们所属的主题重新摆放的过程。</p>
<h5 id="分类（classification）"><a href="#分类（classification）" class="headerlink" title="分类（classification）"></a>分类（classification）</h5><p>根据<strong><u>给定的主题</u></strong>、固定的信息需求或者其他类别体系，将每一个文档分到一个或多个类别的任务。</p>
<h4 id="布尔模型：优缺点"><a href="#布尔模型：优缺点" class="headerlink" title="布尔模型：优缺点"></a>布尔模型：优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>查询<strong>简单</strong>，容易理解</li>
<li>通过使用复杂的布尔表达式，可方便地控制查询结果</li>
<li>相当有效的实现方法</li>
<li>经过某种训练的用户可以容易地写出布尔查询式</li>
<li>布尔模型可以通过扩展来包含排序的功能</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li><strong>弱</strong>，不支持部分匹配，完全匹配会导致结果太多或太少</li>
<li>非常<strong>刚性</strong>：“与”意味着全部；“或”意味着任何一个，所有匹配文档都将被返回</li>
<li>不考虑索引词的权重，所有文档都以相同的方式和查询相匹配</li>
<li>很难进行自动的相关反馈</li>
</ul>
<h4 id="信息检索的基本假设"><a href="#信息检索的基本假设" class="headerlink" title="信息检索的基本假设"></a>信息检索的基本假设</h4><ul>
<li>集合：固定数量的文档</li>
<li>目标：找到与用户信息需求相关的含有信息量的文档，帮助用户完成一个任务。</li>
</ul>
<h4 id="典型的搜索模型"><a href="#典型的搜索模型" class="headerlink" title="典型的搜索模型"></a>典型的搜索模型</h4><ul>
<li><strong>构造矩阵→信息需求→文字形式→查询→查询优化→结果</strong></li>
</ul>
<h4 id="返回文档的好坏"><a href="#返回文档的好坏" class="headerlink" title="返回文档的好坏"></a>返回文档的好坏</h4><h5 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h5><p>返回的能满足用户信息需求的文档占<strong>总的返回文档</strong>的百分比</p>
<h5 id="召回率"><a href="#召回率" class="headerlink" title="召回率"></a>召回率</h5><p>返回的能满足用户信息需求的文档占<strong>总的能满足用户信息需求的文档</strong>的百分比</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><ul>
<li>对于每一个词项，存储所有包含这个词项的文档的一个<u><strong>列表</strong></u>。一个文档用一个<strong><u>序列号</u></strong>docID来表示</li>
<li>应当使用可变长度的记录表<ul>
<li>在硬盘上，一串连续的记录是正常的，也是最好的</li>
<li>在内存里，可以使用链表，或者可变长度的数组</li>
</ul>
</li>
</ul>
<h4 id="倒排索引建立步骤"><a href="#倒排索引建立步骤" class="headerlink" title="倒排索引建立步骤"></a>倒排索引建立步骤</h4><ol>
<li>收集需要建立索引的文档</li>
<li>将每篇文档转换成一个个词条（token）的列表，此个过程称为词条化（tokenization)</li>
<li>进行语言预处理，产生归一化的词条来作为词项</li>
<li>对所有文档按照其中出现的词项来建立倒排索引，索引中包括一部分词典和一个全体倒排索引表</li>
</ol>
<ul>
<li>词条序列Token Sequence</li>
</ul>
<p>（修改过的词条，文档ID）对序列</p>
<ul>
<li><p>排序</p>
<p>先按照词条排序，再按照docID排序</p>
</li>
<li><p>词典和倒排表</p>
<ul>
<li>同一篇文档中多次出现的词被合并</li>
<li>分割成<strong>词典</strong>和<strong>倒排表</strong></li>
<li>词汇的<strong><u>文档频率</u></strong>也被记录</li>
</ul>
</li>
<li><p>查询的处理:AND</p>
<ul>
<li>考虑这样的查询： Brutus AND Caesar<ul>
<li>在字典中找到Brutus，得到它的倒排记录表</li>
<li>在字典中找到Caesar，得到它的倒排记录表</li>
<li>合并两个倒排列表</li>
<li>同时扫描两个倒排记录表求交集，所需时间和倒排记录的数量呈线性关系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="布尔检索模型"><a href="#布尔检索模型" class="headerlink" title="布尔检索模型"></a>布尔检索模型</h3><h4 id="文档表示-1"><a href="#文档表示-1" class="headerlink" title="文档表示"></a>文档表示</h4><p>一个文档被表示为关键词的集合</p>
<h4 id="查询表示-1"><a href="#查询表示-1" class="headerlink" title="查询表示"></a>查询表示</h4><p>查询式(Queries)被表示为<strong>关键词的布尔组合</strong>，用“与、或、非”连接起来(主析取范式DNF)</p>
<h4 id="相关度计算-1"><a href="#相关度计算-1" class="headerlink" title="相关度计算"></a>相关度计算</h4><ul>
<li>一个文档当且仅当它能够满足布尔查询式时，才将其检索出来</li>
<li>检索策略是<strong>二值匹配</strong>{0,1}</li>
</ul>
<h4 id="形式化表示"><a href="#形式化表示" class="headerlink" title="形式化表示"></a>形式化表示</h4><ol>
<li>定义：用q~dnf~ 表示查询q的析取范式，q~cc~表示q~dnf~的任意合取分量</li>
<li>文献d~j~与查询q的相似度为</li>
</ol>
<h4 id="布尔检索模型：布尔代数"><a href="#布尔检索模型：布尔代数" class="headerlink" title="布尔检索模型：布尔代数"></a>布尔检索模型：布尔代数</h4><h5 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h5><ul>
<li>只有“真”、“假”取值的变量</li>
</ul>
<h5 id="布尔操作（关系）"><a href="#布尔操作（关系）" class="headerlink" title="布尔操作（关系）"></a>布尔操作（关系）</h5><h5 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h5><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>布尔模型可以用来处理布尔表达式形式的查询</p>
<ul>
<li>布尔查询使用AND,OR和NOT来连接查询词汇<ul>
<li>将文档看作词汇的集合</li>
<li>精确：匹配或不匹配</li>
</ul>
</li>
<li>布尔模型式IR系统中最简单的模型</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><ul>
<li>按照文档频率的顺序进行处理。先处理文档频率小的，再处理大的。</li>
</ul>
<h2 id="3-词项词典和倒排记录表"><a href="#3-词项词典和倒排记录表" class="headerlink" title="3.词项词典和倒排记录表"></a>3.词项词典和倒排记录表</h2><h3 id="建立词项词典"><a href="#建立词项词典" class="headerlink" title="建立词项词典"></a>建立词项词典</h3><h4 id="文档解析"><a href="#文档解析" class="headerlink" title="文档解析"></a>文档解析</h4><ul>
<li>文档格式</li>
<li>文档中的语言</li>
<li>文档的编码方式</li>
</ul>
<h4 id="词条化"><a href="#词条化" class="headerlink" title="词条化"></a>词条化</h4><ul>
<li><p>将给定的字符序列拆分成一系列子序列的过程，其中每一个子序列称之为一个“词</p>
<p>条”Token。</p>
</li>
<li><p>词条(Tokens)、词项(Terms)</p>
</li>
<li><p>针对不同的语言，采用不同策略的词条化方法</p>
</li>
<li><p>分词的基本方法：</p>
<ul>
<li>基于词典的最大匹配法</li>
<li>机器学习方法</li>
</ul>
</li>
</ul>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><ul>
<li>停用词表：将词项按照<strong>文档集频率</strong>，从高到低排列。选取与文档意义不大，<strong>高频</strong>出现的词，例如a ,an , the , and, ….</li>
<li>优点：停用词消除可以减少term的个数</li>
<li>缺点：有时消除的停用词对检索有意义的 。 的士 ， to be or not to be</li>
<li>消除方法：查表法，基于文档频率</li>
</ul>
<h4 id="词项归一化"><a href="#词项归一化" class="headerlink" title="词项归一化"></a>词项归一化</h4><ul>
<li>将不完全一致的多个词条归纳成一个等价类，以便在它们之间进行匹配。</li>
<li>归一化结果：在IR系统的词项词典中，形成多个<strong>近似词项的一个等价类</strong></li>
<li>归一化策略：建立同义词扩展表</li>
</ul>
<h4 id="词干还原"><a href="#词干还原" class="headerlink" title="词干还原"></a>词干还原</h4><ul>
<li><strong>很粗略的去除单词两端的词缀的启发式过程</strong></li>
<li>能提高召回率，但是会降低准确率</li>
<li>porter算法</li>
</ul>
<h4 id="词形归并"><a href="#词形归并" class="headerlink" title="词形归并"></a>词形归并</h4><ul>
<li>利用词汇表和词形分析来减少曲折变化的形式，将其转变为基本形式 </li>
<li>词形归并可以减少词项词典中的词项数量</li>
</ul>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>词干还原在一般情况下会将多个派生相关词合并在一起</li>
<li>词形归并通常只将同一词元的不同曲折形式进行合并</li>
</ul>
<h3 id="实现倒排记录表"><a href="#实现倒排记录表" class="headerlink" title="实现倒排记录表"></a>实现倒排记录表</h3><h4 id="合并算法"><a href="#合并算法" class="headerlink" title="合并算法"></a>合并算法</h4><ul>
<li>通过在两个倒排表之间同时移动指针来实现合并，此时的操作与线性表的总数成线性关系。</li>
</ul>
<h4 id="基于调表的倒排记录表快速合并算法"><a href="#基于调表的倒排记录表快速合并算法" class="headerlink" title="基于调表的倒排记录表快速合并算法"></a>基于调表的倒排记录表快速合并算法</h4><ul>
<li>跳表指针能够跳过那些不可能出现在检索结果中的记录项</li>
<li>如果倒排表的长度是L，那么在每个$\sqrt L$处均放置跳表指针</li>
<li>跳表指针只对AND类型查询有用，对OR类型查询不起作用</li>
</ul>
<h4 id="短语查询"><a href="#短语查询" class="headerlink" title="短语查询"></a>短语查询</h4><h5 id="二元词索引"><a href="#二元词索引" class="headerlink" title="二元词索引"></a>二元词索引</h5><ul>
<li>将文档中每个连续词对看成一个短语，其中的每个二元词对豆浆作为词典中的词项。</li>
</ul>
<h5 id="扩展的二元词索引"><a href="#扩展的二元词索引" class="headerlink" title="扩展的二元词索引"></a>扩展的二元词索引</h5><h5 id="位置信息索引"><a href="#位置信息索引" class="headerlink" title="位置信息索引"></a>位置信息索引</h5><ul>
<li><p>在此索引中，对每个词项，都采取以下方式存储倒排表记录：</p>
<p> &lt;词项，词项频率;</p>
<p>   文档1：位置1，位置2，……</p>
<p>   文档2：位置1，位置2，……</p>
</li>
</ul>
<h2 id="4-索引构建"><a href="#4-索引构建" class="headerlink" title="4.索引构建"></a>4.索引构建</h2><h3 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h3><h3 id="语资料库"><a href="#语资料库" class="headerlink" title="语资料库"></a>语资料库</h3><h3 id="索引构建算法"><a href="#索引构建算法" class="headerlink" title="索引构建算法"></a>索引构建算法</h3><h4 id="基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）"><a href="#基于块的排序索引算法（BSBI：Blocked-sort-based-Indexing）" class="headerlink" title="基于块的排序索引算法（BSBI：Blocked sort-based Indexing）"></a>基于块的排序索引算法（BSBI：Blocked sort-based Indexing）</h4><ul>
<li>在索引构建过程中需要依次分析所有的文档，不能很容易利用压缩技巧。只有分析完所有文档，最终的倒排记录表才会完整。</li>
</ul>
<ul>
<li>基本思想：对每一个<strong>块</strong>都生成倒排记录，并排序，写入硬盘。然后将这些块<strong>合并</strong>成一个长的排好序的倒排记录。</li>
<li>每条数据占用12字节（4+4+4）（词项，文档，频数）</li>
<li>在内存中处理，累积放满固定的块，排序后写入硬盘f~i~ ，合并所有索引文件成一个</li>
</ul>
<h5 id="基于BSBI排序算法存在的问题"><a href="#基于BSBI排序算法存在的问题" class="headerlink" title="基于BSBI排序算法存在的问题"></a>基于BSBI排序算法存在的问题</h5><ul>
<li>假设能够将<strong><u>词典存入内存</u></strong>中</li>
<li>需要该词典动态增长去查找任一词项和词项ID之间的对应关系。</li>
<li>（一个可扩展的，但效率非常低的构建索引算法）</li>
</ul>
<h4 id="内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing"><a href="#内存式单遍扫描索引算法（SPIMI-Single-pass-in-memory-indexing" class="headerlink" title="内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)"></a>内存式单遍扫描索引算法（SPIMI  Single-pass  in-memory indexing)</h4><ul>
<li><p>核心思想：为每个块<strong>单独</strong>生成一个词典—— （不需要维护全局的&lt;词项,词项ID&gt;映射表）</p>
</li>
<li><p><strong>不进行排序</strong>。有新的&lt;词项,文档ID&gt;对时直接在倒排记录表中增加一项。</p>
<ul>
<li>可以为每个块生成一个完整的倒排索引，然后将这些单独的索引合并为一个大的索引</li>
</ul>
</li>
<li>压缩技术将会使SPIMI算法更加高效<ul>
<li>压缩词项</li>
<li>压缩倒排记录表</li>
</ul>
</li>
</ul>
<h4 id="分布式索引构建（Distributed-indexing）"><a href="#分布式索引构建（Distributed-indexing）" class="headerlink" title="分布式索引构建（Distributed indexing）"></a>分布式索引构建（Distributed indexing）</h4><ul>
<li><p>Web规模的索引构建</p>
<p>必须使用一个分布式的计算机集群</p>
</li>
<li><p>计算机都是故障频发的</p>
<ul>
<li>可能会在任意时刻失效</li>
</ul>
</li>
<li><p>利用集群中的主控节点来指挥索引构建工作</p>
<ul>
<li>认为主控节点是“安全的”</li>
</ul>
</li>
<li><p>将索引构建过程<strong>分解</strong>成一组并行的任务</p>
</li>
<li><p>主控计算机从集群中选取一台空闲的机器并将<strong>任务分配</strong>给它</p>
</li>
<li><p>采用两组不同的并行任务</p>
<ul>
<li><p>Parsers分析器</p>
<ol>
<li><p>主节点将一个数据片分配给一台空闲的分析服务器</p>
</li>
<li><p>分析器依次读取文档并生成&lt;词项,文档&gt;对。</p>
</li>
<li><p>分析器将这些&lt;词项,文档&gt;按照<em><strong>词项对</strong></em>分成$j$个段</p>
</li>
<li><p>每一段是按照词项首字母划分的一个区间。</p>
<p>例如：a-f,g-p,q-z 这里j=3</p>
</li>
<li><p>然后进行索引的倒排</p>
</li>
</ol>
</li>
<li>Inverters倒排器<ol>
<li><strong><em>对于一个词项分区</em></strong>，倒排器收集所有的&lt;词项,文档&gt;对（倒排记录）。</li>
<li>排序，并写入最终的倒排记录表。</li>
</ol>
</li>
</ul>
</li>
<li><p>首先，将输入文档集分割成n个数据片</p>
<ul>
<li>每个数据片就是一个文档子集（与BSBI/SPIMI算法中的数据块相对应）</li>
<li>两种分割方法<ul>
<li>基于词项的分割</li>
<li>基于文档的分割</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="数据流图"></p>
</li>
</ul>
<h3 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h3><h4 id="动态索引构建方法"><a href="#动态索引构建方法" class="headerlink" title="动态索引构建方法"></a>动态索引构建方法</h4><p>文档集通常不是静态的</p>
<ul>
<li>文档会不断的加入进来</li>
<li>文档也会被删除或者被修改</li>
</ul>
<p>词典和倒排记录表需要修改</p>
<ul>
<li>对于已在词典中的词项更新倒排记录</li>
<li>新的词项加入到词典中</li>
</ul>
<ol>
<li>周期性索引重构</li>
</ol>
<ul>
<li>建立索引的同时，旧索引继续工作</li>
<li>条件<ul>
<li>更新次数不是很多</li>
<li>能够接受对新文档检索的一定延迟（重构之前新文档检索不到）</li>
<li>有足够的资源进行重构</li>
</ul>
</li>
</ul>
<ol>
<li>维护一个大的主索引<ul>
<li>新文档信息存储在一个小的<strong>辅助索引</strong>中（位于内存）</li>
<li>检索可以同时遍历两个索引并将结果<strong>合并</strong></li>
<li>删除<ul>
<li>文档的删除记录在一个<strong>无效位向量</strong>中</li>
<li>在返回结果前利用它过滤掉已删除文档</li>
</ul>
</li>
<li>定期地将辅助索引合并到主索引中</li>
<li>文档更新通过先删除后插入的方式实现</li>
</ul>
</li>
</ol>
<h4 id="主索引与辅助索引存在的问题"><a href="#主索引与辅助索引存在的问题" class="headerlink" title="主索引与辅助索引存在的问题"></a>主索引与辅助索引存在的问题</h4><ul>
<li>频繁的合并带来很大开销</li>
<li>合并过程效率低<ul>
<li>如果每个词项的倒排记录表都单独成一个文件，那么合并主索引和辅助索引将会很高效。</li>
<li>合并是一个简单的添加操作</li>
<li>需要使用很多倒排文件—— 对文件系统来说是低效的</li>
</ul>
</li>
</ul>
<h4 id="对数合并"><a href="#对数合并" class="headerlink" title="对数合并"></a>对数合并</h4><ul>
<li>维护一系列索引$I_0, I_1 , I_2, … ,$每个都是前一个的两倍大小</li>
<li>辅助索引$Z_0$存储在内存中，而较大的（$I_0, I_1 , I_2, … ,$）存储在磁盘中</li>
<li>当$Z_0$达到上限时，将它写入磁盘$I_0$中，当下一次达到上限时，它会和$I_0$合并，生成$Z_1$<ul>
<li>此时，如果$I1$不存在，存储到$I1$中</li>
<li>如果$I1$已存在，则$Z1$与$I1$合并成$Z2 $(大小$2^{2*n}$)</li>
<li>此时，如果$I2$不存在，存储到$I2$中</li>
<li>如果$I2$已存在，则$Z2$与$I2$合并成Z3 (大小$2^{2*n}$)</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="4-索引压缩"><a href="#4-索引压缩" class="headerlink" title="4.索引压缩"></a>4.索引压缩</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>节省磁盘空间</li>
<li>提高内存的利用率（加快速度）</li>
<li>加快数据从磁盘到内存的传输速度<ul>
<li>[读取压缩数据][解压缩] 比直接 [读取未压缩的数据]快</li>
<li>前提：解压缩算法要很快</li>
</ul>
</li>
</ul>
<h4 id="压缩倒排索引的原因"><a href="#压缩倒排索引的原因" class="headerlink" title="压缩倒排索引的原因"></a>压缩倒排索引的原因</h4><ul>
<li>词典<ul>
<li>压缩的足够小以便放入内存中</li>
<li>当词典足够小时，也可以在内存中存储一部分倒排索引记录表</li>
</ul>
</li>
<li>倒排记录文件<ul>
<li>减少所需要的磁盘空间</li>
<li>减少从磁盘读取倒排记录文件所需的时间</li>
<li>大的搜索引擎在内存中存储了很大一部分倒排记录表<ul>
<li>压缩可以在内存中存储的更多</li>
</ul>
</li>
</ul>
</li>
<li>将涉及各种基于IR系统的压缩架构</li>
</ul>
<h3 id="词项统计量"><a href="#词项统计量" class="headerlink" title="词项统计量"></a>词项统计量</h3><h3 id="词典压缩"><a href="#词典压缩" class="headerlink" title="词典压缩"></a>词典压缩</h3><h4 id="有损压缩和无损压缩"><a href="#有损压缩和无损压缩" class="headerlink" title="有损压缩和无损压缩"></a>有损压缩和无损压缩</h4><ul>
<li>无损压缩：压缩之后所有原始信息都被保留<ul>
<li>在IR系统中常采用无损压缩</li>
</ul>
</li>
<li>有损压缩：丢掉一些信息</li>
<li>一些<strong>预处理步骤可以看成是有损压缩</strong>：大小写转化，停用词剔除，词干还原，数字去除等</li>
<li>有损还是无损与需求相关</li>
</ul>
<h4 id="Heaps定律：M-kT-b"><a href="#Heaps定律：M-kT-b" class="headerlink" title="Heaps定律：M=kT^b^"></a>Heaps定律：M=kT^b^</h4><ul>
<li>M是<strong>词项</strong>的数目，T是文档集中<strong>词条</strong>的个数</li>
<li>词汇量大小M和文档集大小T在对数空间存在斜率为1/2的线性关系。</li>
<li><strong>不同单词的数目与文本篇幅之间存在幂函数的关系</strong>，其幂指数小于1</li>
<li><strong>提供了对文档集中词汇量的估计</strong></li>
</ul>
<h4 id="Zipf定律"><a href="#Zipf定律" class="headerlink" title="Zipf定律"></a>Zipf定律</h4><ul>
<li><strong>词项在文档中的分布情况</strong></li>
</ul>
<ul>
<li>排名<strong>第i多</strong>的词项的文档集频率与1/i成正比</li>
<li>词项t~i~在文档集中出现的次数</li>
<li><strong>高频词项很少，低频罕见词项很多</strong></li>
</ul>
<h4 id="为什么要压缩词典"><a href="#为什么要压缩词典" class="headerlink" title="为什么要压缩词典"></a>为什么要压缩词典</h4><ul>
<li>搜索从词典开始</li>
<li>想将词典放入内存中和其他应用程序共享内存资源</li>
<li>手机或者嵌入式设备通常只有很小的内存</li>
<li>即使不在内存中，也希望足够小以便搜索能够快速启动</li>
</ul>
<h4 id="压缩词项列表：将词典看成单一字符串"><a href="#压缩词项列表：将词典看成单一字符串" class="headerlink" title="压缩词项列表：将词典看成单一字符串"></a>压缩词项列表：将词典看成单一字符串</h4><ul>
<li>将所有词项存储为一个长字符串<ul>
<li>指向下一词项的指针同时也标识着当前词项的结束</li>
<li>期望节省60%词典空间</li>
</ul>
</li>
</ul>
<h4 id="按块存储（Blocking）"><a href="#按块存储（Blocking）" class="headerlink" title="按块存储（Blocking）"></a>按块存储（Blocking）</h4><ul>
<li>每k个词项分词一块，只保留第一个指针</li>
<li>需要存储词项长度（额外一字节）</li>
</ul>
<h4 id="前端编码"><a href="#前端编码" class="headerlink" title="前端编码"></a>前端编码</h4><ul>
<li>按照词典顺序排列的连续词项之间往往具有<strong>公共前缀</strong></li>
<li>（块内k个词项的最后k-1个）</li>
</ul>
<h3 id="倒排记录表压缩"><a href="#倒排记录表压缩" class="headerlink" title="倒排记录表压缩"></a>倒排记录表压缩</h3><ul>
<li>倒排记录表远大于词典，至少10倍</li>
<li>紧密地存储每一个倒排记录表</li>
<li>每个倒排记录用<strong>文档ID</strong>来定义</li>
</ul>
<h4 id="倒排记录表：相反的两点"><a href="#倒排记录表：相反的两点" class="headerlink" title="倒排记录表：相反的两点"></a>倒排记录表：相反的两点</h4><ul>
<li>像“arachnocentric”这样的词项可能在一百万 个文档中才会出现一次 可以用log21M ≈ 20 bits来存储这一倒排记录。</li>
<li>像“the”这样的词项在每个文档中都会出现， 所以对它采用20bit/倒排记录太浪费了。<ul>
<li>这种情况更希望是0/1的bit向量<h4 id="倒排记录表项中文档ID的间距（GAP）"><a href="#倒排记录表项中文档ID的间距（GAP）" class="headerlink" title="倒排记录表项中文档ID的间距（GAP）"></a>倒排记录表项中文档ID的间距（GAP）</h4></li>
</ul>
</li>
<li>按照文档ID的递增顺序来存储一个词项的倒排列表<ul>
<li>Computer： 33，47，154，159，202，…</li>
</ul>
</li>
<li>可以存储间距<ul>
<li>33，14，107，5，43，…</li>
</ul>
</li>
<li>期望：绝大多数间距存储空间都远小于20bit</li>
</ul>
<h4 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h4><ul>
<li>目标：<ul>
<li>对于arachnocentric，使用20bit/间距项</li>
<li>对于the，使用1 bit/间距项</li>
</ul>
</li>
<li>如果词项的评价间距为G，我们想使用log2Gbit/间距项</li>
<li>关键问题：需要利用整个字节对每个间距编码<ul>
<li>可变长度编码：对一些小数字用短码来实现</li>
</ul>
</li>
<li>可变字节码：<ul>
<li>用一个字节来存储G，并分配1bit作为延续位</li>
<li>G$\le$127 对7位有效码采用二进制编码并设置延续位c=1（结束)</li>
<li>G$&gt;$127 则先对G低阶的7位编码，然后采用相同的算法用额外字节对高阶bit位进行编码</li>
<li>设置最后一个字节的延续位为1（c=1)，其他字节的c=0（未结束）</li>
</ul>
</li>
</ul>
<h2 id="5-Web搜索"><a href="#5-Web搜索" class="headerlink" title="5.Web搜索"></a>5.Web搜索</h2><h3 id="Web搜索基础"><a href="#Web搜索基础" class="headerlink" title="Web搜索基础"></a>Web搜索基础</h3><h4 id="重复文档"><a href="#重复文档" class="headerlink" title="重复文档"></a>重复文档</h4><ul>
<li>完全复制Duplication ： 可以通过指纹（fingerprints）来检测精确匹配</li>
<li>近似重复Near-Duplication：通过编辑距离计算语法上的相似性</li>
</ul>
<h4 id="相似性计算"><a href="#相似性计算" class="headerlink" title="相似性计算"></a>相似性计算</h4><ul>
<li>搭叠Shingles（N元词N-Grams）<ul>
<li>给定正整数K及文档d的一个词项序列可以定义文档d的k-shingle为d中所有k个连续词项构成的序列</li>
</ul>
</li>
<li>Jaccard系数：衡量重复度<ul>
<li>表示公式： 交集 / 并集</li>
<li>计算所有文档对之间搭叠的<strong>精确交集</strong>非常费时而且难以处理</li>
<li>使用冲Shingles中选出一个<strong>子集</strong>（素描sketch）来近似计算（抽样Sample）</li>
</ul>
</li>
</ul>
<h4 id="小结：近似重复检测"><a href="#小结：近似重复检测" class="headerlink" title="小结：近似重复检测"></a>小结：近似重复检测</h4><ul>
<li>Shingle算法的核心思想是将<strong>文件相似性</strong>问题转换为<strong>集合的相似</strong>性问题</li>
<li>数量较大时，对Shingle集合进行<strong>抽样</strong>，以降低空间和时间计算复杂性</li>
<li>shingle取样三种方法：Min-Wise,Modm,Mins</li>
</ul>
<h3 id="Web采集"><a href="#Web采集" class="headerlink" title="Web采集"></a>Web采集</h3><h4 id="采集器"><a href="#采集器" class="headerlink" title="采集器"></a>采集器</h4><ol>
<li>从已知种子URL开始</li>
<li>获取页面并解析<ol>
<li>提取页面中包含的链接</li>
<li>将链接放入URL队列</li>
</ol>
</li>
<li>对队列中的URL转2</li>
</ol>
<h5 id="采集器必须具有的功能"><a href="#采集器必须具有的功能" class="headerlink" title="采集器必须具有的功能"></a>采集器必须具有的功能</h5><ul>
<li>礼貌性：Web服务器有显示或隐式的策略控制采集器的访问</li>
<li>鲁棒性：能从采集器陷阱中跳出，能处理Web服务器的其他恶意行为</li>
<li>分布式：可以在多台机器上分布运行</li>
<li>可扩展性：添加更多机器后采集效率应该提高</li>
<li>性能和效率：充分利用不同的系统资源，包括处理器、存储器和网络带宽</li>
<li>新鲜度：对原来爬取的网页进行更新</li>
<li>功能可扩展性：支持多方面的功能扩展，例如处理新的数据格式、抓取新的协议。</li>
</ul>
<h4 id="采集器基本架构"><a href="#采集器基本架构" class="headerlink" title="采集器基本架构"></a>采集器基本架构</h4><p><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E9%87%87%E9%9B%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="采集器"></p>
<h4 id="Web-图"><a href="#Web-图" class="headerlink" title="Web 图"></a>Web 图</h4><h5 id="Web-→Web图"><a href="#Web-→Web图" class="headerlink" title="Web →Web图"></a>Web →Web图</h5><ul>
<li>将静态Web看成静态HTML网页通过超链接互相连接而成的有向图，其中每个<strong>网页</strong>是<strong>图的顶点</strong>，而每个超链接式图的<strong>有向边</strong>。</li>
<li>该有向图可能不是一个强连通图，即从一个网页出发，沿着超链接前进，有可能永远不会到达另外某个网页</li>
<li><strong>指向</strong>某个网页的链接称为 <strong><u>入链接</u></strong>（in-link)，而从某个网页指出去的链接称为<strong><u>出链接</u></strong>（out-link）。</li>
<li>入度：网页的入链数目。  出度：网页的出链数目</li>
</ul>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><ul>
<li>每个网页都用唯一的整数来表示</li>
<li>建立一个<strong>类似于倒排索引</strong>的邻接表，每行对应一个网页，按照其对应的整数大小排序。</li>
<li>任一网页P对应的行中包含的也是一系列整数的排序结构，每个整数对应<strong><u>链向P</u></strong>的网页编号。（那些网页指向P）</li>
</ul>
<h4 id="链接分析"><a href="#链接分析" class="headerlink" title="链接分析"></a>链接分析</h4><h5 id="Web是有向图"><a href="#Web是有向图" class="headerlink" title="Web是有向图"></a>Web是有向图</h5><ul>
<li>假设1：A到B的超链接表示A的作者对B的认可</li>
<li>假设2：指向页面B的锚文本式对B一个很好的描述</li>
</ul>
<h5 id="索引锚文本"><a href="#索引锚文本" class="headerlink" title="索引锚文本"></a>索引锚文本</h5><ul>
<li>索引文档D的时候，也索引指向文档D的锚文本</li>
<li>可以根据锚文本<strong><u>所在页面的权威性</u></strong>来确定锚文本的权重</li>
</ul>
<h5 id="小结：锚文本"><a href="#小结：锚文本" class="headerlink" title="小结：锚文本"></a>小结：锚文本</h5><ul>
<li>Web上很多网页的内容并不包含对自身的精确描述</li>
<li>Web搜索者不一定要使用网页中的词项来对网页进行查询，而使用锚文本。</li>
<li>锚文本周围窗口中的文本也可以当成锚文本一样来使用。</li>
</ul>
<h4 id="链接分析：PageRank"><a href="#链接分析：PageRank" class="headerlink" title="链接分析：PageRank"></a>链接分析：PageRank</h4><h5 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h5><ul>
<li>对Web图中的每个节点赋一个0~1间的分值，这个分值为PageRank</li>
<li><strong>查询词无关</strong>的排序</li>
<li>第一代版本：使用<strong>链接的数目</strong>作为流行程度的最简单度量</li>
<li>两个改进：<ul>
<li>无向流行度：赋予每个页面一个分：出链数+入链数</li>
<li>有向流行度：页面分数 = <strong>入链数</strong></li>
</ul>
</li>
</ul>
<h5 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h5><ul>
<li>检索出所有满足文本查询词的页面，然后把这些页面按照链接的流行的排序。</li>
<li>更复杂：把链接按流行度当作静态得分，结合文本匹配的分数进行综合排序</li>
</ul>
<h5 id="PageRank打分"><a href="#PageRank打分" class="headerlink" title="PageRank打分"></a>PageRank打分</h5><ul>
<li>假设一个浏览者在网络上随机行走<ul>
<li>从一个随机页面开始，每一步从当前页等概率地选择一个链接，进入链接所在页面</li>
</ul>
</li>
<li>在稳定状态下，每个页面都有一个访问概率——用这个概率作为页面的分数</li>
<li>当浏览者在Web上进行节点间的随机游走时，某些节点的访问次数会比其他的节点更多</li>
<li>访问频繁的节点具有很多从其它频繁访问节点中指向的入链接</li>
<li>PageRank思路：<strong>在随机游走过程中越频繁访问的网页越重要</strong></li>
</ul>
<h5 id="随机跳转（Teleporting）"><a href="#随机跳转（Teleporting）" class="headerlink" title="随机跳转（Teleporting）"></a>随机跳转（Teleporting）</h5><ul>
<li>遇到dead end时，随机跳转到一个页面，如果页面总数总是N，那么随机跳转的概率式1/N</li>
<li>非dead end， 以$a$(值较小)的概率跳转到一个随机页面；以剩余1-a的概率从页面的出链中选择一个</li>
<li>随机跳转结果：不会再困在一个地，将会有比率表示所有网页长期被访问的概率</li>
</ul>
<h5 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h5><ul>
<li>一个Markov链有<strong>N个状态</strong>，以及一个NxN的<strong>转移概率矩阵P</strong>。每一步只能处在一个状态</li>
<li>$1 \le i,j\le N$，转移概率矩阵P~ij~给出了从状态i到下一个状态j的条件转移概率</li>
<li>P中每一行的元素之和为1，从该页面跳转道其所有出链的概率之和为1</li>
<li>满足上述性质的非负矩阵被成为随机矩阵。最大特征值是1，与该特征值对应的有一个<strong>左特征向量</strong></li>
<li>马尔科夫链中下一个状态的分布仅仅依赖于当前的状态，与如何到达当前状态无关。</li>
<li>马尔科夫链的状态概率分布可以看成一个概率向量，每个元素都在[0,1]，且所有元素的和为1（行）</li>
</ul>
<h5 id="邻接矩阵A→概率转移矩阵P"><a href="#邻接矩阵A→概率转移矩阵P" class="headerlink" title="邻接矩阵A→概率转移矩阵P"></a>邻接矩阵A→概率转移矩阵P</h5><ul>
<li>如果一行没有1（没有出链），用1/N代替每个元素</li>
<li>否则<ul>
<li>每行中用1的个数除每个1。（归一化） 若某行3个1，每个1用1/3表示</li>
<li>上面处理的结果矩阵乘以1-a</li>
<li>上面结果矩阵元素加上  a/N </li>
</ul>
</li>
</ul>
<h5 id="概率向量的变化"><a href="#概率向量的变化" class="headerlink" title="概率向量的变化"></a>概率向量的变化</h5><ul>
<li>最终访问频率收敛与固定的、稳态概率π</li>
<li>算法： 给 <strong><em>X</em></strong> 乘上P的k次方，k不断增加，直到乘积稳定</li>
<li><strong><em>π</em></strong>P = <strong><em>π</em></strong>  <ul>
<li>解矩阵等式得到<strong><em>π</em></strong></li>
<li><strong><em>π</em></strong>是P的主左特征向量，<strong><em>π~i~</em></strong>是页面i的PageRank</li>
</ul>
</li>
</ul>
<h3 id="链接分析：HITS"><a href="#链接分析：HITS" class="headerlink" title="链接分析：HITS"></a>链接分析：HITS</h3><ul>
<li>对每个网页给出两个得分 hub值（导航） ，authority值（权威）</li>
<li>确定基本集</li>
<li>精选出Hub页和Authority页</li>
<li>迭代跟新h(x),a(x)<ul>
<li>输出h(x)最高作为Top Hub页，a(x)最高作为Top Authority页</li>
</ul>
</li>
<li>大概5次迭代就会稳定</li>
<li>h是$AA^t$的特征向量，a是$A^tA$的特征向量</li>
</ul>
<h2 id="6-向量模型"><a href="#6-向量模型" class="headerlink" title="6.向量模型"></a>6.向量模型</h2><h3 id="排序式检索"><a href="#排序式检索" class="headerlink" title="排序式检索"></a>排序式检索</h3><p>布尔检索：文档要么匹配要么不匹配。对自身需求和文档集性质非常了解的专家而言，布尔查询式不错的选择。然而对大多数用户来说不方便</p>
<ul>
<li>布尔查询的结果不是太多就是太少</li>
<li>需要花费很多精力去<strong>构造一个合适的query</strong>才可以获得一个在数量上可以接受的查询结果。</li>
</ul>
<h4 id="排序检索模型"><a href="#排序检索模型" class="headerlink" title="排序检索模型"></a>排序检索模型</h4><ul>
<li>在排序检索模型中，系统根据<strong>文档与query的相关性排序</strong>返回文档集合中的文档，而不是简单地返回所有满足query描述的文档集合。</li>
<li>自由文本查询：用户query是自然语言的一个或多个词语而不是由查询语言构造的表达式。</li>
<li>总体上，排序检索模型中有布尔查询和自由文本查询两种方式，但是实际中排序检索模型总是与自由文本查询联系在一起，反之亦然。</li>
</ul>
<h4 id="过多、过少不再是问题"><a href="#过多、过少不再是问题" class="headerlink" title="过多、过少不再是问题"></a>过多、过少不再是问题</h4><ul>
<li>当系统给出的式有序的查询结果，查询结果数目多不再是问题。只需要给出<strong>top K</strong>（10个左右）个结果，为用户减轻负担。</li>
<li>前提是有<strong>合适的排序算法</strong></li>
</ul>
<h4 id="排序检索的基本—-评分"><a href="#排序检索的基本—-评分" class="headerlink" title="排序检索的基本—-评分"></a>排序检索的基本—-评分</h4><p>希望根据文档对查询者的有用性大小顺序将文档返回给查询者</p>
<ul>
<li>给每个“查询—文档”对进行评分，在[0,1]之间</li>
<li><strong><em><em>这个评分值衡量文档与query的匹配程度</em></em></strong></li>
<li>以单个单词组成的query为例<ul>
<li>如果单词不出现在文档中，该文档得分为0</li>
<li>该词项在文档中出现的频率越高，则评分越高</li>
</ul>
</li>
</ul>
<h5 id="评分方案一—-Jaccard系数"><a href="#评分方案一—-Jaccard系数" class="headerlink" title="评分方案一—-Jaccard系数"></a>评分方案一—-Jaccard系数</h5><p>一种常用的衡量<strong>两个集合A,B重叠度</strong>的方法</p>
<ul>
<li>$Jaccard(A,B) = |A \cap B| / |A \cup B|$</li>
<li>$Jaccard(A,A) = 1$</li>
<li>$Jaccard(A,B) = 0 \ if\  A \cap B=0$</li>
<li>集合A和B不需要具有同样的规模</li>
<li>Jaccard(A,B)的取值在[0,1]</li>
</ul>
<p>用Jaccard系数评分的问题</p>
<ul>
<li>没有考虑<strong><em>词项频率</em></strong>（词项在文档中出现的次数）</li>
<li>没有考虑<strong><em>罕见词比高频词的信息量更大，更具区分度</em></strong></li>
</ul>
<h3 id="词项频率"><a href="#词项频率" class="headerlink" title="词项频率"></a>词项频率</h3><h4 id="词项–文档二值关联矩阵"><a href="#词项–文档二值关联矩阵" class="headerlink" title="词项–文档二值关联矩阵"></a>词项–文档二值关联矩阵</h4><ul>
<li>每个文档用一个二值向量表示 $\in {0,1}^{|v|}$  。每个词项是否属于某个文档</li>
</ul>
<h4 id="词项—文档词频关联矩阵"><a href="#词项—文档词频关联矩阵" class="headerlink" title="词项—文档词频关联矩阵"></a>词项—文档词频关联矩阵</h4><ul>
<li>考虑词项在文档中出现的频率，将每个文档看成是一个<strong><em>词频向量</em></strong>：矩阵中的一列</li>
</ul>
<h4 id="词袋模型（Bag-of-words）"><a href="#词袋模型（Bag-of-words）" class="headerlink" title="词袋模型（Bag of words）"></a>词袋模型（Bag of words）</h4><ul>
<li><p><strong>不考虑词在文档中出现的顺序</strong></p>
<p>“John is quicker than Mary” 和 “Mary is quicker than John” 的表示结果一样</p>
</li>
</ul>
<h5 id="词项频率tf（Term-frequency）"><a href="#词项频率tf（Term-frequency）" class="headerlink" title="词项频率tf（Term frequency）"></a>词项频率tf（Term frequency）</h5><p>词项频率：词项t在文档d中出现的次数，记为$tf_{t,d}$</p>
<ol>
<li>采用原始tf值（raw tf）<ul>
<li>某个词项在A文档中出现10次，即tf=10，在B文档中tf=1，那么A比B更相关，但是相关度不会相差10倍</li>
<li><strong><em>相关性不会正比于词项频率</em></strong></li>
</ul>
</li>
<li>对数词频<ul>
<li>词项t在文档d中的对数频率权重</li>
<li><img src="http://oo9y7ylu4.bkt.clouddn.com/image/knowledge/%E5%AF%B9%E6%95%B0%E9%A2%91%E7%8E%87.png" alt="对数词频"><ul>
<li>文档——词项的<strong><em>匹配得分</em></strong>是所有<strong>同时出现</strong>在<u>query</u>和<u>文档d</u>中的词项的词频的对数之和</li>
<li>$Score(q,d) = \sum<em>{t\in q\cap d} (1+log^{tf</em>{t,d}})$</li>
<li>评分为0，表示文档和query没有<strong><em>公共词项</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="tf-idf权重计算"><a href="#tf-idf权重计算" class="headerlink" title="tf-idf权重计算"></a>tf-idf权重计算</h3><p>除词项频率tf之外，利用<strong>词项在整个文档集中</strong>的频率进行权重和评分计算</p>
<h4 id="罕见词所期望的权重"><a href="#罕见词所期望的权重" class="headerlink" title="罕见词所期望的权重"></a>罕见词所期望的权重</h4><ul>
<li><strong>罕见词比常见词所蕴含的信息更多</strong></li>
<li>考虑查询中某个词项，它会在整个文档集中非常罕见</li>
<li><strong>某篇包含该词项的文档很可能相关</strong>，故罕见词项将有较高权重</li>
</ul>
<h4 id="常见词项所期望的权重"><a href="#常见词项所期望的权重" class="headerlink" title="常见词项所期望的权重"></a>常见词项所期望的权重</h4><ul>
<li>常见词项的<strong>信息量</strong>不如罕见词</li>
<li>考虑一个查询此项，它频繁出现在文档集中</li>
<li>一篇包含该词项的文档当然比不包含该词项的文档的相关度要高</li>
<li>但是，这些词对于相关度而言并<strong><em><em>不是非常强的指示词</em></em></strong>，故<strong><em><em>给一个正的权重，但是整个权重小于罕见词权重</em></em></strong></li>
</ul>
<h4 id="文档频率（Document-frequency，df）"><a href="#文档频率（Document-frequency，df）" class="headerlink" title="文档频率（Document frequency，df）"></a>文档频率（Document frequency，df）</h4><ul>
<li>罕见词项赋予高权重</li>
<li>常见词项赋予正的低权重</li>
<li>文档频率$df$因子来计算 查询–文档的匹配得分</li>
<li><strong><em>文档频率</em></strong>：出现词项的文档数目</li>
</ul>
<h4 id="idf（inverse-document-frequency）逆文档频率"><a href="#idf（inverse-document-frequency）逆文档频率" class="headerlink" title="idf（inverse document frequency）逆文档频率"></a>idf（inverse document frequency）逆文档频率</h4><ul>
<li>$df_t$是词项t的<strong>文档频率</strong>：<strong>文档集合中包含t的文档数目</strong><ul>
<li>$df_t$与词项t包含的<strong>信息量</strong>成<strong>反比</strong>（出现文档数目越多，该词项的信息量相对较小）</li>
<li>$df_t \le N$ (N是文档的总数)</li>
</ul>
</li>
<li><p>定义t的<strong>逆文档频率</strong>为$idf$</p>
<p>  $idf<em>t = log</em>{10}(N/df_t)$</p>
</li>
<li>$idf_t$是反应<strong>词项t的信息量</strong>的一个指标</li>
<li>用$log_{10}(N/df_t)$来代替$\frac{N}{df_t}$来抑制idf的作用</li>
</ul>
<h4 id="idf对排序的影响"><a href="#idf对排序的影响" class="headerlink" title="idf对排序的影响"></a>idf对排序的影响</h4><ul>
<li>对于含有<strong>两个以上查询词的query</strong>，$idf$才会影响排序结果；只有一个查询词的query，idf对排序结果没有影响</li>
<li>例如 Query: arachnocentric line ， idf会提高 arachnocentric的相对权重，同时减低line的相对权重</li>
</ul>
<h4 id="文档集频率和文档频率"><a href="#文档集频率和文档频率" class="headerlink" title="文档集频率和文档频率"></a>文档集频率和文档频率</h4><ul>
<li>文档集频率（collection frequency,cf）是<u>指t在整个文档集合中出现的<strong><em><em>词的次数</em></em></strong></u>。</li>
<li>文档频率（document frequency，df）<u>包含该词项的<strong><em><em>文档数目</em></em></strong></u></li>
<li>df比cf更适合权重计算</li>
</ul>
<h4 id="tf–idf文档-逆文档频率（单个词）"><a href="#tf–idf文档-逆文档频率（单个词）" class="headerlink" title="tf–idf文档-逆文档频率（单个词）"></a>tf–idf文档-逆文档频率（单个词）</h4><ul>
<li>tf-idf是信息检索中最著名的权重计算方法</li>
<li>词项t的tf-idf式由它的tf和idf组合而成</li>
<li>$w<em>{t,d} = (1+logtf</em>{t,d})\times\log_{10}(N/df_t)$</li>
<li>tf-idf值随着<strong><em>词项在单个文档中出现次数(tf)增加而增加</em></strong>，随着<strong><em>词项在文档集中数目(df)增加而减小</em></strong></li>
</ul>
<h4 id="Query-最终文档排序"><a href="#Query-最终文档排序" class="headerlink" title="Query 最终文档排序"></a>Query 最终文档排序</h4><p>$Score(q,d) = \sum<em>{t\in q \cap d}tf*idf</em>{t,d}$</p>
<h3 id="向量空间模型"><a href="#向量空间模型" class="headerlink" title="向量空间模型"></a>向量空间模型</h3><ul>
<li>二值关联矩阵：每个文档用一个二值向量表示 $\in {0,1}^{|v|}$</li>
<li>词频矩阵：每篇文档表示成一个词频向量 $\in N^{|v|}$</li>
<li>tf-idf矩阵：每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$</li>
</ul>
<h4 id="文档表示成向量"><a href="#文档表示成向量" class="headerlink" title="文档表示成向量"></a>文档表示成向量</h4><ul>
<li>每篇文档表示成一个基于tf-idf权重的实值向量$\in R^{|v|}$(V式词项集合，|v|表示词项个数)</li>
<li>|v|维实向量空间<ul>
<li>空间每一维都对应<strong>词项</strong></li>
<li><strong>文档</strong>是空间的点或者向量</li>
<li>维度非常高：特别是互联网搜索引擎，空间可达千万维或更高</li>
<li>向量空间非常<strong>稀疏</strong>：对每个向量来说大部分都是0</li>
</ul>
</li>
</ul>
<h4 id="Queries表示成向量"><a href="#Queries表示成向量" class="headerlink" title="Queries表示成向量"></a>Queries表示成向量</h4><ol>
<li>对于查询做同样的处理，即将查询表示成统一高维空间的向量</li>
<li>在向量空间内根据query与<strong>文档相量间的距离</strong>来排序</li>
</ol>
<h4 id="利用夹角代替距离"><a href="#利用夹角代替距离" class="headerlink" title="利用夹角代替距离"></a>利用夹角代替距离</h4><ul>
<li>按query与文档夹角递减给文档排序，按余弦递增给文档排序 是的等价的。</li>
<li>按余弦cosine(query,document)递减给文档排序，只考虑相对顺序</li>
</ul>
<h4 id="文档长度归一化"><a href="#文档长度归一化" class="headerlink" title="文档长度归一化"></a>文档长度归一化</h4><ul>
<li>利用二范数对文档长度进行归一化，一个文档向量除以它的L~2~范数就是给这个文档进行长度归一化</li>
</ul>
<h2 id="6-检索系统"><a href="#6-检索系统" class="headerlink" title="6.检索系统"></a>6.检索系统</h2><h3 id="排序的重要性"><a href="#排序的重要性" class="headerlink" title="排序的重要性"></a>排序的重要性</h3><ul>
<li>用户只希望看到一些而不是成千上万的结果</li>
<li>很难构造只产生一些结果的查询，即使是专家也很难</li>
<li>→排序能够将成千上万条结果缩减至几条结果，因此非常重要</li>
<li>实际上大部分用户只看到1-3条结果</li>
</ul>
<h4 id="摘要阅读"><a href="#摘要阅读" class="headerlink" title="摘要阅读"></a>摘要阅读</h4><p>用户更可能阅读前几页(1, 2, 3, 4)的结果的摘要</p>
<h4 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h4><p>点击的分布甚至更有偏向性</p>
<ul>
<li>一半情况下，用户点击排名最高的页面<ul>
<li>即使排名最高的页面不相关，仍然有30%的用户会点击它            </li>
</ul>
</li>
<li>正确排序相当重要，把相关的页面放在首页非常重要</li>
</ul>
<h3 id="结果排序的实现"><a href="#结果排序的实现" class="headerlink" title="结果排序的实现"></a>结果排序的实现</h3><h4 id="tf和idf的存储"><a href="#tf和idf的存储" class="headerlink" title="tf和idf的存储"></a>tf和idf的存储</h4><ul>
<li><p>词典中保存每个词的idf</p>
</li>
<li><p>词项频率tf存入倒排索引</p>
<p>term|idf    →  d1,tf , \<p1,p2,…> d5, tf, \<p1,p2,…></p1,p2,…></p1,p2,…></p>
</li>
</ul>
<h4 id="精确top-K检索机器加速办法"><a href="#精确top-K检索机器加速办法" class="headerlink" title="精确top K检索机器加速办法"></a>精确top K检索机器加速办法</h4><ul>
<li>从文档集所有文档中找出K个离查询最近的文档</li>
<li>步骤：对每个文档频繁（余弦相似度），按评分高低排序，选出前K个结果</li>
<li>如何加速：<ul>
<li>加快每个余弦相似度的计算</li>
<li>不对所有文档的评分结果排序而直接选出top K篇</li>
<li>能否不需要计算所有N篇文档的得分</li>
</ul>
</li>
</ul>
<h4 id="快速计算余弦相似度"><a href="#快速计算余弦相似度" class="headerlink" title="快速计算余弦相似度"></a>快速计算余弦相似度</h4><ul>
<li>检索排序就是找查询的k临近</li>
<li>如果查询很短，可以加速<ul>
<li>查询的多个词项无权重</li>
<li>排序只需要相对得分</li>
</ul>
</li>
</ul>
<h4 id="堆排序法N中选K"><a href="#堆排序法N中选K" class="headerlink" title="堆排序法N中选K"></a>堆排序法N中选K</h4><ul>
<li>检索时，通常只需要返回前K条结果</li>
<li>令J=具有非零余弦相似度值的文档数目，利用对结构从J中选K个最大的</li>
</ul>
<h4 id="提前终止计算"><a href="#提前终止计算" class="headerlink" title="提前终止计算"></a>提前终止计算</h4><h4 id="非精确top-K检索的可行性"><a href="#非精确top-K检索的可行性" class="headerlink" title="非精确top K检索的可行性"></a>非精确top K检索的可行性</h4><ul>
<li>索引去除：<ul>
<li>对于一个包含多个词项的查询来说，可以只考虑<strong>至少包含一个查询词项的文档</strong></li>
<li>只考虑那些词项的<strong>idf值</strong>超过一定阈值的文档</li>
<li>只考虑包含<strong>多个查询词项</strong></li>
</ul>
</li>
<li>胜者表<ul>
<li>对于词典中的每个词项t，预先计算出r个最高权重的文档<ul>
<li>词项t所对应的tf值最高的r篇文档构成t的胜者表，r值<strong>在索引建立时给定</strong>可能r&lt;k</li>
</ul>
</li>
<li>根据给定查询q，对查询q中所有词项的胜者表求并集生成集合A。根据余弦相似度大小从A中选取前top K个文档</li>
</ul>
</li>
<li>静态得分<ul>
<li>希望排序考前的文档既相关又是权威的<ul>
<li>相关性通过余弦相似度得分来判断</li>
<li>权威性由文档本身的属性决定</li>
</ul>
</li>
<li>​</li>
</ul>
</li>
</ul>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>信息检索的目标式<strong><em><em>较少消耗情况下尽快、全面返回准确的结果。</em></em></strong></p>
<h3 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h3><h4 id="效率（Efficiency）"><a href="#效率（Efficiency）" class="headerlink" title="效率（Efficiency）"></a>效率（Efficiency）</h4><ul>
<li>时间开销</li>
<li>空间开销</li>
<li>响应速度<h4 id="效果（Effectiveness）"><a href="#效果（Effectiveness）" class="headerlink" title="效果（Effectiveness）"></a>效果（Effectiveness）</h4></li>
<li>返回的文档中有多少相关文档</li>
<li>所有相关文档中反回了多少</li>
<li>返回得靠不靠前<h4 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h4></li>
<li>覆盖率（Coverage）</li>
<li>访问量</li>
<li>数据更新速度</li>
</ul>
<h4 id="评价效果"><a href="#评价效果" class="headerlink" title="评价效果"></a>评价效果</h4><ul>
<li><strong>相同的文档</strong>集合，<strong>相同的查询</strong>主题集合，<strong>相同的评价指标</strong>，<strong>不同</strong>的检索系统进行比较。</li>
</ul>
<h3 id="无序检索结果的评价"><a href="#无序检索结果的评价" class="headerlink" title="无序检索结果的评价"></a>无序检索结果的评价</h3><h4 id="对单个查询进行评估的指标"><a href="#对单个查询进行评估的指标" class="headerlink" title="对单个查询进行评估的指标"></a>对单个查询进行评估的指标</h4><h5 id="对整个文档集合的划分"><a href="#对整个文档集合的划分" class="headerlink" title="对整个文档集合的划分"></a>对整个文档集合的划分</h5><ul>
<li>未检索出（Not Retrieved）<ul>
<li>未检索出的相关文档(NR)</li>
<li>未检索出的不相关文档 (NN)</li>
</ul>
</li>
<li>检索出（Retrieved）<ul>
<li>检索出的相关文档(RR)</li>
<li>检索出的不相关文档(RN)<h5 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h5></li>
</ul>
</li>
<li>召回率(Recall):RR/(RR+NR),返回的相关结果数占实际相关结果总数的比率，也称为查全率，$R\in[0,1]$</li>
<li>正确率(Precision):RR/(RR+RN),返回的结果中真正相关的比率，也称查准率，$P\in[0,1]$</li>
<li>两个指标分别度量检索效果的某个方面，忽略任何一个方面都有偏失。</li>
<li>两个极端情况<ol>
<li>返回有把握的1篇，P=100%，但R极低</li>
<li>全部文档都返回，R=1，但P极低</li>
</ol>
</li>
<li>虽然Precision和Recall都很重要，但是不同的应用、不同的用户对两者的要求不一样。</li>
</ul>
<h4 id="正确率和召回率的问题"><a href="#正确率和召回率的问题" class="headerlink" title="正确率和召回率的问题"></a>正确率和召回率的问题</h4><ul>
<li>应用领域<ul>
<li>拼写校对、中文分词、文本分类、人脸识别、…… </li>
</ul>
</li>
</ul>
<ul>
<li>召回率难以计算<ul>
<li>Pooling方法，或则不考虑召回率</li>
</ul>
</li>
<li>两个指标分别衡量了系统的某个方面，但是如何评价哪个系统好<ul>
<li>将两个指标融成一个指标</li>
</ul>
</li>
<li>两个指标都是基于<strong><em>集合（无序）进行</em></strong>计算，并没有考虑序的作用<ul>
<li>引入序的作用</li>
</ul>
</li>
</ul>
<h5 id="召回率的计算"><a href="#召回率的计算" class="headerlink" title="召回率的计算"></a>召回率的计算</h5><p>对于大规模语料集合，列举每个查询的所有相关文档不可能，因此不可能准确地计算召回率</p>
<ul>
<li>缓冲池（Pooling）方法：对多个检索系统的TopN个结果组成的集合进行人工标注，标注相关文档集合作为整个相关文档集合</li>
</ul>
<h5 id="使用查准率-查全率的问题"><a href="#使用查准率-查全率的问题" class="headerlink" title="使用查准率/查全率的问题"></a>使用查准率/查全率的问题</h5><ul>
<li>需要在<strong>大规模</strong>的文档集合和查询集合上进行计算</li>
<li><p>需要<strong>人工</strong>对返回的文档进行评价</p>
<ul>
<li>由于人的主观因素，人工评价往往不可靠</li>
</ul>
</li>
<li><p>评价是二值的</p>
<ul>
<li>无法体现细微的差别</li>
</ul>
</li>
<li>文档结合和数据来源不同，结果也不同，有严重的偏差<ul>
<li>评价结果只适用于某个范围，很难引申到其他范围</li>
</ul>
</li>
</ul>
<h4 id="综合评价准则-F-P和R融合"><a href="#综合评价准则-F-P和R融合" class="headerlink" title="综合评价准则 F=P和R融合"></a>综合评价准则 F=P和R融合</h4><ul>
<li>F值（F-measure):召回率R和查准率的加权调和平均值</li>
<li>$F = \frac{1}{\alpha^\frac{1}{p}+(1-\alpha)^\frac{1}{R}}=\frac{(\beta^2+1)PR}{\beta^2P+R}$</li>
<li>$F_\beta$ ：表示召回率的重要程度是查准率的$\beta(&gt;=0)$倍<ul>
<li>$\beta&gt;1$ 更重视召回率，$\beta&lt;1$更重视查准率</li>
<li>取等权重</li>
<li>$F_{\beta=1} = \frac{2PR}{P+R}$</li>
</ul>
</li>
<li>调和平均比较保守</li>
</ul>
<h4 id="精确率不适合IR的原因"><a href="#精确率不适合IR的原因" class="headerlink" title="精确率不适合IR的原因"></a>精确率不适合IR的原因</h4><ul>
<li>和查询相关的文档占文档集的极少数，即使什么都不返回也会得到很高的精确率</li>
<li>用户希望找到某些文档并且能够容忍结果中有一定的不相关性</li>
<li>返回一些即使不好的文档也比不反回任何文档好</li>
</ul>
<h3 id="有序检索结果的评价"><a href="#有序检索结果的评价" class="headerlink" title="有序检索结果的评价"></a>有序检索结果的评价</h3><h4 id="评价排序后的结果"><a href="#评价排序后的结果" class="headerlink" title="评价排序后的结果"></a>评价排序后的结果</h4><ul>
<li>P、R、F值都是基于集合的评价方法，它们都是利用无序的文档集合进行计算。如果搜索引擎输出为有序的检索结果时，需要扩展</li>
<li>对于特定检索词的有序检测结果<ul>
<li>系统可能返回任意数量的结果（=N）</li>
<li>考虑Top k返回的情形</li>
<li>则每个k的取值对应一个R和P</li>
</ul>
</li>
<li>计算得到查准率-查全率曲线</li>
</ul>
<h4 id="P-R的优缺点"><a href="#P-R的优缺点" class="headerlink" title="P-R的优缺点"></a>P-R的优缺点</h4><ul>
<li>优点：<ul>
<li>简单直观</li>
<li>既考虑了检索结果的覆盖度，又考虑了检索结果的排序情况</li>
</ul>
</li>
<li>缺点:<ul>
<li>单个查询的P-R曲线虽然直观，但是难以明确表示两个查询的检索结果的优劣</li>
</ul>
</li>
</ul>
<h4 id="基于P-R曲线的单一指标"><a href="#基于P-R曲线的单一指标" class="headerlink" title="基于P-R曲线的单一指标"></a>基于P-R曲线的单一指标</h4><ul>
<li>固定检索等级的查准率<ul>
<li>Precision@k：前k个结果的查准率</li>
<li>对大多数的web搜索适合，因为用户看重在前几页中有多少好结果</li>
<li>平均的方式不好，通常所用指标中最不稳定的</li>
</ul>
</li>
<li>11点平均正确率<ul>
<li>对每个信息需求，插值的<strong>正确率</strong>定义在0,0.1,0.2,…,0.9,1共11个召回率水平上</li>
<li>对每个召回率水平，对测试集中<strong>多个查询</strong>在该点的插值正确率<strong>求算术平均</strong></li>
</ul>
</li>
</ul>
<h4 id="更多的评价准则：AP"><a href="#更多的评价准则：AP" class="headerlink" title="更多的评价准则：AP"></a>更多的评价准则：AP</h4><ul>
<li><p>平均查准率(Average Precision,AP)：对不同召回率点上的正确率进行平均</p>
<ul>
<li><p><strong>未插值AP</strong>：某个查询Q共有6个相关结果，某系统排序反回了5篇相关文档，其位置分别为 第1，第2，第5，第10，第20位。</p>
<ul>
<li>$AP = (\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20}+0)/6$，等价于6点平均</li>
</ul>
</li>
<li><p><strong>插值的AP</strong>：在召回率分别为0, 0.1, 0.2, … ,1.0的十一个点上的正确率求平均，等价于11点平均</p>
<ul>
<li><p><strong>只对返回的相关文档</strong>进行计算的AP</p>
<p>$AP =(\frac{1}{1}+\frac{2}{2}+\frac{3}{5}+\frac{4}{10}+\frac{5}{20})/5$，倾向返回那些快速返回结果的系统，<strong>没有考虑召回率</strong>，等价于5点平均</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="不考虑召回率"><a href="#不考虑召回率" class="headerlink" title="不考虑召回率"></a>不考虑召回率</h4><ul>
<li>Precision@N：在第N个位置上的正确率<ul>
<li>对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页结果。因此P@10、P@20对大规模搜索引擎来说是很好的指标</li>
</ul>
</li>
</ul>
<h4 id="宏平均vs微平均"><a href="#宏平均vs微平均" class="headerlink" title="宏平均vs微平均"></a>宏平均vs微平均</h4><ul>
<li>平均的求法：<ul>
<li>宏平均（Macro Average）：对<strong>每个查询</strong>求出某个指标，然后对这些指标进行算术平均</li>
<li>微平均（Micro Average）：将所有查询视为<strong>一个查询</strong>，将各种情况的文档总数求和，然后进行指标运算。（一个系统的所有查询）<ul>
<li>Eg： $ Micro Precision = \frac{对所有检验出的相关文档总数} {对所有查询检出的文档总数}$</li>
<li>宏平均对所有<strong>查询一视同仁</strong>，微平均受返回相关文档数目比较大的查询影响（宏平均保护弱者）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="平均查准率均值-Mean-Average-Precision-MAP"><a href="#平均查准率均值-Mean-Average-Precision-MAP" class="headerlink" title="平均查准率均值 Mean Average Precision(MAP)"></a>平均查准率均值 Mean Average Precision(MAP)</h4><ul>
<li>每个<strong><u><em>相关文档位置上</em></u></strong>查准率的平均值，被称为<strong>平均查准率</strong>（AP）</li>
<li>对所有查询求宏平均，就得到平均查准率均值（MAP）</li>
<li>$Map(Q)= \frac{1}{|Q|}\sum_{j=1}^{|Q|}\frac{1}{m<em>j}\sum</em>{k=1}^{m<em>j}Precision(R</em>{jk})$</li>
<li>Q为信息需求，$q_j \in Q$所对应的所有相关文档集合为${d_1,d<em>2,…,d</em>{mj}}$ ，$R_{ij}$是查询$q<em>j$的返回结果，该结果中包含而不含有$d</em>{k+1}$及以后的相关文档</li>
</ul>
<h4 id="面向用户的评价指标"><a href="#面向用户的评价指标" class="headerlink" title="面向用户的评价指标"></a>面向用户的评价指标</h4><ul>
<li>假定用户<strong>已知的相关文档集合为U</strong>，检索结果和U的交集为$R_u$，则<strong>覆盖率</strong><ul>
<li>$C=\frac{R_u}{U}$，<strong>检索系统找到的用户已知的相关文档比例</strong></li>
</ul>
</li>
<li>假定检索结果中返回一些用户<strong>以前未知的相关文档$R_k$</strong>，则可以定义<strong>新颖率</strong><ul>
<li>$N=\frac{|R_k|}{|R_u|+|R_k|}$，表示系统返回的新相关文档的比例</li>
</ul>
</li>
</ul>
<h4 id="GMAP"><a href="#GMAP" class="headerlink" title="GMAP"></a>GMAP</h4><ul>
<li>AP的集合平均值（更能体现细微差别）</li>
</ul>
<h4 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h4><ul>
<li>每个文段不仅仅只有相关和不相关，而是有相关级别<ul>
<li>相关度级别越高的结果越多越好</li>
<li>相关度级别越高的结果越靠前越好</li>
</ul>
</li>
</ul>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><ul>
<li>标题通常是从文档的元数据中自动抽取出来的<ul>
<li>用户根据描述信息来判断这个文档是否相关</li>
</ul>
</li>
<li>两种基本类型<ul>
<li>静态：不论输入什么查询，文档的静态摘要都是不变的</li>
<li>动态：动态摘要<strong>依赖于查询</strong>，试图解释当前文档返回的原因</li>
</ul>
</li>
</ul>
<h4 id="本讲小结"><a href="#本讲小结" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>信息检索的评价方法<ul>
<li>不考虑序的检索评价指标：P、R、F</li>
<li>考虑序的评价指标：P/R曲线、MAP、NDCG</li>
</ul>
</li>
<li>检索结果的摘要</li>
</ul>
<h2 id="相关反馈及查询扩展"><a href="#相关反馈及查询扩展" class="headerlink" title="相关反馈及查询扩展"></a>相关反馈及查询扩展</h2><ul>
<li>交互式相关反馈：在初始检索结果基础上，通过用户指定哪些文档相关或不相关，然后改进检索的结果。Rocchio相关反馈</li>
<li>查询扩展（Query expansion）：通过在查询中加入同义或者相关的词项来提供检索结果。人工编辑的同义词辞典、自动构造的同义词词典、查询日志</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h4 id="搜索中提高召回率的方法"><a href="#搜索中提高召回率的方法" class="headerlink" title="搜索中提高召回率的方法"></a>搜索中提高召回率的方法</h4><ul>
<li>提高召回率的方法—— 相关反馈及查询扩展</li>
<li>返回不包含查询词项的相关文档</li>
</ul>
<h4 id="关于召回率Recall"><a href="#关于召回率Recall" class="headerlink" title="关于召回率Recall"></a>关于召回率Recall</h4><ul>
<li>放松召回率的定义，给用户返回更多的相关文档</li>
</ul>
<h4 id="提高召回率的方法"><a href="#提高召回率的方法" class="headerlink" title="提高召回率的方法"></a>提高召回率的方法</h4><ul>
<li>局部（local）方法：对用户查询进行局部的实时分析<ul>
<li>主要局部方法：<strong>相关反馈</strong>（relevance feedback）</li>
</ul>
</li>
<li>全局（global）方法：进行一次性的全局分析产生同/近义词词典(thesaurus)<ul>
<li>利用该词典进行查询扩展</li>
</ul>
</li>
</ul>
<h3 id="相关反馈基础"><a href="#相关反馈基础" class="headerlink" title="相关反馈基础"></a>相关反馈基础</h3><h4 id="相关反馈的基本思想"><a href="#相关反馈的基本思想" class="headerlink" title="相关反馈的基本思想"></a>相关反馈的基本思想</h4><ul>
<li>用户提交一个（简短的）查询</li>
<li>搜索引擎返回一系列文档</li>
<li>用户将部分返回文档标记为<strong>相关</strong>的，将部分文档标记为<strong>不相关</strong>的</li>
<li>搜索引擎根据标记结果计算得到信息需求的一个<strong>新查询表示</strong>。（希望好于初始查询）</li>
<li>对新查询进行处理，返回新结果。</li>
<li>新结果渴望有更高的<strong>召回率</strong></li>
</ul>
<h4 id="相关反馈分类"><a href="#相关反馈分类" class="headerlink" title="相关反馈分类"></a>相关反馈分类</h4><ul>
<li>用户相关反馈或显示相关反馈（User Feedback or Explicit Feedback）：用户显示参加交互过程</li>
<li>隐式相关反馈（Implicit Feedback）：系统跟踪用户的行为来推测返回文档的相关性，从而进行反馈</li>
<li>伪相关反馈或盲目相关反馈：（Pseduo Feedback or Blind Feedback）：没有用户参与，系统直接假设返回文档的前K篇相关的，然后进行反馈。</li>
</ul>
<h3 id="相关反馈详细介绍"><a href="#相关反馈详细介绍" class="headerlink" title="相关反馈详细介绍"></a>相关反馈详细介绍</h3><h4 id="相关反馈中的核心概念：质心"><a href="#相关反馈中的核心概念：质心" class="headerlink" title="相关反馈中的核心概念：质心"></a>相关反馈中的核心概念：质心</h4><ul>
<li>质心是一系列点的中心</li>
<li>前面将文档表示成高维空间中的点</li>
<li>计算文档质心的公式：</li>
</ul>
<h4 id="相关反馈基本理论"><a href="#相关反馈基本理论" class="headerlink" title="相关反馈基本理论"></a>相关反馈基本理论</h4><ul>
<li>基本理论：假定要找一个最有查询向量q，它与相关文档之间的相似度最大且同时又和不相关文档之间的相似度最小。</li>
<li><strong><em>q~opt~</em></strong>是将相关文档与不相关文档区分开的向量</li>
<li>当sim()函数采用余弦相似度计算时，能够将相关文档与不相关文档区分开的最有查询向量为：</li>
<li>最优查询向量等于<strong>相关文档的质心向量和不相关文档的质心向量的差</strong></li>
</ul>
<h4 id="Rocchio算法"><a href="#Rocchio算法" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>假定有一个用户查询，并知道部分相关文档和不相关文档的信息，最优查询向量为</li>
<li>q-</li>
<li>修改后的新查询从q~0~开始，向相关文档质心靠近，同时与不相关文档质心远离。</li>
<li>将<strong>相关文档</strong>的质心移动一个量，该量为相关文档质心和不相关文档质心的差异量</li>
<li>修改后的新查询，向着相关文档的质心向量靠近了一段距离，与不相关文档的质心向量远离了一段距离。</li>
</ul>
<h4 id="相关反馈策略的评价"><a href="#相关反馈策略的评价" class="headerlink" title="相关反馈策略的评价"></a>相关反馈策略的评价</h4><ul>
<li>使用初始查询q~0~ ，计算”查准率-查全率“曲线</li>
<li>使用相关反馈后修改查询q~m~，然后计算”查准率-查全率“曲线<ul>
<li>方案1：在<strong>整个文档集合</strong>上评价<ul>
<li>有显著的改善，但是有作弊嫌疑部分原因是会把已知的相关文档排在很前</li>
<li>需要用用户没有看到的文档集合来评价</li>
</ul>
</li>
<li>方案2：使用<strong>剩余的文档</strong>集合来评价（总的文档集合减去评价过的相关性文档）<ul>
<li>评价结果往往<strong>比初始查询的结果差</strong>，但是这种方法更现实</li>
<li>可以用来有效比较不同相关反馈方法之间的相对效果</li>
</ul>
</li>
<li>方案3：使用<strong>两个文档</strong>集合<ul>
<li>在第一个文档集合上使用初始查询q~0~，并进行相关反馈</li>
<li>在第二个文档集合上使用初始查询q~0~和修改过的查询q~m~进行评价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="评价的误区"><a href="#评价的误区" class="headerlink" title="评价的误区"></a>评价的误区</h4><ul>
<li>评价不同相关反馈的效用的时候，必须考虑消耗时间的要素。</li>
<li>代替相关反馈的方法：用户修改并重新提交查询</li>
<li>相对于判断文档的相关性，用户可能更愿意修改并重新提交查询</li>
<li>没有证据能表明相关反馈占用了用户的时间就能给用户带来最大的效用。</li>
</ul>
<h4 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h4><ul>
<li>提高召回率</li>
<li>查询重构的全局方法。在全局查询扩展中，查询基于一些<strong>全局的资源</strong>进行修改。</li>
<li>主要使用 同义词或近义词词典（人工构建和自动构建）</li>
</ul>
<h2 id="概率检索模型"><a href="#概率检索模型" class="headerlink" title="概率检索模型"></a>概率检索模型</h2><h3 id="向量空间模型回顾"><a href="#向量空间模型回顾" class="headerlink" title="向量空间模型回顾"></a>向量空间模型回顾</h3><h4 id="向量空间模型-1"><a href="#向量空间模型-1" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>文档表示成向量</li>
<li>查询也表示成向量</li>
<li>计算两个向量之间的相似度：余弦相似度、内积相似度</li>
<li>向量表示中的词项权重计算方法主要是tf-idf公式，实际考虑<strong>tf、idf及文档长度</strong>3个因素</li>
</ul>
<h4 id="向量空间模型优缺点"><a href="#向量空间模型优缺点" class="headerlink" title="向量空间模型优缺点"></a>向量空间模型优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>简洁直观，可以应用到很多其他领域(文本分类、生物信息学)</li>
<li>支持部分匹配和近似匹配，结果可以排序</li>
<li>检索效果不错</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>理论上不够：基于直觉的经验性公式</li>
<li>索引项之间的独立性假设与实际不符：实际上，term的出现之间是有关系的，不是完全独立。</li>
</ul>
<h3 id="基本概率统计知识"><a href="#基本概率统计知识" class="headerlink" title="基本概率统计知识"></a>基本概率统计知识</h3><h4 id="随机试验和随机事件"><a href="#随机试验和随机事件" class="headerlink" title="随机试验和随机事件"></a>随机试验和随机事件</h4><h4 id="概率和条件概率"><a href="#概率和条件概率" class="headerlink" title="概率和条件概率"></a>概率和条件概率</h4><h4 id="乘法公式、全概率公式和贝叶斯公式"><a href="#乘法公式、全概率公式和贝叶斯公式" class="headerlink" title="乘法公式、全概率公式和贝叶斯公式"></a>乘法公式、全概率公式和贝叶斯公式</h4><h4 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h4><h4 id="概率检索模型-1"><a href="#概率检索模型-1" class="headerlink" title="概率检索模型"></a>概率检索模型</h4><ul>
<li>概率检索模型：通过<strong>概率的方法</strong>将查询和文档联系起来<ul>
<li>定义3个随机变量R、Q、D：<strong>相关度R</strong>={0，1}，<strong>查询Q</strong>={q1,q2,…}，<strong>文档D</strong>={d1,d2,…}</li>
<li>通过计算<strong>条件概率$P(R=1|Q=q,D=d)$</strong>来度量文档和查询的相关度</li>
</ul>
</li>
</ul>
<h4 id="概率排序原理PRP"><a href="#概率排序原理PRP" class="headerlink" title="概率排序原理PRP"></a>概率排序原理PRP</h4><ul>
<li>利用概率模型来估计每篇文档和需求的<strong><em>相关概率P(R=1|d,q)</em></strong>，然后对结果进行排序</li>
<li>最简单的PRP情况<ul>
<li>检索没有任何迭代因子，或者说不会对不同行为或错误采用不同的权重因子。</li>
<li>在返回一篇不想管文档或者返回一篇相关文档不成功的情况下，将失去1分</li>
<li>而检索的目标是对于用户给定的k值，返回可能性最高的文档前k篇作为结果输出。即RPR希望可以按照$P(R=1|d,q)$值的<strong>降序</strong>来排列所有文档</li>
</ul>
</li>
<li>公式的理解</li>
</ul>
<h4 id="基于检索代价的概率排序原理"><a href="#基于检索代价的概率排序原理" class="headerlink" title="基于检索代价的概率排序原理"></a>基于检索代价的概率排序原理</h4><ul>
<li>C~1~表示一篇<strong>相关文档未返回</strong>所发生的代价</li>
<li>C~0~表示<strong>返回一篇不相关文档</strong>所发生的代价</li>
<li>PRP认为，如果对于一篇特定的文档d及其所有其他未返回的文档d’都满足：</li>
<li>$C_0\cdot P(R=1|d)-C_1\cdot P(R=0|d) \le C_0\cdot P(R=1|d’)-C_1\cdot P(R=0|d’)$<ul>
<li>$C_0\cdot P(R=1|d)$：当d不相关时却返回的代价（判为相关）</li>
<li>$C_1\cdot P(R=0|d)$：当d相关却没有返回的代价</li>
<li>两者相减表示返回文档d的<strong>代价函数</strong>，即此时前者越低越好，后者越高越好</li>
</ul>
</li>
<li>那么d就应该是下一篇被返回的文档</li>
</ul>
<h4 id="二值独立概率模型BIM"><a href="#二值独立概率模型BIM" class="headerlink" title="二值独立概率模型BIM"></a>二值独立概率模型BIM</h4><ul>
<li>为了对概率函数P(R|q,d)进行估计，引入了一些简单假设。<ul>
<li>”二值“等价于布尔值：文档和查询都表示为<strong><u>词项出现与否的布尔向量</u></strong></li>
<li>类似，查询q表示成词项出现向量q</li>
<li>”独立性“指的式词项在文档中的出现是相互独立的，BIM不识别词项之间的关联。</li>
</ul>
</li>
</ul>
<h4 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h4><ul>
<li>在减少出现事件的概率估计值的同时提高未出现事件的概率估计值的方法</li>
</ul>
<h4 id="BIM模型的优缺点"><a href="#BIM模型的优缺点" class="headerlink" title="BIM模型的优缺点"></a>BIM模型的优缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>BIM模型建立在数学基础上，理论性较强</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>需要估计参数</li>
<li>原始BIM没有考虑TF、文档长度因素</li>
<li>BIM中同样存在词项独立性假设</li>
</ul>
<h4 id="理论上的概率估计方法"><a href="#理论上的概率估计方法" class="headerlink" title="理论上的概率估计方法"></a>理论上的概率估计方法</h4><ul>
<li>P~t~词项出现在一篇相关文档中的概率</li>
<li>$p_t = P(x_t=1|R=1,q) = s/S$</li>
<li>u~t~词项出现在一片不相关文档中的概率</li>
<li>$u_t=P(x_t=1|R=0, q)= (df_t-s)/(N-S)$</li>
</ul>
<h2 id="基于语言建模的检索模型"><a href="#基于语言建模的检索模型" class="headerlink" title="基于语言建模的检索模型"></a>基于语言建模的检索模型</h2><ul>
<li>传统概率模型<ul>
<li>需要对文档d与查询q的相关概率$P(R=1|q,d)$进行显示建模</li>
</ul>
</li>
<li>概率语言模型<ul>
<li>首先对每篇文档d建模得到文档的<strong>概率语言模型 $M_d$</strong></li>
<li>然后按照<strong>模型生成查询q</strong>的概率$P(q|M_d)$的高低来对文档进行排序</li>
</ul>
</li>
</ul>
<h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><h4 id="最简单的语言生成器模型"><a href="#最简单的语言生成器模型" class="headerlink" title="最简单的语言生成器模型"></a>最简单的语言生成器模型</h4><ul>
<li>一个简单的又穷自动机及其生成语言中的一些字符串<ul>
<li>$\rightarrow$指向的是自动机的初始状态</li>
<li>双圈节点对应的是终止状态</li>
</ul>
</li>
<li>如果每一个节点都有一个生成不同词项的概率分布，便得到一个语言模型，或概率语言模型，或统计语言模型<ul>
<li>语言模型的概念本质上是基于概率的</li>
</ul>
</li>
</ul>
<h4 id="有穷自动机-rightarrow-语言模型"><a href="#有穷自动机-rightarrow-语言模型" class="headerlink" title="有穷自动机$\rightarrow$语言模型"></a>有穷自动机$\rightarrow$语言模型</h4><ul>
<li>一个语言模型（LM）是从某词汇表上抽取的<strong>字符串概率的一个映射函数</strong>。对字母表$\sum$上的语言模型M有：$\sum_{s\in \sum^*}P(s)=1$</li>
<li>最简单的语言模型等价于一个仅仅包含一个节点的概率有穷自动机，只有一个生成不同词项的概率分布，因此有$\sum_{t\in V}P(t)=1$</li>
<li>假定停止概率是固定的，因此不会影响文档的排序。因此可以不考虑停止概率，但形式上得到的结果将不再是概率，而只是概率的部分项</li>
</ul>
<h4 id="语言模型的比较"><a href="#语言模型的比较" class="headerlink" title="语言模型的比较"></a>语言模型的比较</h4><ul>
<li>比较两个模型，可计算似然比，即将其中一个模型的数据生成概率除以另外一个模型数据的生成概率。</li>
</ul>
<h3 id="语言模型的种类"><a href="#语言模型的种类" class="headerlink" title="语言模型的种类"></a>语言模型的种类</h3><h4 id="对于词项序列如何求解其生成的概率值"><a href="#对于词项序列如何求解其生成的概率值" class="headerlink" title="对于词项序列如何求解其生成的概率值"></a>对于词项序列如何求解其生成的概率值</h4><ul>
<li>根据链式规则将一系列事件的概率分解成多个连续事件概率之积，每个概率是每个事件基于其历史事件的条件概率。</li>
<li>$P(t_1t_2t_3t_4)=P(t_1)P(t_2|t_1)P(t3|t_1t_2)P(t_4|t_1t_2t_3)$</li>
</ul>
<h4 id="语言模型的种类n-gram"><a href="#语言模型的种类n-gram" class="headerlink" title="语言模型的种类n-gram"></a>语言模型的种类n-gram</h4><ul>
<li><p>一元语言模型（Unigram LM）：上下文语言无关模型，是最简单的语言模型，去掉所有条件概率中的条件来独立地估计每个词项的概率</p>
<ul>
<li>$P_{uni}(t_1t_2t_3t_4) = P(t_1)P(t_2)P(t_3)P(t_4)$</li>
<li>词袋模型Bag of words</li>
</ul>
</li>
<li><p>二元语言模型（Bigram LM）：即计算条件概率时只考虑前一个词项的出现情况</p>
<ul>
<li>$P_{bi}(t_1t_2t_3t_4) = P(t_1)P(t_2|t_1)P(t_3|t_2)P(t_4|t_3)$</li>
</ul>
</li>
<li><p>三元语言模型（Trigram LM）</p>
</li>
</ul>
<h4 id="词的多项式分布"><a href="#词的多项式分布" class="headerlink" title="词的多项式分布"></a>词的多项式分布</h4><ul>
<li>词的多项式分布</li>
</ul>
<h3 id="语言模型应用到IR"><a href="#语言模型应用到IR" class="headerlink" title="语言模型应用到IR"></a>语言模型应用到IR</h3><h4 id="总体分布-amp-抽样"><a href="#总体分布-amp-抽样" class="headerlink" title="总体分布&amp;抽样"></a>总体分布&amp;抽样</h4><ul>
<li>文档模型实际是某种<strong>总体分布</strong></li>
<li>文档和查询都是该总体分布下的一个<strong>抽样样本示例</strong></li>
<li>根据文档，估计文档的模型，即求出该总体分布，然后计算该总体分布下抽样出查询的概率</li>
<li>文档 $\rightarrow$ 总体分布 $\rightarrow$ 查询</li>
</ul>
<h4 id="查询似然模型"><a href="#查询似然模型" class="headerlink" title="查询似然模型"></a>查询似然模型</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>将文档按照其余查询相关的似然$P(d|q)$排序<ul>
<li>$P(d|q)=P(d|q)\frac{P(d)}{P(q)}$</li>
</ul>
</li>
<li><p>最后会按照$P(d|q)$进行排序，它是在<strong>文档d对应的语言模型$M_d$下生成q的概率</strong></p>
</li>
<li><p>IR中的语言建模方法实际上是在<strong>对查询的过程</strong>进行建模</p>
<ul>
<li>首先每篇文档d对应一个文档模型$M_d$</li>
<li>然后计算查询被视为每个文档模型的随机抽样样本的概率</li>
<li>最后根据这些概率对文档排序<ul>
<li>$P(q|M_d) = K<em>q \prod</em>{t\in V}P(t|M<em>d)^{tf</em>{t,d}}$</li>
<li>$K_q$是查询q的多项式系数，对于某个特定查询，是一个常数可以忽略。</li>
</ul>
</li>
</ul>
</li>
<li>模型的直观意义是，用户脑子里有一篇原型文档，然后按照该文档中的词语用法来生成查询。</li>
</ul>
<h4 id="查询生成的概率估计"><a href="#查询生成的概率估计" class="headerlink" title="查询生成的概率估计"></a>查询生成的概率估计</h4><ul>
<li>每篇文档d构建其对应的语言模型$M_d$</li>
<li>采用最大似然估计：使得观察样本出现概率最大的估计<ul>
<li>$P(q|M<em>d)=\prod</em>{t\in q}P_{mle}(t|M<em>d)=\frac{tf</em>{t,d}}{L_d}$</li>
<li>$L_d$是d中的词条数目</li>
</ul>
</li>
</ul>
<h4 id="线性插值LM示例"><a href="#线性插值LM示例" class="headerlink" title="线性插值LM示例"></a>线性插值LM示例</h4><h4 id="平滑的方法：线性插值LM"><a href="#平滑的方法：线性插值LM" class="headerlink" title="平滑的方法：线性插值LM"></a>平滑的方法：线性插值LM</h4><ul>
<li><p>需要对文档LM的概率进行平滑（Smoothing），即对出现事件的概率结果进行折扣，并对未出现的词的概率赋予一定的值。</p>
</li>
<li><p>将基于<strong>文档的多项式</strong>分布和基于全部<strong>文档集</strong>估计出的多项式分布相混合</p>
</li>
<li>$P(t|d)= \lambda P_{mle}(t|M<em>d)+(1-\lambda)P</em>{mle}(t|M_c)$<ul>
<li>$\lambda \in (0,1)$ , $M_c$是基于全部文档集构造的LM</li>
</ul>
</li>
</ul>
<h4 id="扩展的LM方法"><a href="#扩展的LM方法" class="headerlink" title="扩展的LM方法"></a>扩展的LM方法</h4><ul>
<li>a查询似然类：文档建模，计算查询的似然<ul>
<li>基本QLM模型、翻译模型</li>
</ul>
</li>
<li>b文档似然类：查询建模，计算文档的似然<ul>
<li>BIM模型、相关性模型</li>
</ul>
</li>
<li>c模型比较类：文档建模，查询建模，kl距离模型</li>
</ul>
<h2 id="文本分类及朴素贝叶斯分类器"><a href="#文本分类及朴素贝叶斯分类器" class="headerlink" title="文本分类及朴素贝叶斯分类器"></a>文本分类及朴素贝叶斯分类器</h2><h3 id="本讲要点"><a href="#本讲要点" class="headerlink" title="本讲要点"></a>本讲要点</h3><ul>
<li>什么是文本分类</li>
<li>什么是朴素贝叶斯分类器</li>
<li>朴素贝叶斯分类器的生成模型</li>
<li>朴素贝叶斯分类器的性质<ul>
<li>条件独立假设&amp;位置独立性假设</li>
</ul>
</li>
<li>特征选择：互信息、x2统计量、词项频率</li>
<li>文本分类评价：宏平均和微平均</li>
</ul>
<h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><ul>
<li>给定分类体系，将一篇文本分到其中一个或者多个类别中的过程。</li>
</ul>
<ul>
<li>文本分类中，给定文档$d \in X$ 和一个固定的类别集合 $C={C_1,C_2,…,C_j}$ , 其中X表式文档空间，类别也通常称为类或类标签<ul>
<li>按类别书目：binary vs multi-class</li>
<li>按每篇文档赋予的标签书目： sing label vs multi label</li>
</ul>
</li>
</ul>
<h4 id="分类方法1：-手工方法"><a href="#分类方法1：-手工方法" class="headerlink" title="分类方法1： 手工方法"></a>分类方法1： 手工方法</h4><ul>
<li>使用人工分类方法来分类，如果专家来分类精度会非常高</li>
<li>如果问题规模和分类团队都很小时，能否保持分类结果的一致性</li>
</ul>
<h4 id="分类方法2：规则方法"><a href="#分类方法2：规则方法" class="headerlink" title="分类方法2：规则方法"></a>分类方法2：规则方法</h4><ul>
<li>繁琐，开销大</li>
</ul>
<h4 id="分类方法3：机器学习方法"><a href="#分类方法3：机器学习方法" class="headerlink" title="分类方法3：机器学习方法"></a>分类方法3：机器学习方法</h4><ul>
<li>文本分类被定义为一个学习问题，包括：<ul>
<li>通过有监督的学习，得到分类函数$\gamma$，然后将其应用于对新文档的分类</li>
</ul>
</li>
<li>一系列的分类方法：朴素贝叶斯、Rocchio、KNN、SVM</li>
<li>当学习方法基于统计时，此方法也称为统计文本分类：<ul>
<li>在统计文本分类中，对每个类别需要一些好的文档样例（训练文档）</li>
<li>需要人来标注训练文档，所以对人工分类的需求依然存在</li>
<li>标注（labeling）指对每篇文档赋予类别标签的过程</li>
</ul>
</li>
</ul>
<h4 id="基于学习的文本分类"><a href="#基于学习的文本分类" class="headerlink" title="基于学习的文本分类"></a>基于学习的文本分类</h4><ul>
<li>文档空间X<ul>
<li>文档都在该空间下表示—— 通常都是某种高维空间</li>
</ul>
</li>
<li>固定的类别集合$C={C_1,C_2,…,C_j}$<ul>
<li>类别往往根据应用的需求来人为定义</li>
</ul>
</li>
<li>训练集D，文档d用c来标记，$<d,c> \in X \times C$<ul>
<li>利用学习算法，可以学习一个分类器$\gamma$，它可以将文档映射成类别： $\gamma：X\rightarrow C$</li>
</ul>
</d,c></li>
<li>文档分类的实现<ul>
<li>对于文档空间中文档，$d \in X $,可确定$γ(d) \in C $即确定d最可能属于的类别$c_i = γ(d),c \in C$</li>
</ul>
</li>
</ul>
<h4 id="无监督-有监督的学习"><a href="#无监督-有监督的学习" class="headerlink" title="无监督/有监督的学习"></a>无监督/有监督的学习</h4><ul>
<li>supervised learning 监督学习<ul>
<li>利用一组<strong><u>已知类别的样本</u></strong>调整分类器的参数，使其达到所求性能的过程，也称为监督训练或有教师学习</li>
</ul>
</li>
<li>无监督学习<ul>
<li>若所给的学习样本<strong><em>不带有类别信息</em></strong>，就是无监督学习</li>
</ul>
</li>
</ul>
<h4 id="搜索引擎中的文本分类应用"><a href="#搜索引擎中的文本分类应用" class="headerlink" title="搜索引擎中的文本分类应用"></a>搜索引擎中的文本分类应用</h4><ul>
<li>语言识别</li>
<li>垃圾网页识别</li>
<li>是否包含淫秽内容</li>
<li>领域搜索或垂直搜索—— 搜索对象限制在某个垂直领域</li>
<li>静态查询</li>
<li>情感识别</li>
</ul>
<h4 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h4><ul>
<li>是一个概率分类器</li>
<li>文档d属于类别c的概率计算</li>
<li>$P(c|d)=\frac{P(c)P(d|c)}{P(d)} ∞ P(c)P(d|c)∞P(c)\prod_{1\le K \le n_d}{P(t_k|c)}$</li>
<li>t~k~是d中的词条，n~d~是文档的长度（词条个数）</li>
<li>P(t~k~|c)是此项t~k~出现在类别c中文档的概率，或类别c生成词项t~k~的概率，或是度量的是当c是正确类别时t~k~的贡献</li>
<li>P(c)是类别c的先验概率</li>
<li>如果文档的词项无法提供属于哪个类别的信息，那么直接选择P(c)最高的那个类别</li>
</ul>
<h3 id="朴素贝叶斯理论"><a href="#朴素贝叶斯理论" class="headerlink" title="朴素贝叶斯理论"></a>朴素贝叶斯理论</h3><h4 id="两种模型文本生成过程"><a href="#两种模型文本生成过程" class="headerlink" title="两种模型文本生成过程"></a>两种模型文本生成过程</h4><ul>
<li>给定类别时文档生成的条件概率计算有所不同<ul>
<li>多项式模型$P(d|c)=P(<t_1, …="" ,="" t_k,="" …,="" t_{nd}="">|c)$</t_1,></li>
<li>贝努利模型$P(d|c)=P(<e_1, …="" ,="" e_k,="" …,="" e_m="">|c)$</e_1,></li>
<li>其中 多项式模型是d中出现的词项序列（去掉词）</li>
<li>贝努利模型是一个M维的布尔向量，表示每个词项在文档d中存在与否。</li>
</ul>
</li>
<li>两种不同的文档表示方法<ul>
<li>多项式模型是文档空间X是所有词项序列的集合</li>
<li>贝努利模型是文档空间X是${0,1}^M$</li>
</ul>
</li>
</ul>
<h4 id="具有最大后验概率的类别"><a href="#具有最大后验概率的类别" class="headerlink" title="具有最大后验概率的类别"></a>具有最大后验概率的类别</h4><ul>
<li>朴素贝叶斯分类的目标是寻找“最佳”类别</li>
</ul>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ul>
<li>文本分类中，通常要将文本表示在一个<strong>高维空间</strong>下，<strong>每一维对应一个词项</strong>。特征选择是从训练集合出现的词项中选出一部分子集的过程。在文本分类过程也仅仅使用这个子集作为特征</li>
<li>特征选择有两个主要目的：<ol>
<li>通过减少有效的词汇空间来提高分类器训练和应用的效率。这对除NB之外的其他训练开销较大的分类器来说尤为重要。</li>
<li>特征选择能够去除噪音特征，从而提高分类的精度。</li>
</ol>
</li>
<li><strong>噪音特征</strong>：加入文本表示之后反而会增加新数据上的分类错误率的特征</li>
<li>由于训练集的偶然性导出的不正确的泛化结果称为<strong>过学习</strong></li>
</ul>
<h4 id="特征选择算法"><a href="#特征选择算法" class="headerlink" title="特征选择算法"></a>特征选择算法</h4><ul>
<li>给定类别c，对词汇表中的每个词项t，计算<strong>效用指标A(t,c)</strong>，然后从中选择k个具有最高值的词项作为最后的特征。</li>
</ul>
<h4 id="不同的特征选择方法"><a href="#不同的特征选择方法" class="headerlink" title="不同的特征选择方法"></a>不同的特征选择方法</h4><ul>
<li>特征选择方法主要基于其所使用特征效用指标来定义</li>
<li>特征效用指标<ul>
<li>频率法—— 选择高频词项</li>
<li>互信息—— 选择具有最高互信息的那些词项</li>
<li>卡方x^2^ </li>
</ul>
</li>
</ul>
<h3 id="分类评价"><a href="#分类评价" class="headerlink" title="分类评价"></a>分类评价</h3><ul>
<li>评价必须基于测试数据进行，而且该测试数据与训练数据完全独立。</li>
<li>很容易通过训练可以子训练集上达到很高的性能</li>
<li>常用指标：正确率、召回率、F~1~值、分类精确率等等</li>
<li>宏平均：在类别之间求平均值  微平均：将每篇文档在每个类别上的判定放入一个缓冲池，然后基于这个缓冲池计算效果指标。</li>
</ul>
<h4 id="宏平均"><a href="#宏平均" class="headerlink" title="宏平均"></a>宏平均</h4><ul>
<li>对类别集合C中的每个类都计算一个F~1~值</li>
<li>对C个结果求平均</li>
</ul>
<h4 id="微平均"><a href="#微平均" class="headerlink" title="微平均"></a>微平均</h4><ul>
<li>对类别集合C中的每个类都计算TP、FP和FN</li>
<li>将C中的这些数字累加</li>
<li>基于累加的TP、FP、FN计算P、R和F~1~</li>
</ul>
<h4 id="宏平均和微平均的适用范围"><a href="#宏平均和微平均的适用范围" class="headerlink" title="宏平均和微平均的适用范围"></a>宏平均和微平均的适用范围</h4><ul>
<li>宏平均和微平均的计算结果可能会相差很大。宏平均对每个类等同对待，而微平均则对每篇文档的判定结果等同对待</li>
<li>由于F1值忽略判断正确的负例，所以它的大小主要由判断正确的正例数目所决定，所以在微平均计算中大类起支配作用。</li>
</ul>
<h2 id="基于向量空间模型的文本分类"><a href="#基于向量空间模型的文本分类" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><ul>
<li>Rocchio方法<ul>
<li>基于质心或原型将整个向量空间划分成多个区域</li>
</ul>
</li>
<li>kNN方法<ul>
<li>将K个最邻近文档所属的主类别赋给测试文档</li>
</ul>
</li>
<li>线性分类器<ul>
<li>指基于特征的简单<strong>线性组合</strong>就可以对文档进行分类的分类器</li>
</ul>
</li>
</ul>
<h3 id="基于向量空间的分类方法"><a href="#基于向量空间的分类方法" class="headerlink" title="基于向量空间的分类方法"></a>基于向量空间的分类方法</h3><h4 id="向量空间表示"><a href="#向量空间表示" class="headerlink" title="向量空间表示"></a>向量空间表示</h4><ul>
<li>每个文档表示成一个<strong>向量</strong>，向量的每一维表示一个<strong>term</strong></li>
<li>向量可以归一化成单位长度</li>
<li>高维向量空间<ul>
<li>维度非常高</li>
<li>每个term就是一个坐标轴</li>
<li>文档表示为空间的向量</li>
</ul>
</li>
</ul>
<h4 id="向量空间模型-2"><a href="#向量空间模型-2" class="headerlink" title="向量空间模型"></a>向量空间模型</h4><ul>
<li>词项——文档矩阵：二值—&gt; 计数 —&gt; 权重矩阵（tf-idf）</li>
<li><p>相关性 = 向量距离 ： 欧式距离—&gt; 夹角 —&gt; 余弦相似度</p>
</li>
<li><p>利用向量空间模型进行文本分类的思路主要基于<strong>邻近假设</strong>：</p>
<ol>
<li>同一类的文档会构成一个邻近区域</li>
<li>不同类的邻近区域之间互不重叠</li>
</ol>
</li>
<li>如何找到<strong>分类面决策边界</strong>（decision boundary）</li>
</ul>
<h3 id="Rocchio方法"><a href="#Rocchio方法" class="headerlink" title="Rocchio方法"></a>Rocchio方法</h3><h4 id="Rocchio方法进行向量空间分类的思路"><a href="#Rocchio方法进行向量空间分类的思路" class="headerlink" title="Rocchio方法进行向量空间分类的思路"></a>Rocchio方法进行向量空间分类的思路</h4><ul>
<li>利用<strong>质心</strong>来定义分类边界</li>
<li>一个<strong>类别c的质心</strong>可以通过类中文档向量的平均向量或者质心想来来计算</li>
<li>计算公式：</li>
</ul>
<h4 id="Rocchio算法-1"><a href="#Rocchio算法-1" class="headerlink" title="Rocchio算法"></a>Rocchio算法</h4><ul>
<li>计算每个类的中心向量（所有文档向量的算术平均）</li>
<li>将每篇测试文档分到离它最近的那个中心向量</li>
</ul>
<h4 id="Rocchio算法中的决策边界"><a href="#Rocchio算法中的决策边界" class="headerlink" title="Rocchio算法中的决策边界"></a>Rocchio算法中的决策边界</h4><ul>
<li>利用质心来定义分类边界</li>
<li>两类的边界由那些<strong>到两个类质心等距的点集组成</strong>（超平面）</li>
</ul>
<h4 id="Rocchio分类方法的缺陷"><a href="#Rocchio分类方法的缺陷" class="headerlink" title="Rocchio分类方法的缺陷"></a>Rocchio分类方法的缺陷</h4><ul>
<li>为了遵循邻近性的要求，Rocchio 分类中的每个类别一定要近似球形，并且它们之间具有相似球半径。</li>
</ul>
<h3 id="KNN邻近方法"><a href="#KNN邻近方法" class="headerlink" title="KNN邻近方法"></a>KNN邻近方法</h3><h4 id="kNN（k邻近）方法"><a href="#kNN（k邻近）方法" class="headerlink" title="kNN（k邻近）方法"></a>kNN（k邻近）方法</h4><ul>
<li>kNN = k nearnest neighbors， k邻接</li>
<li>k = 1情况下的kNN：将每篇测试文档分给训练集中离它最近的那篇文档所属的类别。</li>
<li>1NN不很鲁棒 —— 一篇文档可能会分错类或者这篇文档本身就返常</li>
<li>k&gt;1情况下的kNN：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>kNN的基本依据<ul>
<li>根据邻近假设，一篇测试文档d将和其邻域中的训练文档应该具有相同的类别。</li>
</ul>
</li>
</ul>
<h4 id="1NN分类器"><a href="#1NN分类器" class="headerlink" title="1NN分类器"></a>1NN分类器</h4><ul>
<li>1NN分类器的判别边界是<strong>Voronoi剖分</strong>形成的多个线段的连接。Voronoi剖分会将整个平面分成|D|个凸多边形，每个多边形仅包含其对应的文档，而每个凸多边形是在二维空间种通过直线围成的凸区域。</li>
</ul>
<h4 id="小结：KNN方法"><a href="#小结：KNN方法" class="headerlink" title="小结：KNN方法"></a>小结：KNN方法</h4><ul>
<li>思路：将每篇测试文档分到训练集中离它最近的k篇文档所属类别中最多的那个类别</li>
<li>KNN的基本依据：根据邻近假设，一篇测试文档d将和其领域中的训练文档应该具有相同的类别<ul>
<li>当训练集非常大的时候，KNN分类精度很高</li>
<li>当训练集非常小的时候，KNN效果很差</li>
</ul>
</li>
</ul>
<h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><ul>
<li>定义</li>
</ul>
<h2 id="基于向量空间模型的文本分类-1"><a href="#基于向量空间模型的文本分类-1" class="headerlink" title="基于向量空间模型的文本分类"></a>基于向量空间模型的文本分类</h2><h3 id="二元线性SVM"><a href="#二元线性SVM" class="headerlink" title="二元线性SVM"></a>二元线性SVM</h3><ul>
<li>SVM是最大间隔分类器的一种，它是局域向量空间的机器学习方法，其目标是找到两个类别之间的一个决策边界，使之尽量远离训练集上的任意一点。</li>
<li>SVM定义的准则是<strong><u>寻找一个离数据点最远的决策面</u></strong>。从决策面到最近数据点的距离决定了<strong>分类器的间隔</strong></li>
</ul>
<h4 id="小结：SVM要点"><a href="#小结：SVM要点" class="headerlink" title="小结：SVM要点"></a>小结：SVM要点</h4><ul>
<li>线性SVM的结果分类器为：</li>
<li>SVM基本过程：<ul>
<li>基于给定训练数据集，通过二次优化过程寻找最佳的分类超平面</li>
<li>对于待分类的新数据点，利用分类函数计算该点到超平面的距离</li>
<li>距离的正负（分类函数的符号）决定了该数据点类别的归属</li>
<li>如果该点在分类器的间隔之内，分了器可以在原来的两个类之外，返回“类别未知”</li>
</ul>
</li>
<li>​</li>
</ul>
<h2 id="文本聚类"><a href="#文本聚类" class="headerlink" title="文本聚类"></a>文本聚类</h2><h3 id="聚类介绍"><a href="#聚类介绍" class="headerlink" title="聚类介绍"></a>聚类介绍</h3><h4 id="聚类的定义"><a href="#聚类的定义" class="headerlink" title="聚类的定义"></a>聚类的定义</h4><ul>
<li>文档聚类是将一系列文档按照相似性聚团成子集或者簇的过程</li>
<li>簇内文档之间应该彼此相似，相似度不大</li>
<li>聚类是一种最常见的无监督学习方法<ul>
<li>无监督学习意味着没有已标注好的数据集</li>
</ul>
</li>
</ul>
<h4 id="分类VS聚类"><a href="#分类VS聚类" class="headerlink" title="分类VS聚类"></a>分类VS聚类</h4><ul>
<li>分类：有监督的学习</li>
<li>聚类：无监督的学习</li>
<li>分类：类别事先人工定义好，并且是学习算法的输入的一部分</li>
<li>聚类：簇在没有人工输入的情况下从数据中推理而得<ul>
<li>但是很多因素会影响聚类的输出结果：簇的个数、相似度计算方法、文档的表示方式等。</li>
</ul>
</li>
</ul>
<h3 id="聚类在IR中的应用"><a href="#聚类在IR中的应用" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h3><h4 id="聚类假设"><a href="#聚类假设" class="headerlink" title="聚类假设"></a>聚类假设</h4><ul>
<li>在考虑文档和信息需求之间的相关性式，同一簇中的文档表现互相类似。</li>
<li>聚类在IR中的应用所有应用都直接或间接基于上述聚类假设</li>
</ul>
<h4 id="聚类在IR中的应用-1"><a href="#聚类在IR中的应用-1" class="headerlink" title="聚类在IR中的应用"></a>聚类在IR中的应用</h4><table>
<thead>
<tr>
<th>应用</th>
<th>聚类对象</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>搜索结果聚类</td>
<td>搜索结果</td>
<td>提供面向用户的更有效的展示</td>
</tr>
<tr>
<td>“分散-集中”界面</td>
<td>文档集和文档子集</td>
<td>提供了另一种用户界面，即不需要人工输入关键词的搜索界面</td>
</tr>
<tr>
<td>文档聚类</td>
<td>文档集</td>
<td>提供了一种面向探索式浏览的有效性的信息展示法</td>
</tr>
<tr>
<td>基于语言建模的IR文档集</td>
<td>文档集</td>
<td>提高了正确率和/或召回率</td>
</tr>
<tr>
<td>基于聚类的检索</td>
<td>文档集</td>
<td>加快了搜索的速度</td>
</tr>
</tbody>
</table>
<h4 id="文档聚类用于提高召回率"><a href="#文档聚类用于提高召回率" class="headerlink" title="文档聚类用于提高召回率"></a>文档聚类用于提高召回率</h4><ul>
<li>实现将文档集中的文档进行聚类</li>
<li>当文档和查询匹配时，也返回包含d的簇所包含的其它文档</li>
<li>我们希望通过上述做法，在输入查询“car”时，也能包含“automobile”的文档</li>
<li>由于聚类算法会把包含“car”的文档和包含“automobile”的文档聚在一起</li>
</ul>
<h4 id="聚类的要求"><a href="#聚类的要求" class="headerlink" title="聚类的要求"></a>聚类的要求</h4><ul>
<li>一般目标： 将相关文档放到一个簇中，将不相关文档放到不同的簇中</li>
<li>簇的数目应该合适，以便于聚类的数据集吻合<ul>
<li>一开始，假设给定簇的数目为K</li>
<li>后面介绍K的半自动的方法</li>
</ul>
</li>
<li>其它目标：<ul>
<li>避免非常小和非常大的簇</li>
<li>定义的簇对用户来说很容易理解</li>
<li>其它……</li>
</ul>
</li>
</ul>
<h4 id="扁平聚类vs层次聚类"><a href="#扁平聚类vs层次聚类" class="headerlink" title="扁平聚类vs层次聚类"></a>扁平聚类vs层次聚类</h4><ul>
<li><p>扁平算法：</p>
<ul>
<li>通过一开始将全部或部分文档随机划分为不同的组</li>
<li>通过迭代不断修正</li>
<li>代表算法： K-均值聚类算法</li>
</ul>
</li>
<li><p>层次算法：</p>
<ul>
<li>构建具有层次结果的簇</li>
<li>自底向上（Bottom-up）的算法称为凝聚式算法</li>
<li>自顶向下的（Top-down）算法称为分裂式算法</li>
</ul>
</li>
</ul>
<h4 id="硬聚类vs软聚类"><a href="#硬聚类vs软聚类" class="headerlink" title="硬聚类vs软聚类"></a>硬聚类vs软聚类</h4><ul>
<li>硬聚类：每篇文档仅仅属于一个簇<ul>
<li>很普遍并且相对容易实现</li>
</ul>
</li>
<li>软聚类：一篇文档可以属于多个簇</li>
</ul>
<h4 id="扁平算法"><a href="#扁平算法" class="headerlink" title="扁平算法"></a>扁平算法</h4><ul>
<li>扁平算法将N篇文档划分成K个簇</li>
<li>给定一个文档集合及聚类结果簇的个数K</li>
<li><strong>寻找一个划分将这个文档集合分成K个簇，该结果满足最优划分规则</strong></li>
<li>全局优化：穷举所有的结果划分，从中选择最优的那个划分结果(无法处理)</li>
<li>高效的启发式方法：k-均值聚类算法</li>
</ul>
<h3 id="K-均值聚类算法"><a href="#K-均值聚类算法" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h3><p>最著名的聚类算法，算法十分简单，但是在很多情况下效果不错</p>
<h4 id="聚类中的文档表示"><a href="#聚类中的文档表示" class="headerlink" title="聚类中的文档表示"></a>聚类中的文档表示</h4><ul>
<li>向量空间模型</li>
<li>欧式距离计算向量之间的相关性</li>
</ul>
<h4 id="K-均值聚类算法-1"><a href="#K-均值聚类算法-1" class="headerlink" title="K-均值聚类算法"></a>K-均值聚类算法</h4><ul>
<li>K-均值聚类算法中的每个簇都定义为其质心向量</li>
<li>划分准则：<strong>使得所有文档到其所在簇的质心向量的平方和最小</strong></li>
<li>质心向量的定义：</li>
<li>通过下列两部来实现目标优化：<ol>
<li>重分配：将每篇文档分配给离它最近的簇</li>
<li>重计算：重新计算每个簇的质心向量</li>
</ol>
</li>
</ul>
<h4 id="K-均值聚类算法一定会收敛"><a href="#K-均值聚类算法一定会收敛" class="headerlink" title="K-均值聚类算法一定会收敛"></a>K-均值聚类算法一定会收敛</h4><ul>
<li>RSS（Residual Sum of Squares）残差平方和 = 所有簇上的文档向量到质心向量的距离的平方和的总和</li>
<li>每次重新分配之后RSS会下降<ul>
<li>因为每个向量都被移到离它最近的质心向量所代表的簇中</li>
</ul>
</li>
<li>每次重新计算之后RSS也会下降</li>
<li>可能的聚类结果是有穷的，因此一定会收敛到一个固定点</li>
<li>如果出现了等值的情况，算法都采用前后一致的方法来处理</li>
<li>如果不关心少许文档在不同簇之间来回交叉的话，收敛速度通常会很快。但是完全收敛需要很庞大的迭代过程</li>
</ul>
<h4 id="K-均值聚类算法的最优性"><a href="#K-均值聚类算法的最优性" class="headerlink" title="K-均值聚类算法的最优性"></a>K-均值聚类算法的最优性</h4><ul>
<li>收敛并不意味着会达到<strong>全局最优</strong>的聚类结果，这是K-均值聚类算法最大缺点之一。如果开始的种子选择不好，最终的聚类结果可能会非常糟糕。</li>
</ul>
<h4 id="K-均值聚类算法的初始化"><a href="#K-均值聚类算法的初始化" class="headerlink" title="K-均值聚类算法的初始化"></a>K-均值聚类算法的初始化</h4><ul>
<li>种子的随机选择只是K-均值聚类算法的中初始化方法之一</li>
<li>随机选择不太鲁棒：可能会获得一个次优的聚类结果</li>
<li>更好的办法：<ul>
<li>非随机地采用某些启发式方法来选择种子（比如，过滤掉一些离群点，或则寻找具有较好文档空间覆盖度的种子集合）</li>
<li>采用层级聚类算法寻找好的种子</li>
<li>选择$i$次不同的随机种子集合，对每次产生的随机种子集合运行<strong><em>K</em></strong>-均值聚类算法，最后选择具有最小RSS的聚类结果。</li>
</ul>
</li>
</ul>
<h4 id="K-均值聚类算法的时间复杂度"><a href="#K-均值聚类算法的时间复杂度" class="headerlink" title="K-均值聚类算法的时间复杂度"></a>K-均值聚类算法的时间复杂度</h4><p>O(<em>IKNM</em>)-线性</p>
<h3 id="聚类评价"><a href="#聚类评价" class="headerlink" title="聚类评价"></a>聚类评价</h3><h4 id="内部准则"><a href="#内部准则" class="headerlink" title="内部准则"></a>内部准则</h4><p>一个内部准则的例子：K-均值聚类算法的$RSS$值。</p>
<p>但是内部准则往往不能评价聚类在应用中的实际效用</p>
<h4 id="外部准则"><a href="#外部准则" class="headerlink" title="外部准则"></a>外部准则</h4><ul>
<li>按照用户定义的<strong>分类</strong>结果来评价，即对一个分好类的数据集进行聚类，将聚类结果和事先的类别情况进行比照，得到最后的评价结果。</li>
<li>目标：<strong>聚类结果和给定分类结果一致</strong></li>
</ul>
<h4 id="纯度"><a href="#纯度" class="headerlink" title="纯度"></a>纯度</h4><ul>
<li>对每个簇，找到类别$c_j$，该类别包含$w<em>k$中的元素最多，为$n</em>{kj}$个，也就是说$w_k$的元素最多分布在$c_j$中</li>
<li>将所有n_{kj}求和，然后除以所有的文档数目N</li>
</ul>
<h3 id="簇个数确定"><a href="#簇个数确定" class="headerlink" title="簇个数确定"></a>簇个数确定</h3><ul>
<li>基本思路：<ul>
<li>从一个簇开始（K=1）</li>
<li>不断增加簇</li>
<li>对每个新的簇增加一个惩罚项</li>
</ul>
</li>
<li>在惩罚项和RSS之间折中，选择满足最佳折中条件的K</li>
<li>给定聚类结果，定义文档的代价为其到质心向量的距离(失真率)</li>
<li>定义全部失真率RSS(K)为所有文档代价和</li>
<li>对每个簇一个惩罚项$\lambda$ ，对于具有K个簇的聚类结果，总的聚类惩罚项为K$\lambda$。</li>
<li>定义聚类结果的所有开销为失真率和总聚类惩罚项的和：RSS(K)+K$\lambda$</li>
<li>选择使得(RSS(k)+Kℷ)最小的K值</li>
</ul>
<h4 id="本讲小结-1"><a href="#本讲小结-1" class="headerlink" title="本讲小结"></a>本讲小结</h4><ul>
<li>聚类的概念</li>
<li>聚类在IR中的应用</li>
<li>K-均值聚类算法</li>
<li>聚类评价</li>
<li>簇个数确定</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/Create-reverse-table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/01/Create-reverse-table/" itemprop="url">
                  Create reverse table
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T15:44:06+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="http://a280606790.iteye.com/blog/799347" target="_blank" rel="external">http://a280606790.iteye.com/blog/799347</a></p>
<p><a href="http://www.cnblogs.com/sephy/p/3303711.html" target="_blank" rel="external">http://www.cnblogs.com/sephy/p/3303711.html</a></p>
</blockquote>
<h2 id="Lucene包结构功能表"><a href="#Lucene包结构功能表" class="headerlink" title="Lucene包结构功能表"></a>Lucene包结构功能表</h2><table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.apache.lucene.analysis</td>
<td>语言分析器，主要用于的切词，支持中文主要是扩展此类</td>
</tr>
<tr>
<td>org.apache.lucene.document</td>
<td>索引存储时的文档结构管理，类似于关系型数据库的表结构</td>
</tr>
<tr>
<td>org.apache.lucene.index</td>
<td>索引管理，建立、删除等</td>
</tr>
<tr>
<td>org.apache.lucene.queryParser</td>
<td>查询分析器，查询关键词间的运算，与、或、非等</td>
</tr>
<tr>
<td>org.apache.lucene.search</td>
<td>检索管理，根据查询条件，检索得到结果</td>
</tr>
<tr>
<td>org.apache.lucene.util</td>
<td>公用类</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Analyzer是分析器，将字符串划分成一个个词语，去除其中的无效词语。英文的of,the，中文’的’，’地’等。</p>
</li>
<li><p>document用户提供的源，可以是文本文件、字符串或者数据库表的一条记录。一条记录经过索引后，就是以一个Document形式存储在索引文件中。用户进行搜索以Document列表形式返回</p>
</li>
<li><p>Field: 一个document可以包含多个信息域，标题、正文、最后修改时间，这些信息域通过Field在Document中存储。Field有两个属性可选：存储和索引。通过存储属性可以控制是否对该Field进行存储。</p>
</li>
<li><p>Term:搜索的最小单位，表示文档的一个词语。term由词语和这个词语出现的Field组成。</p>
</li>
<li><p>Tocken: term中的一次出现，包含term文本和相应的起止偏移，以及一个类型字符串。一句话可以出现多次相同的词语，它们用同一个term表示，但是用不同的tocken，每个tocken标记该词语出现的地方。</p>
</li>
<li><p>Segment: 添加索引时并不是每个document都马上添加到同一个索引文件，首先被写入不同的小文件，然后再合并成一个大索引文件，每一个小文件都是一个segment。</p>
<p>​</p>
</li>
</ul>
<h2 id="Lucene查询逻辑"><a href="#Lucene查询逻辑" class="headerlink" title="Lucene查询逻辑"></a>Lucene查询逻辑</h2><h3 id="影响Lucene对文档评分权重的方式"><a href="#影响Lucene对文档评分权重的方式" class="headerlink" title="影响Lucene对文档评分权重的方式"></a>影响Lucene对文档评分权重的方式</h3><p>如果希望某些文档和某些域比其他的域更重要，如果此文档和此域包含所要查询的词则应该得分较高，则可以在索引阶段设定文档的boost和域的boost值。默认值1.0，增加权重需要比1大才可以</p>
<p>Lucene文档的打分公式：<br>$$<br>score(q,d)=coord(q,d) \cdot queryNorm(q)\cdot \sum (tf(t\in d))\cdot idf(t)^3 \cdot t.getBoost()\cdot norm(t,d))<br>$$<br>通过修改对应域的boost的值来修改对应域的权重。</p>
<p>lucene的搜索相当强大，提供了很多辅助查询类，每个类都继承自Query类，各自完成特定的一种查询，可以组合使用完成特定的复杂操作；Lucene还提供Sort类对结果进行排序，还有Filter类对查询条件进行限制。各种查询方式可以在官网API中查看。</p>
<p>对于分词器，按照句子语义切分成一个个词语。对英文进行切词已经有完善的分词器StandardAnalyzer，很多情况下都可以使用。但是对中文分词并不友好，它会将中文词语单切，对每一个字符都分词。例如搜索”如果”，也会将”牛奶不如果汁好喝”搜索出来，并且因为对每一个字都分词，会造成词项很多，文件很大。所以选择使用Paoding分词，按词典词义进行分词。</p>
<p>执行查询的逻辑为：在已创建的索引目录中，创建一个搜索器。使用分词器对查询语句分词，设置搜索的域，利用生成的query去搜素，以Hits的形式返回。</p>
<p>查询例示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">searchIndex</span><span class="params">(String text)</span></span>&#123;</div><div class="line">     TokenStream stream = analyzer.tokenStream(<span class="string">"content"</span>,<span class="keyword">new</span> StringReader(text));</div><div class="line">     Date date1=<span class="keyword">new</span> Date();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">if</span>(showParticiple)</div><div class="line">             printTokens(<span class="string">" "</span>,stream);</div><div class="line">         System.out.println(<span class="string">"搜索 '"</span>+text+<span class="string">"' 结果如下"</span>);</div><div class="line">         <span class="comment">//1.打开存储位置</span></div><div class="line">             <span class="comment">//庖丁分词</span></div><div class="line">         analyzer = <span class="keyword">new</span> PaodingAnalyzer();</div><div class="line">         IndexReader ireader = IndexReader.open(INDEX_DIR);</div><div class="line">         <span class="comment">//2.创建搜索器</span></div><div class="line">         IndexSearcher isearcher = <span class="keyword">new</span> IndexSearcher(ireader);</div><div class="line">         <span class="comment">//3.进行关键词查询</span></div><div class="line">         QueryParser parser = <span class="keyword">new</span> QueryParser(<span class="string">"content"</span>,analyzer);</div><div class="line">       	<span class="comment">//进行多域查询，支持查询内容，时间，日期</span></div><div class="line">         String fields[] = &#123;<span class="string">"content"</span>,<span class="string">"filename"</span>,<span class="string">"editor"</span>,<span class="string">"date"</span>&#125;;</div><div class="line">         String texts[] =&#123;text,text,text,text&#125;;</div><div class="line">         Query query = MultiFieldQueryParser.parse(texts,fields,analyzer);</div><div class="line">         ScoreDoc[] hits=isearcher.search(query,<span class="keyword">null</span>,<span class="number">300</span>).scoreDocs;</div><div class="line">         <span class="keyword">if</span>(hits.length==<span class="number">0</span>)</div><div class="line">             System.out.println(<span class="string">"没有相似文件"</span>);</div><div class="line">         <span class="keyword">else</span> &#123;</div><div class="line">             System.out.println(<span class="string">"找到"</span>+hits.length+<span class="string">"个文件"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hits.length;i++)&#123;</div><div class="line">             Document hitDoc = isearcher.doc(hits[i].doc);</div><div class="line">             System.out.println(<span class="string">"_______________________"</span>);</div><div class="line">             System.out.println(hitDoc.get(<span class="string">"filename"</span>));</div><div class="line">             System.out.println(<span class="string">"时间: "</span>+hitDoc.get(<span class="string">"date"</span>));</div><div class="line">             System.out.println(<span class="string">"URL: "</span>+hitDoc.get(<span class="string">"url"</span>));</div><div class="line">             System.out.println(<span class="string">"Content:"</span>+hitDoc.get(<span class="string">"content"</span>));</div><div class="line">             System.out.println(<span class="string">"编辑: "</span>+hitDoc.get(<span class="string">"editor"</span>));</div><div class="line">             System.out.println(<span class="string">"Path:"</span>+hitDoc.get(<span class="string">"path"</span>));</div><div class="line">             System.out.println(<span class="string">"_______________________"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//4.关闭查询器等</span></div><div class="line">         ireader.close();</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">     &#125;</div><div class="line">     Date date2 = <span class="keyword">new</span> Date();</div><div class="line">     System.out.println(<span class="string">"查看索引-----耗时："</span>+(date2.getTime()-date1.getTime()+<span class="string">"ms\n"</span>));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="Lucene入库逻辑"><a href="#Lucene入库逻辑" class="headerlink" title="Lucene入库逻辑"></a>Lucene入库逻辑</h2><ol>
<li><p>入库这定义到库中文档的结构，如需要把网站内容加载到全文检索库，让用户通过“站内检索“搜索到相关的网页的内容。入库文档结构和关系型数据库中的表结构类似，每个入库的文档由多个字段构成（文章标题、作者、发布时间、原文链接、正文内容）。</p>
</li>
<li><p>包含N个字段的文档（Dcument）在入库前需要经过切词索引，切词规则由语言分析器（analyzer）完成。</p>
</li>
<li><p>切分后的”单词“被注册到索引树上，供查询使用。另需要将其他不需要索引的内容入库，所有这些文件操作由storage完成。</p>
</li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">createIndex</span><span class="params">(String path)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">boolean</span> first=<span class="keyword">true</span>;</div><div class="line">        <span class="comment">//记录开始创建索引的时间</span></div><div class="line">        Date date1=<span class="keyword">new</span> Date();</div><div class="line">        <span class="comment">//获取路径下的所有文件集合</span></div><div class="line">        List&lt;File&gt; fileList=getFileList(path);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span>(File f:fileList)&#123;</div><div class="line">                <span class="comment">//从"."开始取子字符串 取文件后缀</span></div><div class="line">                String type =f.getName().substring(f.getName().lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>);</div><div class="line">                <span class="comment">//1.读取txt文件的内容</span></div><div class="line">                <span class="keyword">if</span>(<span class="string">"txt"</span>.equalsIgnoreCase(type)) &#123;</div><div class="line">                    <span class="comment">//取得文件所有内容</span></div><div class="line">                    con = txt2String(f);</div><div class="line">                &#125;</div><div class="line">     </div><div class="line">                <span class="comment">//2.向本地文件存储索引</span></div><div class="line">                File indexFile = <span class="keyword">new</span> File(INDEX_DIR);</div><div class="line">              	<span class="comment">//如果索引不存在则创建</span></div><div class="line">                <span class="keyword">if</span>(!indexFile.exists())&#123;</div><div class="line">                    indexFile.mkdirs();</div><div class="line">                &#125;</div><div class="line">                indexWriter = <span class="keyword">new</span> IndexWriter(INDEX_DIR,analyzer,first);</div><div class="line">                first=<span class="keyword">false</span>;</div><div class="line">        </div><div class="line">                <span class="comment">//3.提取内容，进行索引的存储</span></div><div class="line">                Document document=<span class="keyword">new</span> Document();</div><div class="line">                Field filename = <span class="keyword">new</span> Field(<span class="string">"filename"</span>,con.get(<span class="number">0</span>), Field.Store.YES,Field.Index.TOKENIZED);</div><div class="line">                filename.setBoost(<span class="number">100</span>);</div><div class="line">                Field editor = <span class="keyword">new</span> Field(<span class="string">"editor"</span>,con.get(<span class="number">2</span>), Field.Store.YES,Field.Index.TOKENIZED);</div><div class="line">              	<span class="comment">//设置内容权重</span></div><div class="line">                editor.setBoost(<span class="number">80</span>);</div><div class="line">                document.add(filename);</div><div class="line">                Field content = <span class="keyword">new</span> Field(<span class="string">"content"</span>,con.get(con.size()-<span class="number">1</span>), Field.Store.YES,Field.Index.TOKENIZED);</div><div class="line">                content.setBoost(<span class="number">50</span>);</div><div class="line">                document.add(<span class="keyword">new</span> Field(<span class="string">"date"</span>,con.get(<span class="number">3</span>), Field.Store.YES,Field.Index.UN_TOKENIZED));</div><div class="line">                document.add(editor);</div><div class="line">                document.add(<span class="keyword">new</span> Field(<span class="string">"url"</span>,con.get(<span class="number">1</span>),Field.Store.YES,Field.Index.NO));</div><div class="line">                document.add(content);</div><div class="line">                document.add(<span class="keyword">new</span> Field(<span class="string">"path"</span>,f.getPath(), Field.Store.YES,Field.Index.NO));</div><div class="line">                <span class="comment">//4.索引对象加入索引创建中</span></div><div class="line">                indexWriter.addDocument(document);</div><div class="line">                <span class="comment">//提交索引并关闭</span></div><div class="line">                closeWriter();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        Date date2=<span class="keyword">new</span> Date();</div><div class="line">        System.out.println(<span class="string">"创建索引成功\t耗时： "</span>+(date2.getTime()-date1.getTime())+<span class="string">"ms\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/23/Python爬虫/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/23/Python爬虫/" itemprop="url">
                  Python爬虫--《山大主页》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-23T00:00:00+08:00">
                2017-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h1><h2 id="URL管理器"><a href="#URL管理器" class="headerlink" title="URL管理器"></a>URL管理器</h2><p>声明两个集合 new_urls,old_urls. 一个存储待爬取的URL，一个存储已经爬取过的URLS。其中有四个函数，分别是</p>
<ul>
<li>add_new_url: 如果传入的url不在带爬取页面和已爬取页面中，向new_urls中加入一个新的待爬取页面。</li>
<li>add_new_urls:传入很多urls，将urls的每一个url调用add_new_url判断是否加入待爬取集合中</li>
<li>has_new_url:判断是否有待爬取页面</li>
<li>get_new_url:从待爬取集合中返回一个url并将其加入已爬取集合中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlManager</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.new_urls = set()</div><div class="line">        self.old_urls = set()</div><div class="line">    <span class="comment"># 向管理器添加url</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_url</span><span class="params">(self, url)</span>:</span></div><div class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 如果URL不在待爬取页面和已爬取页面中，将页面加入到待爬取页面</span></div><div class="line">        <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.new_urls <span class="keyword">and</span> url <span class="keyword">not</span> <span class="keyword">in</span> self.old_urls:</div><div class="line">            self.new_urls.add(url)</div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_urls</span><span class="params">(self, urls)</span>:</span></div><div class="line">        <span class="comment"># 如果urls为空 或者 其长度为0 退出</span></div><div class="line">        <span class="keyword">if</span> urls <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(urls) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 调用单个url加入到集合中</span></div><div class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</div><div class="line">            self.add_new_url(url)</div><div class="line"></div><div class="line">    <span class="comment"># 是否有新的url</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_new_url</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 长度不为0表明有待爬取的url</span></div><div class="line">        <span class="keyword">return</span> len(self.new_urls) != <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_url</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 从待获取url集合中获取一个url，并加入到已爬取集合</span></div><div class="line">        new_url = self.new_urls.pop()</div><div class="line">        self.old_urls.add(new_url)</div><div class="line">        <span class="keyword">return</span> new_url</div></pre></td></tr></table></figure>
<h2 id="URL下载器"><a href="#URL下载器" class="headerlink" title="URL下载器"></a>URL下载器</h2><p>将传入的url，使用urllib2.urlopen下载，并返回结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, url)</span>:</span></div><div class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        response = urllib2.urlopen(url)</div><div class="line">        <span class="keyword">if</span> response.getcode() != <span class="number">200</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span> response.read()</div></pre></td></tr></table></figure>
<h2 id="URL解析器"><a href="#URL解析器" class="headerlink" title="URL解析器"></a>URL解析器</h2><ul>
<li>_get_new_urls: 根据传入的BeautifulSoup对象查找符合要求的url，即需要爬取的url。找到所有a标签中符合url标准的 href值。并且根据格式生成对应的url加入到new_urls集合中。</li>
<li>_get_new_data: 解析页面中的数据，声明一个字典res_data，保存url、title、date、content、author</li>
<li>parse: 传入页面内容和url，分别爬取页面的url和data并返回</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> urlparse</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlParser</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_new_urls</span><span class="params">(self, page_url, soup)</span>:</span></div><div class="line">        new_urls = set()</div><div class="line">        <span class="comment"># view.sdu.edu.cn/new/2017~~~~</span></div><div class="line">        <span class="comment">#^\d+/([^# ]*)| 导航栏： ^/new/\w+/$  上下一页^\w+/\d+.html ：sdnews/23.html  ^/new/\w+/$</span></div><div class="line">        links = soup.find_all(<span class="string">'a'</span>, href=re.compile(<span class="string">r"^\d+/([^# ]*)|^/new/\w+|^\w+/\d+.html"</span>))    <span class="comment"># 正则表达式  /view/123.htm</span></div><div class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</div><div class="line">            new_url = link[<span class="string">'href'</span>]</div><div class="line">            <span class="comment"># print (new_url)</span></div><div class="line">            <span class="keyword">if</span> new_url[<span class="number">0</span>:<span class="number">4</span>] == <span class="string">"/new"</span>:</div><div class="line">                new_full_url = urlparse.urljoin(page_url, new_url)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                new_full_url = <span class="string">"http://www.view.sdu.edu.cn/new/"</span>+new_url</div><div class="line">            <span class="comment">#</span></div><div class="line">            <span class="comment"># print (new_full_url)</span></div><div class="line">            new_urls.add(new_full_url)</div><div class="line">        <span class="keyword">return</span> new_urls</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_new_data</span><span class="params">(self, page_url, soup)</span>:</span></div><div class="line">        <span class="comment"># 解析数据</span></div><div class="line">        res_data = &#123;&#125;</div><div class="line">        res_data[<span class="string">'url'</span>] = page_url</div><div class="line">        <span class="comment"># &lt;div class="text"&gt; &lt;h1&gt;山东大学召开创新转化学院课程与教材建设研讨会&lt;/h1&gt;</span></div><div class="line">        <span class="keyword">if</span> soup.find(<span class="string">'div'</span>, class_=<span class="string">"text"</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 标题</span></div><div class="line">        title_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"text"</span>).find(<span class="string">'h1'</span>)</div><div class="line">        res_data[<span class="string">'title'</span>] = title_node.get_text()</div><div class="line">        <span class="comment"># 时间</span></div><div class="line">        <span class="comment">#&lt;div class="text_a"&gt;</span></div><div class="line">        date_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"text_a"</span>)</div><div class="line">        res_data[<span class="string">'date'</span>] = date_node.get_text()</div><div class="line"></div><div class="line">        <span class="comment"># &lt;div class="text_s" id="content"&gt;</span></div><div class="line">        <span class="comment"># 内容</span></div><div class="line">        summary_node = soup.find(<span class="string">'div'</span>, class_=<span class="string">"text_s"</span>, id=<span class="string">"content"</span>)</div><div class="line">        res_data[<span class="string">'summary'</span>] = summary_node.get_text()</div><div class="line">        <span class="comment"># &lt;div class ="text_c" &gt; 【作者：邹晓东　来自：《文史】 &lt; / div &gt;</span></div><div class="line">        <span class="comment"># 作者</span></div><div class="line">        author_node = soup.find(<span class="string">'div'</span>,class_=<span class="string">"text_c"</span>)</div><div class="line">        res_data[<span class="string">'author'</span>] = author_node.get_text()</div><div class="line">        <span class="keyword">return</span> res_data</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, page_url, html_cont)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> page_url <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> html_cont <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        soup = BeautifulSoup(html_cont, <span class="string">'html.parser'</span>, from_encoding=<span class="string">'utf-8'</span>)</div><div class="line">        <span class="comment"># soup = BeautifulSoup(html_cont)</span></div><div class="line">        new_urls = self._get_new_urls(page_url, soup)</div><div class="line">        new_data = self._get_new_data(page_url, soup)</div><div class="line">        <span class="keyword">return</span> new_urls, new_data</div></pre></td></tr></table></figure>
<h2 id="DATA输出器"><a href="#DATA输出器" class="headerlink" title="DATA输出器"></a>DATA输出器</h2><p>集合datas保存所有内容</p>
<ul>
<li>collect_data: 保存所有爬取的新闻内容数据</li>
<li>output_html: 将datas中所有保存的数据写入到文件中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlOutputer</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.datas = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect_data</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        self.datas.append(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_html</span><span class="params">(self)</span>:</span></div><div class="line">        foutAll = open(<span class="string">'output.html'</span>, <span class="string">'w'</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;meta charset=\"UTF-8\"&gt;"</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;html&gt;"</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;body&gt;"</span>)</div><div class="line">        foutAll.write(<span class="string">"&lt;table&gt;"</span>)</div><div class="line">        count = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> self.datas:</div><div class="line">            <span class="comment">#记录每一篇文章的html</span></div><div class="line">            foutAll.write(<span class="string">"&lt;tr&gt;"</span>)</div><div class="line">            foutAll.write(<span class="string">"&lt;td&gt;&lt;a href=%s&gt;%s&lt;/a&gt;&lt;/td&gt;"</span> % (data[<span class="string">'url'</span>], data[<span class="string">'url'</span>]))</div><div class="line">            foutAll.write(<span class="string">"&lt;td&gt;%d&lt;/td&gt;"</span> % count)</div><div class="line">            foutAll.write(<span class="string">"&lt;td&gt;%s&lt;/td&gt;"</span> % data[<span class="string">'title'</span>].encode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line">            fout=open(<span class="string">'test/%d'</span> % count, <span class="string">'w'</span>)</div><div class="line">            fout.write(data[<span class="string">'title'</span>].encode(<span class="string">'utf-8'</span>))</div><div class="line">            fout.write(data[<span class="string">'summary'</span>].encode(<span class="string">'utf-8'</span>))</div><div class="line">            fout.write(data[<span class="string">'url'</span>])</div><div class="line">            fout.close()</div><div class="line">            count += <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="爬虫启动器"><a href="#爬虫启动器" class="headerlink" title="爬虫启动器"></a>爬虫启动器</h2><ul>
<li>初始化爬虫对象：URL管理器、URL下载器、URL解析器、URL输出器</li>
<li>爬虫调度程序：将root_url加入到URL管理器的待爬集合中。如果待爬集合不为空循环执行：取一个url，将其内容下载；将url，cont传入到解析器；解析器返回页面中所有的url和data。将url加入待爬、将data加入输出器。循环结束，调用输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> html_downloader</div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> html_output</div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> html_parser</div><div class="line"><span class="keyword">from</span> Spider <span class="keyword">import</span> url_manager</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMain</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="comment"># 构造函数初始化对象</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.urls = url_manager.UrlManager()                    <span class="comment"># URL管理器</span></div><div class="line">        self.downloader = html_downloader.HtmlDownloader()      <span class="comment"># URL下载器</span></div><div class="line">        self.parser = html_parser.HtmlParser()                  <span class="comment"># URL解析器</span></div><div class="line">        self.output = html_output.HtmlOutputer()                <span class="comment"># 输出器</span></div><div class="line">    <span class="comment"># 爬虫调度程序</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">craw</span><span class="params">(self, root_url)</span>:</span></div><div class="line">        count = <span class="number">1</span></div><div class="line">        self.urls.add_new_url(root_url)</div><div class="line">        <span class="keyword">while</span> self.urls.has_new_url():</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                new_url = self.urls.get_new_url()</div><div class="line">                <span class="comment"># print 'craw %d : %s' % (count, new_url)</span></div><div class="line">                html_cont = self.downloader.download(new_url)</div><div class="line">                new_urls, new_data = self.parser.parse(new_url, html_cont)</div><div class="line">                self.urls.add_new_urls(new_urls)</div><div class="line">                self.output.collect_data(new_data)</div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'craw failed'</span></div><div class="line">                <span class="keyword">print</span> count</div><div class="line">        self.output.output_html()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># root_url = "http://www.view.sdu.edu.cn/"             # 入口地址</span></div><div class="line">    <span class="comment"># root_url = "http://www.view.sdu.edu.cn/new/2015/1028/76105.html"             # 入口地址</span></div><div class="line">    root_url = <span class="string">"http://www.view.sdu.edu.cn/"</span></div><div class="line">    <span class="comment"># root_url = "http://www.view.sdu.edu.cn/new/sdnews/"</span></div><div class="line">    obj_spider = SpiderMain()</div><div class="line">    obj_spider.craw(root_url)</div></pre></td></tr></table></figure>
<p><a href="http://download.csdn.net/detail/li201400130091/9859107" target="_blank" rel="external">源代码请参考</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/20/vocabulary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/20/vocabulary/" itemprop="url">
                  vocabulary
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-20T20:41:30+08:00">
                2017-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Media"><a href="#Media" class="headerlink" title="Media"></a>Media</h2><p>current affairs 实事    the press新闻界    the print media印刷媒体    the electronic media电子媒体news outlets新闻报道机构        无处不在的、普遍的、流行的 prevalent,ubiquitous,pervasive            be awash with,be inundated with,be saturated with    </p>
<p>lay the foundation for</p>
<p>increasingly:  Cash in China is increasingly unnecessary.</p>
<p>e-commerce</p>
<p>roughly:  roughtly the population of all Europe</p>
<p>reasonably: We may reasonably conclude that the meeting has been postponed.</p>
<p>freshman 大学一年级学生；新手    sophomore大学二年级学生    junior大学三年级学生    senior大学四年级学生</p>
<p>sampling rate    sampling frequency</p>
<p>Firefighters tried to extinguish the flame.</p>
<p>unfavorable : I got an unfavorable score. /  I am surprised you got an unfavorbale impression of him.</p>
<p>cope with: For all his learning, he didn’t know how to cope with the situation.</p>
<p>civil rights </p>
<p>Sweet are the uses of adversity. 苦尽甘来u</p>
<p>pessism    optimism</p>
<p>harassed 疲倦的，厌烦的   </p>
<p>a house among the trees</p>
<p>cyber 电脑的，网络的    cyber attack </p>
<p>glitch n.小故障  computer glitch</p>
<p>anecdote n.轶事，奇闻</p>
<p>tens of thousands of </p>
<p>vengeance n.报仇，复仇  retaliate v.报复，回敬</p>
<p>mortality n. 死亡数目 Infant mortality was 20 deaths per thousand live births in 1986.</p>
<p>allergy n.敏感症，反感 I have an allergy to animal hair.</p>
<p>lethal adj.致命的 a lethal weapon </p>
<p>oral learing: The mechanism of oral learing is largely that of continuous repetition.</p>
<p>phase out : 逐渐减少 The Palace Museum will decide whether to phase out the sale of paper tickects and sell all tickets via the internet.</p>
<p>in a bid to : 以便， in a bid to avoid too many tourists at a time.</p>
<p>set a daily visitor cap 设置每日游客访问量</p>
<p>restriction: The swimming club is open to families in the neighborhood without restriction.</p>
<p>meditated a visit to her daughter ,  He meditate on his past life.</p>
<p>reception 接待，招待会  receipt n.收据</p>
<p>The book contains many mathmatical theorems.</p>
<p>conform: I can’t conform what you said</p>
<p>entrancing music 令人陶醉的音乐</p>
<p>composite, composition, comprise</p>
<p>speculate: It’s useless to speculate why he did it.</p>
<p>cheat: I would rather fail than cheat in the examination.</p>
<p>suspicious: suspicious behavior, I was suspicious of his motives.</p>
<p>fluctuate: My weight fluctuated widly depending on how muach I ate.</p>
<p>resent-hate: I resent having to get his permission for everything I do.</p>
<p>elevation: The house is at an elevation of 1000 meters.</p>
<p>population: One third of the world’s population consume two thirds of the world’s resources.</p>
<p>fitness: fitness equipment , fitness centers ; Her fitness for the job cannot be questioned.</p>
<p>certainty: We have no certainty of success.</p>
<p>substitute: a meat substitute</p>
<p>tentative: We made a tentative arrangement to meet on Friday. tentative conclusions.</p>
<p>infectious disease,  tourist attraction旅游胜地</p>
<p>a definitive agreement/answer/statement  The definitive version of text is ready to be published.</p>
<p>Don’t keep us in suspense. Tell us what happened!</p>
<p>a muscle spasm 肌肉痉挛</p>
<p>It takes a lot of stamina to run a marathon.</p>
<p>maximum temperature 最高气温</p>
<p>There are some indications that the prices will rise.</p>
<p>eternal truth不朽的真理  She felt eternal gratitude to him for saving her life.</p>
<p>index of corpulence.肥胖指数</p>
<p>2017-05-08</p>
<p>renowned adj.有名的，有声誉的 He is renowned as novelist.</p>
<p>decisive: the decisive vote决定性的一票 .The government must take decisive action on gun control.  </p>
<p>a divorce settlement</p>
<p>He made many efforts to enhance his reputation.</p>
<p>The book shows that he is an ingenious author.</p>
<p>The knowledge is beyond my scope.知识超过了我的范围</p>
<p>Malls in the town reach saturation point.</p>
<p>He consoled her with flowers.  Nothing could console him when his pet dog died.</p>
<p>I refuse to lie about it , it’s against my principles.</p>
<p>He give me a duplicate key of his house.</p>
<p><u>Stern as he is , he is full of sympathy.</u></p>
<p>quench熄灭（镇压）  extinguish熄灭（根除） Firemen try to quench the flames raging through the building.</p>
<p>The house has an ample parlor.</p>
<p>He could no longer distinguish between illusion and reality</p>
<p>Reading good books elevates your mind.</p>
<p>The sun has bleached her yellow skirt.</p>
<p>We’re having difficulty keeping up our mortgage payments.</p>
<p>They pledged never to tell the secret.</p>
<p>a crucial factor / issue / decision</p>
<p>ambient temperature 室温  Ambient noise may come from any direction.</p>
<p>Rice is our staple food.</p>
<p>The external walls of the building.</p>
<p>Our relationship is based on reciprocal respect. 我们的关系是以相互尊重为基础的。</p>
<p>The stillness was broken by the sound of footsteps.</p>
<p>There was a suddent stillness in the air.</p>
<p>They asked him to be merciful to the prisoners.</p>
<p>He is a man always speaking with restraint.</p>
<p>She’s tired of the perpetual complaints.   </p>
<p>In his job, patience is an invalueable asset.</p>
<p>The meeting may be prolong into the evening.</p>
<p>He sent the letter our of malice.</p>
<p>Henceforth I expect you to be punctual for meeting.</p>
<ul>
<li>permanent指总是处于相同的情况和地位，可长期持续下去，永久不变</li>
<li>eternal语体较庄重，侧重指永远存在，无始无终。 </li>
<li>perpetual语气最强，指保持永久不变，没有中断的行为，永无止境地持续下去。有时用于贬义，指令人厌烦之事。</li>
</ul>
<p>You don’t have to be a dieter.</p>
<p>It’s the job of the police to enforce the law.</p>
<p>2017-05-10</p>
<p>She made an emotional plea for help.</p>
<p>Her denial of my advice hurts me.</p>
<p>There is no further reference to him in her diary</p>
<p>The dispute coule develop into open warfare.</p>
<p>Be careful not to damage other people’s property.</p>
<p>Thank you so much for your timely help.</p>
<p>Some people are never contented.</p>
<p>A new work programme for young people will be implemented.</p>
<p>It is doubtless that Taiwan belongs to China.</p>
<p>I affirm that waht he said is true.</p>
<p>The missing girl is presumed dead.</p>
<p>I am accustomed to sleeping late.</p>
<p>an elaborately decorated room</p>
<p>He was resolute in carrying out his plan.</p>
<p>2017-05-11 </p>
<p>national anthem国歌</p>
<p>think twice再三考虑</p>
<p>A smile often denotes pleasure and friendship</p>
<p>2017-05-12</p>
<p>astonishing惊人的</p>
<p>without intervention</p>
<p>epidemic： childhood obesity was neither an epidemic nor a public health problem.</p>
<p>obesity is also a risk factor for a variety of chronic diseases.</p>
<p>The company was granted a charted trade in the occupied.</p>
<p>I wouldn’t have dared to defy my teachers.</p>
<p>Adolescence is the period of transition between childhood and adulthood.</p>
<p>Her perdominant characteristic is honesty.</p>
<p>I fail to see the logic behind his argument.</p>
<p>Technically the building is a masterpiece, but few people like it.</p>
<p>To be specific, the argument in your graduation thesis is logical.</p>
<p>She was pressurized into agreeing to a merger.</p>
<p>She was expelled from his company.</p>
<p>2017-05-13 </p>
<p>Implicit in his speech was the a assumption that they guilty.</p>
<p>2017-05-14 </p>
<p>There’s only a minimal amount of risk involved.</p>
<p>If you get up early, you should not disturb others.</p>
<p>Why should I say sorry when it’s not my fault?</p>
<p>I really hate your abandonment of study.</p>
<p>2017-05-15</p>
<p>struggling with 艰苦奋斗</p>
<p>distinctly:  Though they talked in a low voice, they could be heard distinctly.</p>
<p>reportedly:  The  star is reportedly very ill.</p>
<p>engage in:  Let’s not engage in personalities.</p>
<p>category: We are divided into several categories by grades.</p>
<p>sequence: He had to attend a sequence of meetings.</p>
<p>under way: He gave his content for the project to get under way.</p>
<p>elapse:  Three years have elapsd since we met last time.</p>
<p>situated: The village is situated in a valley.</p>
<p>cleanliness: We require the cleanliness from our child.</p>
<p>designate: She was designated sportswoman of the year.</p>
<p>regulatory: There were privacy and regulatory worries.</p>
<p>inviolable: inviolable territory, the inviolable right to life</p>
<p>2017-05-16 </p>
<p>No previous experience is necessary for this job.</p>
<p>He refused the proffered assistance.</p>
<p>Children swim at the pool, under the watchful eye of lifeguards.</p>
<p>The problem is that it’s not profitable.</p>
<p>violence   ultraviolet</p>
<p>in a stew over the lost keys</p>
<p>case history</p>
<p>deviant</p>
<p>introverted</p>
<p>2017-05-18</p>
<p>His action is out of greed</p>
<p>instantaneous  He had an instantaneous response.</p>
<p>He used to be a literary agent.</p>
<p>civilized  : Such behavior is unacceptable in a civilized society.</p>
<p>faltering: A pause of faltering in speech.</p>
<p>2017-05-20</p>
<p>The realization of his ambition makes hime very happy.</p>
<p>The deficiency of this plan is very clear and it can’t possibly succeed.</p>
<p>She couldn’t stand any more of their ridicule.</p>
<p>instiution</p>
<p>2017-05-21</p>
<p>We’re not sure whether we still want to proceed the sale.</p>
<p>He had practically finished his meal when I arrived.</p>
<p>The big match tonight is England versus Spain.</p>
<p>a massive dose of a drug.</p>
<p>We restrict the number of students per class to 10</p>
<p>2017-05-22</p>
<p>institution 制度</p>
<p>fundamental adj. 基本的，基础的</p>
<p>2017-05-28</p>
<p>sponsored</p>
<p>ceaseless adj. 不断的，不停的</p>
<p>awfully adv.可怕地，非常地</p>
<h2 id="教育意义"><a href="#教育意义" class="headerlink" title="教育意义"></a>教育意义</h2><ol>
<li>gain knowledge about…… 获取关于……的知识</li>
<li>develop a wide range of skills  </li>
<li>improve/sharpen their skills</li>
<li>academic performance<ol>
<li>get good grades / achieve good grades</li>
<li>communication skills </li>
<li>problem-solving skills</li>
</ol>
</li>
<li>provide a well-rounded education<ol>
<li>have a wide range of interests and skills</li>
</ol>
</li>
<li>a broad and balance curriculum<ol>
<li>place more importance on……</li>
</ol>
</li>
<li>an optinal course</li>
<li>academic subjects</li>
<li>develop good learning habits</li>
<li>give them a sense of achievement</li>
<li>reduce distractions 减少干扰</li>
</ol>
<h2 id="Listening-List"><a href="#Listening-List" class="headerlink" title="Listening List"></a>Listening List</h2><h3 id="House-renting"><a href="#House-renting" class="headerlink" title="House renting"></a>House renting</h3><p>renting 出租、real-estate agency房屋中介、Landlord房东、Landlady女房东、deposit押金、lease租约、available可租的、unfurnished没有家具的、furnished有家具的、facilities设备、surrounding周边环境、fence篱笆、driveway车道、garage车库、corridor走廊、fountain喷泉、suburb\outskirts郊区、downtown市区、style风格、bungalow平房、flat、accommodation住宿、dormitory宿舍、motel汽车旅馆、shared social area共享休息区、Wing翼、Annex副楼、Lobby前厅、Foyer门厅、balcony阳台、a single/double bedroom 单人间/双人间、a twin room双床房、Laundry room洗衣间、Attic阁楼、Bunk bed上下铺、Wardrobe衣柜、Mirror镜子、cupboard橱柜、cabinet衣柜、drawer柜子、Mattress床垫、king/queen-size bed特大/大号床、electronics电器、Central heating中央供暖、radiator暖气片、air-conditioner空调、washing machine洗衣机、fridge冰箱、vacuum cleaner吸尘器、micro-wave oven微波炉、(Hair)dryer、cable TV有线电视、stereo system立体音响、kettle电水壶、decoration装饰、carpet地毯、pillow枕头、sheet床单、blanket毯子、curtain窗帘、shutter百叶窗、soap肥皂、shampoo香波、body wash沐浴液、body lotion润肤乳、towel浴巾、toothpaste牙膏、toothbrush牙刷、filter过滤器</p>
<h3 id="Job-hopping"><a href="#Job-hopping" class="headerlink" title="Job hopping"></a>Job hopping</h3><p>vacant position空缺职位、job applicant工作申请者、candidate求职者、day shift 日班、shift work倒班、challenging job有挑战的工作、CV=resume简历、arm badge/name badge 胸章/臂章、job interview求职面试、starting salary起薪、wage工资、commission佣金、perks红包、bonus分红、pension养老金、public house fund住房公积金、health insurance健康保险、duration时长、career plan职业规划、work irregular hours不规则工作时间、achievement成就、random selection随机选择、occupational factor职业因素、satisfaction满足感、routine work日常工作、staff advantages员工福利、window dressing橱窗展示、cashier收银员、serve customers服务客户、performance at work工作表现、performance绩效、keep an eye on stock关注库存、stimulating刺激、human resources人力资源、financial officer财政人员、public servant公务员、airplane飞机、ferry轮渡、hovercraft气垫船、tube地铁、subway地铁、underground地铁、metro地铁、cab出租车、4-wheel-drive四驱车、hybrid混合动力车、airport shuttle bus机场穿梭巴士、minibus小巴、express train高铁</p>
<h3 id="Shopping"><a href="#Shopping" class="headerlink" title="Shopping"></a>Shopping</h3><p>shop assistant售货员、counter柜台、corner shop街角小店、general store综合商店、Hypermarket大型超级市场、stall货摊、booth流动商店、kiosk报亭 公用电话亭、boutique时装精品小店、bazaar市场、arcade拱廊市场？、precinct购物区、shopping mall购物中心、department store百货商店、free parking lot免费停车场、mail-order store邮购商店、auction拍卖、second-hand store二手商店、bid喊价、discount折扣、change找零、cosmetic化妆品、stationery文具、fabrics纺织品、sports good体育用品、daily necessities日常必需品、cash现金、cheque支票、cheque book支票本、signature签名、visa、balance余额、overdraft透支、installment分期还款、duty-free shop免税店、credit card信用卡、quality质量、service服务、brand品牌、compact紧凑车型、sedan小轿车、</p>
<h3 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h3><p>barley 大麦</p>
<p>Section 3 Listen words</p>
<p>Now this is rather disturbing</p>
<p>life span 寿命   longevity寿命</p>
<p>spouse法律意义上 的伴侣   partner </p>
<p>nursing care </p>
<p>To start with ,  Since , Furthermore </p>
<p>It is the in playground that we meet each other. </p>
<p>subsidy 津贴补助 allownce</p>
<p>social security 社保 social ins</p>
<p>informative消息灵通的，资料多的，信息量大的</p>
<p>initiative主动权(计划，决定) profitable有利益的</p>
<p>rare breeds animals 稀有物种 </p>
<p>circular area </p>
<p>rear</p>
<p>address the problem解决问题</p>
<p>erect a </p>
<p>enable traffic to exit at all times.</p>
<p>Top/bottom </p>
<p>Above/ below</p>
<h2 id="连接的词汇"><a href="#连接的词汇" class="headerlink" title="连接的词汇"></a>连接的词汇</h2><h3 id="由于，因为"><a href="#由于，因为" class="headerlink" title="由于，因为"></a>由于，因为</h3><ul>
<li>on account of </li>
<li>As a result of 由于，  As a result ，因此</li>
</ul>
<h4 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h4><p>wax and wane 起伏、改变   The stock waxs and wanes</p>
<p>2017-07-09<br>primitive</p>
<p>traverse</p>
<p>throughout the course of history 贯穿历史过程</p>
<p>religious conviction 宗教信仰</p>
<p>economic gain 经济增长</p>
<h2 id="学科"><a href="#学科" class="headerlink" title="学科"></a>学科</h2><p>mathematics 数学 , arts 文科 , science 理科 , history 历史 , geometry 几何 , geography 地理 , geology 地质学</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/小作文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/小作文/" itemprop="url">
                  IELTS小作文
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T23:30:58+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="曲线图"><a href="#曲线图" class="headerlink" title="曲线图"></a>曲线图</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol>
<li>曲线的变化趋势：上升、下降、保持平稳、波动</li>
<li>特殊点：起点、终点、交点、极值点、转折点 </li>
<li>特殊曲线 ： 最高、最低 (**！！)</li>
</ol>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol>
<li>简单介绍逻辑 paraphrase    不能抄题</li>
<li>所有曲线的起点  信息处理逻辑（从大到小），相近的点一句话处理（顺序）</li>
<li>所有下降的曲线及除了交点之外的所有特点</li>
<li>所有上升的曲线及包含交点的所有特点        （按幅度分组）</li>
<li>图标的Overview  图的最大特点，第一眼看 (1)各个曲线的趋势（2）特殊曲线</li>
</ol>
<h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>按柱子的分类分段（主要方法）</p>
<p>按横坐标的组数分段（补充方法）    原则4~6</p>
<p>按时态分段（适用于)</p>
<p>分段不参考 动静</p>
<p>动态：参照 曲线图</p>
<p>静态： 1st 2nd last  将不同的柱子分开</p>
<p>与其他的关系</p>
<p>两倍关系 ：第一 的从句 将一半的带出</p>
<ol>
<li>柱状图即可提现数据变化趋势</li>
</ol>
<h2 id="饼图-pie-chart"><a href="#饼图-pie-chart" class="headerlink" title="饼图(pie chart)"></a>饼图(pie chart)</h2><ol>
<li><p>写几块？ 为什么？</p>
<p>（x-1）块，x=总块数 ；</p>
</li>
<li><p>主要特点是</p>
<p>1st 2nd last。找数字关系</p>
</li>
<li><p>写作顺序</p>
<p>从大到小</p>
</li>
<li><p>余下的块看情况，找数字之间的关系</p>
</li>
</ol>
<p>动态饼  抓主要趋势</p>
<p><strong>多个饼图 动静结合</strong></p>
<ol>
<li><p>数据的变化趋势</p>
<p>参考曲线图</p>
</li>
<li><p>具有代表性的数字</p>
<p>1^st^  2^nd^  last</p>
</li>
<li><p>数字之间的倍数</p>
<p>相等、倍数</p>
</li>
<li><p>Overview</p>
<p>寻找每个饼的overview之间的联系</p>
</li>
</ol>
<p>pie charts </p>
<p>趋势（上升、下降）：  明显的一组 不明显的一组</p>
<p>分段：</p>
<p>总结：多幅图各个击破，找最大的overview；寻找共同点。</p>
<h2 id="表格-table"><a href="#表格-table" class="headerlink" title="表格(table)"></a>表格(table)</h2><p>静态还是动态</p>
<p>​    看情况、曲线图、</p>
<p>表格的主要特点</p>
<p>​    </p>
<p>表格的overview</p>
<p>​    最大的数</p>
<p>横着看，竖着看都有结论</p>
<p>时间按  最早、第二早、最晚。</p>
<p>相关的数据关系。</p>
<p>兼顾纵横</p>
<h2 id="地图题"><a href="#地图题" class="headerlink" title="地图题"></a>地图题</h2><h4 id="历史变迁型-difference"><a href="#历史变迁型-difference" class="headerlink" title="历史变迁型(difference)"></a>历史变迁型(difference)</h4><p>Before - After: </p>
<p>difference的角度  <u>数量的变化、面积的变化、位置的变化</u></p>
<p><u>顺序  顺时针，第二幅图 按照第一幅图的顺序</u></p>
<p>基本功：</p>
<p>数量：</p>
<p>0-1修建：build , construct</p>
<p>1-0去除：remove , demolish</p>
<p>1-2倍数：倍数的表达</p>
<p>位置：</p>
<p>move to, relocate at ,<u>to in</u></p>
<p>面积：area , size </p>
<p>后面这个比前面这个变了很多</p>
<h4 id="规划类-layout"><a href="#规划类-layout" class="headerlink" title="规划类(layout)"></a>规划类(layout)</h4><p>注意比较二者的区别最后得出结论</p>
<p>总而言之，我觉得 …… 更适合 </p>
<h2 id="流程图-Flow-chart"><a href="#流程图-Flow-chart" class="headerlink" title="流程图 Flow chart"></a>流程图 Flow chart</h2><p>Life cycle生命周期</p>
<p>Production物品生产</p>
<p>基本功 ： 找谓语，词汇很关键</p>
<p>产卵spawn  生长发育 thrive</p>
<p>immigrate 人的移民</p>
<p>emmigrate 动物的迁徙  dwell     inhabit栖息</p>
<p>Washing powder</p>
<p>grind / ground   laminate  磨碎</p>
<p>process 处理(加工)</p>
<p>undergo  high temerature</p>
<p>spwan产卵 lay下蛋    thrive , grow   。  grow into 长成  live on 以……为生</p>
<p>knit</p>
<p>First , then , stage/phase , step</p>
<p>intelligible 通俗易懂</p>
<p>总结，产品 的 流程 比较清楚、清晰易懂</p>
<p>step  \ stage</p>
<h2 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h2><h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ul>
<li>上升： rise / climb / increase / soar / show an upward trend /</li>
<li>下降：fall / decline / decrease / slash大幅度削减 /detract from /descend</li>
<li>保持平稳：(keep/remain)  (stable/steady)</li>
<li>波动： fluctuate</li>
<li>显著地： obviously  / consideratly / significantly /dramaticly</li>
<li>大约：about / around / almost /approximately / roughly / just over or below / nearly</li>
<li>超过：overtake / exceed / surpass</li>
<li>展现： show / illustrate / give information about</li>
<li>很多：a great deal</li>
<li>占据：account for</li>
<li>交叠：overlap</li>
</ul>
<h3 id="静态图句型"><a href="#静态图句型" class="headerlink" title="静态图句型"></a>静态图句型</h3><p>百分之…的…被用来/被用在…了 </p>
<p><u>40% of money was used/spent in food.</u></p>
<p><u>There is 40% of money that is spent on food.</u></p>
<p><u>Money spent on food occupies/takes up/consititute/  40%  of all/collectively</u>(不适用纯数字)</p>
<p><u>The percentage/proportion of money spent on food is 40%.</u>    number(可数)/quantity/amount(不可数)</p>
<h3 id="动态图句型"><a href="#动态图句型" class="headerlink" title="动态图句型"></a>动态图句型</h3><p> A increased to XXX(单位) in 2000</p>
<p>There was an obvious decrease/increase in D(something).</p>
<p>E rose and peaked at XXX(单位) in 1990 before fell significantly to XXX [单位] in 1996</p>
<p>F soared to XXX[单位] in 1993 after a slow increase from 1990 to 1991.</p>
<p>占据  consititue ,  account for , takes up ,  occupies  species 单复数通行</p>
<p>collectively 总体、集体</p>
<p>纯数字，带单位，百分数没有单位</p>
<p>diploma  degree大学文凭        Bachelor degree学士学位</p>
<p>predict  ———  estimate  ——— calculate</p>
<p>相等</p>
<p>be + almost / around  same with   equal to  ,  similar to  ,  close to</p>
<p>There is no difference between the two in quantitative terms.</p>
<p>倍数</p>
<p>A is twice as big as B</p>
<p>A is twice bigger than B </p>
<p>The percentage of money spent on rent was 20%, which was about twice bigger than taht of clothes.</p>
<p>There was 9% of money spent entertainment, which was similar/close to that of clothes.</p>
<p>介词性：Thanks to, due to , because of </p>
<p>连词性：because , since , as , for , thus ,so</p>
<p>状语性：as a result, in this way</p>
<p>动词性：cause, lead to ,result in ,contribute to ,are involved/related/linked</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/19/迷宫问题A*搜索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/迷宫问题A*搜索/" itemprop="url">
                  A*算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T19:23:57+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h1><h1 id="A-搜索算法"><a href="#A-搜索算法" class="headerlink" title="A*搜索算法"></a>A*搜索算法</h1><blockquote>
<p><a href="http://www.cnblogs.com/mingjiatang/p/5967681.html" target="_blank" rel="external">http://www.cnblogs.com/mingjiatang/p/5967681.html</a></p>
</blockquote>
<h2 id="A-搜索算法简介"><a href="#A-搜索算法简介" class="headerlink" title="A*搜索算法简介"></a>A*搜索算法简介</h2><p>A*搜索算法是一种启发式算法。即在盲目搜索的过程加入一个启发函数，对于当前结点搜索完毕后，使用启发函数对每一个子结点的状态计算代价，选择代价最小的节点作为下一步的搜索节点。通过不断求最优，就可以找到最优解。</p>
<p>DFS，BFS都是属于盲目搜索，选择子结点是根据固定顺序选择，在某些情况下求解会产生大量的冗余步骤。而A*搜索算法会是根据一个启发函数值来判别从哪一个节点继续进行搜索。启发函数的表达形式为：</p>
<p>​                            $f(n)=g(n)+h(n)$ </p>
<p>其中$f(n)$是每个节点的估值或者代价值。$g(n)$表示从起点到搜索点的代价，$h(n)$代表搜索点到目标点的代价，$h(n)$会直接影响到A*算法的效率。</p>
<p>一种具有$f(n)=g(n)+h(n)$的启发式算法能成为A*算法的充分条件是：</p>
<ol>
<li>搜索树上存在从起点到终点的最优路径</li>
<li>问题域有限</li>
<li>所有子结点的搜索代价值都大于0</li>
<li>$h(n)\leq h*(n)$</li>
</ol>
<h2 id="A-搜索算法描述"><a href="#A-搜索算法描述" class="headerlink" title="A*搜索算法描述"></a>A*搜索算法描述</h2><p>A*算法的流程如下：</p>
<p>A*算法需要两个额外的存储空间，OPEN表和CLOSE表。</p>
<ol>
<li>初始化OPEN表和CLOSE表，将开始节点（开始节点的Hvalue和Gvalue都视为0）放入OPEN表中</li>
<li>重复下面步骤(循环)<ol>
<li>在开始列表中查找具有最小Fvalue的节点作为当前节点</li>
<li>把当前节点从OPEN表中删除，并加入到CLOSED表中</li>
<li>对当前节点的每一个相邻节点依次执行以下步骤：<ol>
<li>如果相邻节点不可通行或者该节点已经在CLOSE表中，则什么操作也不执行</li>
<li>如果该相邻节点不在OPEN表中，则将该节点添加到OEPN表中，并<u>将该相邻节点的父节点设置为当前节点</u>，同时计算保存相邻节点的Fvalue</li>
<li>如果该相邻节点在OPEN表中，则判断若经由当前节点到达该相邻节点的Fvalue是否小雨原来保存的Fvalue，若小于则将该相邻节点的父节点设置为当前节点，并重新计算该相邻节点的Fvalue</li>
<li>若当终点节点被加入到OPEN表作为待检验节点时，表示路径已经找到，此时应终止循环；若当OPEN表为空，表示没有从开始节点到终点节点的路径，此时循环结束</li>
</ol>
</li>
</ol>
</li>
<li>循环终止后，从终点节点开始沿父节点往前遍历，从后到前输出搜索路径。</li>
</ol>
<p>其中，设置相邻节点的父节点为当前节点为了记录从起始节点到终止节点的路径，方便搜索路径后对路径进行输出。</p>
<h2 id="A-算法对于八数码问题"><a href="#A-算法对于八数码问题" class="headerlink" title="A*算法对于八数码问题"></a>A*算法对于八数码问题</h2><h3 id="启发式A-算法"><a href="#启发式A-算法" class="headerlink" title="启发式A*算法"></a>启发式A*算法</h3><p>open表：存放所有待扩展的节点</p>
<p>closed表：存放所有已扩展的节点</p>
<p>spring表：存放所有待处理的节点状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;State&gt; open = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//open表</span></div><div class="line">List&lt;State&gt; closed = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">//close表</span></div><div class="line">List&lt;State&gt; spring = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">//spring表</span></div><div class="line"><span class="keyword">int</span> start[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;            <span class="comment">//初始状态数组</span></div><div class="line"><span class="keyword">int</span> goal[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;           <span class="comment">//目标状态数组</span></div><div class="line">State startState = <span class="keyword">new</span> State();         <span class="comment">//初始状态</span></div><div class="line">State goalState = <span class="keyword">new</span> State();          <span class="comment">//目标状态</span></div></pre></td></tr></table></figure>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><p>检查是否有解（逆序数）</p>
<p>将9宫格横向展开，左边的数大于右边的数的组数称为逆序数。横向平移逆序数增量为0、2或-2。纵向平移逆序数增长为0、4或-4。因此，初态和目标态的逆序数和应该是偶数。（即初态逆序奇数、末态逆序也为奇数和为偶数）若不是偶数代表此八数码无解。</p>
</li>
<li><p>初始化open表（存放待扩展的节点）、close表（存放已扩展的节点）、spring表（存放答案）、初始状态、目标状态。</p>
</li>
<li><p>计算初始状态的g、h、f值后，将初始状态加入到open表中</p>
</li>
<li><p>检查问题是否有解</p>
</li>
<li><p>循环()</p>
<ol>
<li><p>在open表中取出一个状态getOfOpen，判断是否是目标状态。是目标状态则结束</p>
</li>
<li><p>将状态getOfOpen加入closed表</p>
</li>
<li><p>将状态getOfOpen产生后继节点</p>
<ol>
<li>获取0的位置，将0进行四个方向移动的尝试，可以则移动。</li>
<li>判断该移动方向得到的结果是否与其前驱节点相似。</li>
<li>不相似创建新的状态点加入到spring中。</li>
</ol>
</li>
<li><p>检查spring表中所有的节点(state)</p>
<p>如果在open表中有相同节点(stateInOpen)。如果state的g值&lt;stateInOpen的g值，则改变open表中(stateInOpen)的参数，并将open表中的状态按gvalue重排。并从spring表删除该节点。</p>
<p>如果在closed表中有相同节点(stateInClosed)，state的g值&lt;stateInClosed的g值，则改变closed表中(stateInClosed)的参数，将stateInClosed加入open表并排序。并从spring表删除该节点</p>
<p>否则将state加入open表，并从spring表中删除该节点</p>
</li>
</ol>
</li>
</ol>
<h3 id="算法空间表示"><a href="#算法空间表示" class="headerlink" title="算法空间表示"></a>算法空间表示</h3><p>状态用一维数组表示，每个节点状态存以一个State对象存储。包括存储Fvalue，Gvalue，Hvalue。对于九宫格按行展开存入数组，用0表示移动位置（空格）。</p>
<h2 id="A-算法对于迷宫问题"><a href="#A-算法对于迷宫问题" class="headerlink" title="A*算法对于迷宫问题"></a>A*算法对于迷宫问题</h2><p>采用A*算法对迷宫路径求解中，$g(n)$和$h(n)$都采用==曼哈顿距离==，曼哈顿距离代表两个点在标准坐标上的绝对轴距总和。<br>$$<br>d(i,j)=|x_1-x_2|+|y_1-y_2|<br>$$<br>即每次获取的当前通道块，都会对其到入口通道块和出口通道开的曼哈顿距离进行计算。求算当前通道块的Fvalue进行保存。该函数满足启发式算法的充分条件1、2、3、4。</p>
<p>对于迷宫问题需要将A*算法进行更改，其中2-3-1，如果相邻节点不可通行或者该节点已经在close表或open表中，则什么也不执行；2-3-2，如果该节点不在open表和close表中，则将该节点添加到open表中，并将该节点的父节点设置为当前节点，同时计算保存相邻节点的$Fvalue$。</p>
<p>在迷宫求解中使用A*搜索算法不需要更新OPEN表中已存在节点的Fvalue，因为每个节点的位置都是确定的，所以曼哈顿九黎就是固定的。如果是带权值的网路求解最短路径，那么就需要去更新open表中节点的$Fvalue$，如$Dijkstra$算法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/Section1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/Section1/" itemprop="url">
                  Listenning notes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T23:49:00+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/English/" itemprop="url" rel="index">
                    <span itemprop="name">英语</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Listenning"><a href="#Listenning" class="headerlink" title="Listenning"></a>Listenning</h1><h3 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1"></a>Section 1</h3><ol>
<li><p>租房</p>
<ol>
<li>房租价格（数字，水电气，定金）</li>
<li>地理位置（市区、郊区）</li>
<li>内部设施（厨房）</li>
<li>外部设置（花园、车库和交通状况）</li>
<li>专有名词（房东、租客、地址）</li>
<li>生活习惯（双方的要求）</li>
<li>实地看房（时间）</li>
<li>入住后的问题（complaint）</li>
</ol>
<ul>
<li><p>支付信息：</p>
<p>currency 货币、charge 费用、cost成本、deposit押金</p>
<p>pay by cheque/check, cash, credit card</p>
<p>daliy, weekly, monthly, quarterly, annual basis</p>
</li>
<li><p>地址信息：</p>
<p>road    street    avenue    lane</p>
<p>Pallisades/West Lake Street</p>
<p>city centre = central area    市中心，中心那部分</p>
<p>downtown/urban area    市中心，闹市区</p>
<p>suburb = outskirt            郊区，边缘</p>
<p>country = rural area        农村，乡村</p>
<ul>
<li><p>常考地址</p>
<p>South Street, Market Street, Mills Road, University Drive, Hill Road, Forest Road, Cross Street, Castle Road</p>
</li>
</ul>
</li>
<li><p>参与人物：</p>
<p>房东：landlord/landlady    租户：tenant/occupant    中介：real estate agency   学校：accommodation office    出租：to let    租期：length of let</p>
</li>
<li><p>房屋类型：</p>
<p>homestay寄宿家庭, flat/apartment, student hall, dormitory dorm, halls of residence, b&amp;b</p>
</li>
<li><p>房屋类型和家用设施：</p>
<p>balcony阳台, double room双人间, bathroom, kitchen, garden花园, yard庭院, garage车库, laundry洗衣房, study书房, hall, lobby, porch走廊</p>
<p>fridge电冰箱, microwave微波炉, hairdryer吹风机, toaster烤箱, washing machine洗衣机,air-conditioner空调, heater暖气</p>
</li>
<li><p>家具用品与费用：</p>
<p>pillow, curtain, bed sheet床单, blanket毛毯, mattess床垫, towel毛巾, carpet地毯 rent, deposit押金, phone  bill, gas bill, water/electricity bill, <em><u>share petrol一起支付汽油</u></em>, utilities物业费</p>
</li>
<li><p>complaint</p>
<ul>
<li>not near the center, not near the railway station, far from the bus stop,</li>
<li>near the airport, noisy.</li>
<li>share kitchen</li>
<li>insects</li>
<li>a stranger in the next bed, have no privacy</li>
<li>have to prepare some repellent, insects haunting</li>
</ul>
</li>
<li><p>其他考点</p>
<ul>
<li>个人信息（年龄、性别、国籍、专业）</li>
<li>职业</li>
<li>饮食要求</li>
</ul>
</li>
<li><p>国籍</p>
<p>Australia/Australian</p>
<p>Canada/Canadian</p>
<p>India/Indian</p>
<p>Mexico/Mexican</p>
<p>Scotland/Scottish</p>
<p>Germany/German</p>
</li>
<li><p>职业</p>
<p>engineer, architect, secretary, cook/chef, programmer, technician, manager</p>
</li>
</ul>
</li>
<li><p>银行</p>
<ol>
<li><p>账户：</p>
<p>open an account开户    bank/pass book存折    cheque account支票账户    savings account储蓄账户    current account活期账户    deposit account定期账户    monthly savings account按月计息账户    daily interest account按天计息账户    instant account速成户头  joint account联名账户    expense    account公款支付账户    signature card签名卡    credit card信用卡    cash card现金卡    debit card借记卡    cheque guarantee card支票担保卡</p>
</li>
<li><p>人员：</p>
<p>cashier收银员   teller/clerk银行职员  accountant会计   service charge服务费    commercial/merchant bank商业银行   full refund全额偿还    extension延期   overdraw/overdraft透支   mortgage抵押    rebate回扣  payday发薪日     pay slip/envelop薪水单 a princely sum(an excessive amount)巨款  by installment 分期付款    apply for/grant  a loan 申请/批准贷款  collateral担保物    debt债务  loan贷款  statement对账单  money order汇票 unit货币单位      ounce盎司    penny便士  nickel (美/加)五分硬币  dime(美/加) 十分硬币</p>
</li>
<li><p>交易动作：</p>
<p>deposit存款    draw/withdraw取款  earn interest赚取利息 annual insterest rate年利率    service charge服务费/手续费  cheque book支票簿  cash the check(A.) /cheque(B.)兑现支票 blank cheque空白支票      traveler’s cheque旅行支票  exchange rate汇率 denomination=face value面额  value/worth面值  bill钞票  cash现金  password/code 密码  change零钱  coin硬币 four in hundred四张一百元面额  give the money in fives换成五元面额  fill out/in填写  amount in figures小写金额  amount in words大写金额</p>
</li>
</ol>
</li>
<li><p>图书馆</p>
<ol>
<li><p>图书分类</p>
<p>fiction小说   periodical期刊   journal杂志   current/back issue现刊/过刊brochure小册子,手册   prospectus说明书,章程,简介   leaflet传单   index索引 encyclopedia百科全书   front/back over封面,封底   catalog(ue)目录,目录册   bibliography文献目录,参考书目</p>
</li>
<li><p>借书规则</p>
<p>call slip借单,借书证   library card借书证   loan period借书期   renew续借   due到期   overdue过期   annual fee年费   fine罚款</p>
</li>
<li><p>借阅服务</p>
<p>librarian图书管理员   available可提供的,可借到的   in stock有库存   out an loan 已借出   Closed Reserved关闭预定   interlibrary service馆际互借服务   magnetically coded加过词条的   touch screen information service触摸屏查询台   limited number少数   book/order/reserve 预定   in advance提前   laptop笔记本(portable computer)</p>
</li>
<li><p>常考思路</p>
<ol>
<li><p>办理借书证</p>
<p>五种所需证件：ID card ,  driving licence ,  driver’s license ,  passport photos , bank statement(银行结单，银行对账单), student card</p>
</li>
<li><p>具体内容</p>
<p>A. 开关门时间： 注意周末、节假日等特殊时间</p>
<p>B. 具体情况：借阅量borrowng loads</p>
<p>C.特殊借阅物：CD（Compact Disk）/DVD(Digital Video Disk)/Video</p>
</li>
<li><p>复印</p>
<p>设备：photocopying facilities；photocopier影印机；copy，copier，printer</p>
<p>用纸：A3/A4(5 pence); black&amp;whiter ;  colour;  double sides photocopying</p>
<p>付款方式：by a card/coin</p>
</li>
<li><p>计算机房 computer room</p>
<p>24 hours online service；limited computers；book/reserve a place；24/48hours in advance; book a place for one hour / a timeslot 时间段</p>
</li>
<li><p>不同借阅条件</p>
<p>本校生在本校借：</p>
<p>本校生在外校借：</p>
<p>外校生来本校借：</p>
<p>非学生来本校借：</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/读书笔记《费尔巴》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/读书笔记《费尔巴》/" itemprop="url">
                  读书笔记《关于费尔巴的提纲》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T21:46:14+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于背景"><a href="#关于背景" class="headerlink" title="关于背景"></a>关于背景</h3><p>1845 年 2 月，马克思被法国政府驱逐，离开巴黎来到布鲁塞尔。在这里，他重读了费尔巴哈的著作，自觉意识到他的世界观与包括费尔巴哈在内的旧唯物主义有了重大的、本质的区别，在笔记本上写下了供进一步研究用的 《关于费尔巴哈的提纲》,共十一条。</p>
<h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><ol>
<li>旧唯物主义的立脚点是“市民”社会，新唯物主义的立脚点则是人类社会或社会化的人类。</li>
<li>人的思维是否具有客观的真理性，这不是一个理论的问题，而是一个实践的问题。人应该在实践中证明自己思维的真理性，即自己思维的现实性和力量，自己思维的此岸性。</li>
<li>从前的一切唯物主义（包括费尔巴哈的唯物主义）的主要缺点是：对对象、现实、感性，只是从客体的或者直观的形式去理解，而不是把它们当作感性的人的活动，当作实践去理解，不是从主体方面去理解。因此，和唯物主义相反，能动的方面却被唯心主义抽象地发展了，但只是抽象地发展了，因为唯心主义当然是不知道现实的、感性的活动本身的。</li>
<li>全部社会生活在本质上是实践的。凡是把理论引向神秘主义的神秘东西，都能在人的实践中以及对这个实践的理解中得到合理的解决。</li>
<li>直观的唯物主义，即不是把感性理解为实践活动的唯物主义至多也只能达到对单个人和市民社会的直观。</li>
<li>环境的改变和人的活动或自我改变的一致，只能被看作是并合理地理解为革命的实践。</li>
<li>费尔巴哈是从宗教上的自我异化，从世界被二重化为宗教的、想象的世界和现实的世界这一事实出发的。他做的工作是把宗教世界归结于它的世俗基础。他没有注意到，在做完这一工作之后，主要的事情还没有做。因为，世俗基础使自己从自身中分离出去，并在云霄中固定为一个独立王国，这一事实，只能用这个世俗基础的自我分裂和自我矛盾来说明。因此，对于这个世俗基础本身首先应当从它的矛盾中去理解，然后用消除矛盾的方法在实践中使之发生革命</li>
</ol>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>摘录1：《提纲》中，马克思将自己的哲学称为新唯物主义。新唯物主义的落脚点是“人类社会或社会化的人类”，而旧唯物主义的落脚点是“市民”社会。市民社会应该指的是资本主义的社会与市场的关系，而社会化的人类或人类社会指社会主义社会和市场。</p>
<p>摘录3：《提纲》通过对费尔巴哈的清算，将包括费尔巴哈等的以前的唯物主义作为批评对象。阐述了费尔巴哈旧唯物主义忽视人的主观能动性和唯心主义夸大主观能动性的错误。将马克思的思想从新的角度，阐明以实践为基础的新唯物主义哲学与旧唯物主义和唯心主义的区别。从而反映出实践是马克思主义哲学与旧哲学的根本观点。</p>
<p>摘录2、4：实践是检验真理的标准。人的认识、人的思维是否正确，只有在实践中才能证明。检验真理的标准不是主观的理念或者客观的事物，应该从实践中出发去鉴别真理。真理是人们的主观认识对客观世界的评判，而实践对联系主观与客观举足轻重。离开实践去探讨人的思维是否正确毫无意义。</p>
<p>摘录5、6:  新唯物主义的主要价值与思想在于通过实践改造实际。它认为全部的生活本质上是实践的。通过指导无产阶级通过革命去改造世界，改变不合理的制度。即通过实践认知并改变世界。</p>
<p>摘录7：马克思认为费尔巴哈的宗教观有错误，并阐述了宗教产生的社会根源，由于“世俗基础的自我分裂和自我矛盾”，才产生了人对自然的恐惧和对神的依赖。消除的办法是，对世俗基础实践改造，消灭人与人之间的矛盾。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/DFS-Search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/DFS-Search/" itemprop="url">
                  DFS_Search
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T22:43:28+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索所使用的策略是：只要可能尽可能在图中尽量“深入”。搜索从某个节点v开始探索，然后访问和这个节点邻接的一个未访问过的节点，直到该结点的所有出发边都被发现为止。 若结点v的所有出发边都被发现，搜索则回溯到v的前驱节点，来搜索该前驱节点的出发边。</p>
<p>使用颜色来标记结点的状态。每个节点的初始颜色都是白色，在节点被发现后变成灰色，在其邻接链表被扫描完成后，其颜色变为黑色。该方法保证每一个节点尽在一棵深度优先树中被访问，因此，所有的深度优先树是不相交的。</p>
<p>除了创建一个深度优先搜索森林外，深度优先搜索算法还在每个节点盖上一个时间戳。每个节点v有两个时间记录。一个是v.d记录节点第一次被发现的时间（涂上灰色的时候），第二个时间v.f是对v节点的邻接链表搜索完成的时间（涂上黑色的时候）。这些时间记录提供了重要的图结构信息，能够帮助推断深度优先搜索算法的行为。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="TianyLi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ty_Isaac">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T21:52:03+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="TianyLi" />
          <p class="site-author-name" itemprop="name">TianyLi</p>
           
              <p class="site-description motion-element" itemprop="description">It's a bolg that belongs to a industrious programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianyLi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
